{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"An open framework for modular, real-time air traffic management research","text":"<p>tangram is an open research framework for ADS-B and Mode S flight surveillance data designed for various real-time aviation research topics such as GNSS jamming detection, aviation weather monitoring, emission analysis, and airport performance monitoring.</p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p><code>tangram</code> is built on a plugin-first architecture. It provides a lightweight core application, and all major functionality, from data processing to new UI widgets, is added through <code>pip</code>-installable packages.</p> <p>The core framework includes a JavaScript-based web application and a backend powered by Python and Rust. This foundation is designed to be extended, allowing researchers to develop and integrate their own plugins for specific research needs. This modularity enables the community to contribute to the platform, encouraging collaboration and knowledge sharing.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Quickstart: A step-by-step guide to get started with tangram</li> <li>Configuration: Information on how to configure the system for your needs</li> <li>Architecture: An overview of the system architecture and components</li> <li>Plugins: Extend the system with custom functionalities</li> <li>Contribute to tangram: Guidelines for contributing to the project</li> </ul>"},{"location":"#funding","title":"Funding","text":"<p>This project is currently funded by the Dutch Research Council (NWO)'s Open Science Fund, OSF23.1.051: https://www.nwo.nl/en/projects/osf231051.</p>"},{"location":"#history","title":"History","text":"<p>In 2020, @junzis and @xoolive published a paper Detecting and Measuring Turbulence from Mode S Surveillance Downlink Data on how real-time Mode S data can be used to detect turbulence.</p> <p>Based on this method, @MichelKhalaf started developing this tool as part of his training with @xoolive in 2021, which was completed in Summer 2022. After that, the project was then lightly maintained by @xoolive and @junzis, while we have been applying for funding to continue this tool.</p> <p>And in 2023, we received funding from NWO to continue the development of this tool. With this funding, @emctoo from Shinetech was hired to work alongside us on this open-source project.</p>"},{"location":"configuration/","title":"Configuration","text":"<p><code>tangram</code> is configured through a single <code>tangram.toml</code> file. This provides a centralized and clear way to manage the entire platform, from core services to plugins.</p>"},{"location":"configuration/#example-tangramtoml","title":"Example <code>tangram.toml</code>","text":"<pre><code>[core]\n# URL for the Redis instance used for pub/sub messaging.\nredis_url = \"redis://localhost:6379\"\n\n# a list of installed plugin packages to activate.\n# tangram will look for entry points provided by these packages.\nplugins = [\n    \"tangram_system\",\n    \"tangram_jet1090\",\n    \"my_awesome_package\"\n]\n\n[server]  # (1)!\n# main FastAPI web server, which serves the\n# frontend application and plugin API routes.\nhost = \"127.0.0.1\"\nport = 2346\n\n[channel]  # (2)!\n# integrated real-time WebSocket service.\nhost = \"127.0.0.1\"\nport = 2347\n# (optional) the public-facing base URL for the channel service, e.g., \"https://tangram.example.com\".\n# use this when running behind a reverse proxy.\n# public_url = \"http://localhost:2347\"\n# a secret key used to sign JSON Web Tokens (JWTs) for authenticating\n# WebSocket connections. Change this to a strong, unique secret.\njwt_secret = \"a-better-secret-than-this\"\n\n[plugins.tangram_jet1090]  # (3)!\n# plugin-specific configuration is defined in its own table,\n# following the pattern `[plugins.&lt;plugin_package_name&gt;]`.\n# The structure of this table is defined by the plugin itself.\njet1090_channel = \"jet1090\"\nstate_vector_expire = 20\n# UI positioning\n# widgets with higher priority are displayed first (left-to-right or top-to-bottom).\ntopbar_order = 50  # (4)!\nsidebar_order = 50  # (5)!\n\n[plugins.tangram_ship162]\ntopbar_order = 100  # will appear to the left of jet1090 (100 &gt; 50)\nsidebar_order = 100\n</code></pre> <ol> <li>See <code>tangram_core.config.CoreConfig</code>.</li> <li>See <code>tangram_core.config.ServerConfig</code></li> <li>See <code>tangram_core.config.ChannelConfig</code></li> <li>See <code>tangram_core.config.HasTopbarUiConfig</code></li> <li>See <code>tangram_core.config.HasSidebarUiConfig</code></li> </ol>"},{"location":"contribute/","title":"Contribute to tangram","text":"<p>We aim to provide a quality codebase with documentation, but expect that you will find bugs and issues, and hope you will also imagine very creative plugins.</p> <p>We welcome contributions to the project, whether it is code, documentation, or bug reports.</p>"},{"location":"contribute/#bug-reports","title":"Bug reports","text":"<p>Please file bug reports on the GitHub issue tracker.</p> <p>When filing a bug report, please include the following information:</p> <ul> <li>A clear description of the issue</li> <li>Steps to reproduce the issue</li> <li>Expected and actual behaviour</li> <li>Any relevant logs or error messages</li> <li>Your environment (OS, browser, etc.)</li> </ul>"},{"location":"contribute/#bug-fixes-and-contributions","title":"Bug fixes and contributions","text":"<p>If you want to contribute code, please follow these steps:</p> <ol> <li>Fork the repository on GitHub</li> <li>Create a new branch for your feature or bug fix</li> <li>Make your changes and commit them with a clear message</li> <li>Push your changes to your forked repository</li> <li>Create a pull request against the <code>main</code> branch of the original repository</li> <li>Include a clear description of your changes and why they are needed</li> <li>Ensure your code follows the project's coding standards and passes all tests</li> <li>If your changes are related to a specific issue, reference that issue in your pull request description</li> </ol>"},{"location":"contribute/#plugins","title":"Plugins","text":"<p>If you want to share a plugin you have developed, please start by sharing a preview in the Discussions</p>"},{"location":"contribute/#style-guide","title":"Style guide","text":"<p>We do not want to be too strict about the coding standards, but we expect that you will follow the general style guides of the rest of the codebase. Ensure your contribution doesn't reformat existing code unnecessarily, as this can make it harder to review changes.</p> <p>Please take into account the <code>.editorconfig</code> file in the root of the repository, which defines the coding style for the project. You can find more information about EditorConfig here and install plugins for your favourite editor.</p>"},{"location":"contribute/#development-workflow","title":"Development Workflow","text":"<p>The project is structured as a monorepo with <code>uv</code> managing the Python workspaces and <code>pnpm</code> managing the frontend workspaces.</p>"},{"location":"contribute/#building-for-distribution","title":"Building for Distribution","text":"<p>Each Python package (the core <code>tangram</code> and its plugins) can be built into a standard wheel for distribution. The frontend assets should first be built so downstream users won't have to install npm.</p> <pre><code># from the repository root\npnpm i\npnpm build\nuv build --all-packages\n</code></pre>"},{"location":"contribute/#testing-channel-core","title":"Testing Channel Core","text":"<p>The core WebSocket logic is written in Rust. To run these tests, you need a local Redis instance:</p> <pre><code># in packages/tangram_core/rust\ncargo test --features channel\n</code></pre>"},{"location":"contribute/#continuous-integration","title":"Continuous Integration","text":"<p>The CI pipeline, defined in GitHub Actions, automates quality checks and builds. The primary steps are:</p> <ol> <li>Building Wheel: The build process above is automated for all versions from Python 3.10 to 3.13, on Linux, MacOS, Windows and processor architectures.</li> <li>Testing: Python tests are executed using <code>pytest</code> (scope is limited for now)</li> <li>Container Build: A podman image is built using the root <code>Containerfile</code>, serving as an integration test.</li> </ol> <p>Warning</p> <p>The <code>tangram_weather</code> plugin depends on the <code>eccodes</code> library, which is problematic on non-<code>x86_64</code> systems. You can choose to build the <code>eccodes</code> library from source with the <code>ECCODES_STRATEGY</code> in the container build argument.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<ul> <li>For Users: To install and run <code>tangram</code> with official plugins, start here \u00bb</li> <li>For Developers: To contribute to the <code>tangram</code> core project, set up the monorepo \u00bb</li> <li>For Plugin Authors: To build your own extensions for <code>tangram</code>, read the plugin development guide \u00bb</li> </ul>"},{"location":"quickstart/#user-quickstart","title":"User Quickstart","text":""},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following installed:</p> <ul> <li>redis 8 or above (via podman/docker or system-installed version)</li> <li>Python 3.10 or above</li> </ul>"},{"location":"quickstart/#1-install-the-tangram-core","title":"1. Install the <code>tangram</code> core","text":"uvpip <pre><code>uv tool install tangram_core\n</code></pre> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install tangram_core\n</code></pre> <p>For end users, the only supported installation method is from a package index (like PyPI) that hosts pre-built binary wheels. For developers wanting to use the latest git version, refer to the developer guide below.</p>"},{"location":"quickstart/#2-configuration","title":"2. Configuration","text":"<p>Create a <code>tangram.toml</code> file to control the application. This is where you define which plugins are active.</p> <pre><code>[core]\nredis_url = \"redis://127.0.0.1:6379\"\nplugins = []\n\n[server]\nhost = \"127.0.0.1\"\nport = 2346\n\n[channel]\nhost = \"127.0.0.1\"\nport = 2347\njwt_secret = \"a-better-secret-than-this\"\njwt_expiration_secs = 315360000\n</code></pre>"},{"location":"quickstart/#3-running-tangram","title":"3. Running <code>tangram</code>","text":"<p><code>tangram</code> uses Redis for messaging. The easiest way to run one is with a container. Install podman or docker and run:</p> <pre><code>podman run -d --rm -p 6379:6379 --name redis redis:8-alpine\n</code></pre> <p>To start tangram, run:</p> <pre><code>tangram serve --config /path/to/your/tangram.toml\n</code></pre> <p>Open your browser and navigate to http://localhost:2346 to access the web interface.</p>"},{"location":"quickstart/#4-adding-functionality-with-plugins","title":"4. Adding functionality with plugins","text":"<p>The core <code>tangram</code> application provides the shell. All features are added by installing and enabling plugins.</p>"},{"location":"quickstart/#example-1-add-system-monitoring","title":"Example 1: add system monitoring","text":"<p>The <code>tangram_system</code> plugin adds a widget to the UI that displays server metrics like CPU and memory usage. It is a pure-Python package with no external services.</p>"},{"location":"quickstart/#1-install-the-plugin-package","title":"1. Install the plugin package","text":"uvpip <pre><code>uv tool install --with tangram_system tangram_core\n</code></pre> <pre><code># assuming you have an active virtual environment with tangram_core installed\npip install tangram_system\n</code></pre>"},{"location":"quickstart/#2-enable-the-plugin-in-your-tangramtoml","title":"2. Enable the plugin in your <code>tangram.toml</code>","text":"<pre><code>[core]\nredis_url = \"redis://127.0.0.1:6379\"\nplugins = [\"tangram_system\"]\n\n[server]\n# ...\n</code></pre>"},{"location":"quickstart/#3-restart-the-server","title":"3. Restart the server","text":"<p>Stop the running <code>tangram serve</code> process (Ctrl + C) and start it again. The web interface will now include the system monitoring widget.</p>"},{"location":"quickstart/#example-2-add-live-aircraft-data","title":"Example 2: add live aircraft data","text":"<p>To display live flight data, you need the <code>tangram_jet1090</code> plugin. This plugin is more advanced, as it requires an external data source.</p>"},{"location":"quickstart/#1-run-the-jet1090-service","title":"1. Run the <code>jet1090</code> service","text":"<p>The plugin needs a running <code>jet1090</code> instance to receive Mode S/ADS-B data. The easiest way to run one is with a container.</p> Install pre-built binariesPodman/Docker <p>Follow instructions on the jet1090 documentation to install <code>jet1090</code> on your system (Shell script, Powershell or Homebrew).</p> <p>Then run it with:</p> <pre><code># connects to a public feed.\njet1090 --redis-url redis://127.0.0.1:6379 ws://feedme.mode-s.org:9876/40128@EHRD\n</code></pre> <pre><code># connects to a public feed.\npodman run -d --rm --name jet1090 \\\n--network=host \\\nghcr.io/xoolive/jet1090:latest \\\njet1090 --redis-url redis://127.0.0.1:6379 ws://feedme.mode-s.org:9876/40128@EHRD\n</code></pre> <p>Use your own receiver feed URL if you have one. See jet1090 documentation</p> <p>Tip</p> <p>The <code>jet1090</code> container is a dependency of the plugin, not the <code>tangram</code> core. You can run it on any machine as long as it can connect to your Redis instance.</p>"},{"location":"quickstart/#2-install-and-enable-the-plugin","title":"2. Install and enable the plugin","text":"<p>Just like before, install the package and add it to your <code>tangram.toml</code>.</p> uvpip <pre><code>uv tool install --with tangram_system --with tangram_jet1090 tangram_core\n</code></pre> <pre><code># assuming you have an active virtual environment with tangram_core installed\npip install tangram_jet1090\n</code></pre> <pre><code>[core]\nredis_url = \"redis://127.0.0.1:6379\"\nplugins = [\n    \"tangram_system\",\n    \"tangram_jet1090\"\n]\n</code></pre>"},{"location":"quickstart/#3-restart-tangram-serve","title":"3. Restart <code>tangram serve</code>","text":"<p>After restarting, your map should begin to populate with live aircraft data.</p> <pre><code>graph LR\n    subgraph Your Machine\n        direction LR\n        J[jet1090 container] --&gt; R[Redis]\n        T[tangram process] --&gt; R\n    end\n    subgraph Internet\n        F[Public ADS-B Feed] --&gt; J\n    end\n\n    B[Browser] --&gt; T</code></pre>"},{"location":"quickstart/#developer-quickstart","title":"Developer Quickstart","text":"<p>This guide is for setting up a development environment for the <code>tangram</code> core and builtin plugins. To extend <code>tangram</code>, start with the Backend Plugin Guide instead. This is the definitive resource for creating your own installable plugins with custom APIs and services.</p> <p>Ensure you have the following installed:</p> <ul> <li>git</li> <li>redis 8 or above (via podman/docker or system-installed version)</li> <li>Python 3.10 or above</li> <li>uv (not required, but highly recommended)</li> <li>Rust</li> <li>Node and pnpm</li> </ul> <p>To get things quickly installed:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\ncurl -fsSL https://fnm.vercel.app/install | bash\nfnm install --latest\nnpm install -g corepack\ncorepack enable pnpm\n</code></pre>"},{"location":"quickstart/#environment-setup","title":"Environment Setup","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/open-aviation/tangram.git\ncd tangram\n</code></pre> <ol> <li>Build the frontend:</li> </ol> <pre><code>pnpm i\npnpm build\n</code></pre> <p>This will create <code>node_modules</code> and <code>dist-frontend</code> within each package, for example:</p> <pre><code>$ tree packages\npackages\n\u251c\u2500\u2500 tangram_airports\n\u2502   \u251c\u2500\u2500 dist-frontend\n\u2502   \u2502   \u251c\u2500\u2500 index.css\n\u2502   \u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2502   \u251c\u2500\u2500 index.js.map\n\u2502   \u2502   \u2514\u2500\u2500 plugin.json\n\u2502   \u251c\u2500\u2500 node_modules\n\u2502   \u2502   \u2514\u2500\u2500 @open-aviation\n\u2502   \u2502       \u2514\u2500\u2500 tangram-core -&gt; ../../../tangram_core\n...\n</code></pre> <ol> <li>Ensure Redis (and any other services like <code>jet1090</code>) are running, as described in the user guide above.</li> </ol>"},{"location":"quickstart/#running-in-development-mode","title":"Running in Development Mode","text":"<p>To install the core application and all plugins in editable mode, along with useful developer utilities:</p> <pre><code>uv sync --all-packages --all-groups --all-extras\n</code></pre> <p>This will create a virtual environment at <code>.venv/</code>. For Rust-based packages, the <code>maturin</code> build backend will create shared objects under each package:</p> <pre><code>$ rg --files -u packages | rg \"so$\" | xargs stat -c \"%s %n\"\n7857160 packages/tangram_jet1090/src/tangram_jet1090/_planes.cpython-313-x86_64-linux-gnu.so\n6503144 packages/tangram_core/src/tangram_core/_core.cpython-313-x86_64-linux-gnu.so\n7049616 packages/tangram_ship162/src/tangram_ship162/_ships.cpython-313-x86_64-linux-gnu.so\n151122456 packages/tangram_history/src/tangram_history/_history.cpython-313-x86_64-linux-gnu.so\n</code></pre> <p>Tip</p> <p>By default, <code>uv sync</code> builds the Rust code in release mode, which can take up to 4 minutes.</p> <p>You may want to use <code>uv sync --config-setting 'build-args=--profile=dev'</code> instead to significantly speed up recompilation, at the cost of much larger binary sizes and worse performance.</p> <p>To start the <code>tangram</code> server, run:</p> <pre><code>uv run tangram serve --config tangram.example.toml\n</code></pre> <p>This runs the FastAPI application, the <code>channel</code> service, and all enabled backend plugins.</p> <p>The application will be available at <code>http://localhost:2346</code>.</p> <p>Frontend Development</p> <p>Hot Module Replacement (HMR) for frontend plugins is not supported. To see changes to frontend components, you must re-run <code>pnpm build</code> and restart the <code>tangram serve</code> process. If you made changes to Rust code, you may need to re-run <code>uv</code> with the <code>--force-reinstall</code> or <code>--reinstall-package</code> flag.</p> <p>To build the documentation:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>To format all Rust, Python and JS code:</p> <pre><code>just fmt\n</code></pre>"},{"location":"quickstart/#running-in-release-mode","title":"Running in Release Mode","text":"<p>Make sure the frontend is built, and run:</p> <pre><code>uv build --all-packages\n</code></pre> <p>You should see:</p> <pre><code>$ ls -sh1 dist/\ntotal 54M\n 12K tangram_airports-0.2.0-py2.py3-none-any.whl\n8.0K tangram_airports-0.2.0.tar.gz\n2.5M tangram_core-0.2.0-cp313-cp313-linux_x86_64.whl\n 64K tangram_core-0.2.0.tar.gz\n...\n</code></pre> <p>To verify things work, create a virtual environment separate from the usual <code>.venv</code> and install it:</p> <pre><code>uv venv .venv_whl\nuv pip install --python .venv_whl dist/tangram*.whl\n</code></pre> <p>To start the <code>tangram</code> server, run:</p> <pre><code>uv run --python .venv_whl tangram serve --config tangram.example.toml\n</code></pre>"},{"location":"api/core/","title":"Core","text":""},{"location":"api/core/#tangram_core","title":"tangram_core","text":""},{"location":"api/core/#tangram_core.InjectBackendState","title":"InjectBackendState  <code>module-attribute</code>","text":"<pre><code>InjectBackendState: TypeAlias = Annotated[\n    BackendState, Depends(get_state)\n]\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState","title":"BackendState  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>@dataclass\nclass BackendState:\n    redis_client: redis.Redis\n    http_client: httpx.AsyncClient\n    config: Config\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState.redis_client","title":"redis_client  <code>instance-attribute</code>","text":"<pre><code>redis_client: Redis\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState.http_client","title":"http_client  <code>instance-attribute</code>","text":"<pre><code>http_client: AsyncClient\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: Config\n</code></pre>"},{"location":"api/core/#tangram_core.Config","title":"Config  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass Config:\n    core: CoreConfig = field(default_factory=CoreConfig)\n    server: ServerConfig = field(default_factory=ServerConfig)\n    channel: ChannelConfig = field(default_factory=ChannelConfig)\n    map: MapConfig = field(default_factory=MapConfig)\n    plugins: dict[str, Any] = field(default_factory=dict)\n    cache: CacheConfig = field(default_factory=CacheConfig)\n\n    @classmethod\n    def from_file(cls, config_path: Path) -&gt; Config:\n        if sys.version_info &lt; (3, 11):\n            import tomli as tomllib\n        else:\n            import tomllib\n        from pydantic import TypeAdapter\n\n        with open(config_path, \"rb\") as f:\n            cfg_data = tomllib.load(f)\n\n        config_adapter = TypeAdapter(cls)\n        config = config_adapter.validate_python(cfg_data)\n        return config\n</code></pre>"},{"location":"api/core/#tangram_core.Config.core","title":"core  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>core: CoreConfig = field(default_factory=CoreConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.server","title":"server  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>server: ServerConfig = field(default_factory=ServerConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.channel","title":"channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>channel: ChannelConfig = field(\n    default_factory=ChannelConfig\n)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.map","title":"map  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>map: MapConfig = field(default_factory=MapConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plugins: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.cache","title":"cache  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache: CacheConfig = field(default_factory=CacheConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(config_path: Path) -&gt; Config\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Path) -&gt; Config:\n    if sys.version_info &lt; (3, 11):\n        import tomli as tomllib\n    else:\n        import tomllib\n    from pydantic import TypeAdapter\n\n    with open(config_path, \"rb\") as f:\n        cfg_data = tomllib.load(f)\n\n    config_adapter = TypeAdapter(cls)\n    config = config_adapter.validate_python(cfg_data)\n    return config\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin","title":"Plugin  <code>dataclass</code>","text":"<p>Stores the metadata and registered API routes, background services and frontend assets for a tangram plugin.</p> <p>Packages should declare an entry point in the <code>tangram_core.plugins</code> group in their <code>pyproject.toml</code> pointing to an instance of this class.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>@dataclass\nclass Plugin:\n    \"\"\"Stores the metadata and registered API routes, background services and\n    frontend assets for a tangram plugin.\n\n    Packages should declare an entry point in the `tangram_core.plugins` group\n    in their `pyproject.toml` pointing to an instance of this class.\n    \"\"\"\n\n    frontend_path: str | None = None\n    \"\"\"Path to the compiled frontend assets, *relative* to the distribution root\n    (editable) or package root (wheel).\n    \"\"\"\n    routers: list[APIRouter] = field(default_factory=list)\n    into_frontend_config_function: IntoFrontendConfigFunction | None = None\n    \"\"\"Function to parse plugin-scoped backend configuration (within the\n    `tangram.toml`) into a frontend-safe configuration object.\n\n    If not specified, the backend configuration dict is passed as-is.\"\"\"\n    lifespan: Lifespan | None = None\n    \"\"\"Async context manager for plugin initialization and teardown.\"\"\"\n    services: list[tuple[Priority, ServiceAsyncFunc]] = field(\n        default_factory=list, init=False\n    )\n    dist_name: str = field(init=False)\n    \"\"\"Name of the distribution (package) that provided this plugin, populated\n    automatically during loading.\n    \"\"\"  # we do this so plugins can know their own package name if needed\n\n    def register_service(\n        self, priority: Priority = 0\n    ) -&gt; Callable[[ServiceFunc], ServiceFunc]:\n        \"\"\"Decorator to register a background service function.\n\n        Services are long-running async functions that receive the BackendState\n        and are started when the application launches.\n        \"\"\"\n\n        def decorator(func: ServiceFunc) -&gt; ServiceFunc:\n            @functools.wraps(func)\n            async def async_wrapper(backend_state: BackendState) -&gt; None:\n                if asyncio.iscoroutinefunction(func):\n                    await func(backend_state)\n                else:\n                    await asyncio.to_thread(func, backend_state)\n\n            self.services.append((priority, async_wrapper))\n            return func\n\n        return decorator\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin.frontend_path","title":"frontend_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frontend_path: str | None = None\n</code></pre> <p>Path to the compiled frontend assets, relative to the distribution root (editable) or package root (wheel).</p>"},{"location":"api/core/#tangram_core.Plugin.routers","title":"routers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routers: list[APIRouter] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin.into_frontend_config_function","title":"into_frontend_config_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>into_frontend_config_function: (\n    IntoFrontendConfigFunction | None\n) = None\n</code></pre> <p>Function to parse plugin-scoped backend configuration (within the <code>tangram.toml</code>) into a frontend-safe configuration object.</p> <p>If not specified, the backend configuration dict is passed as-is.</p>"},{"location":"api/core/#tangram_core.Plugin.lifespan","title":"lifespan  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lifespan: Lifespan | None = None\n</code></pre> <p>Async context manager for plugin initialization and teardown.</p>"},{"location":"api/core/#tangram_core.Plugin.services","title":"services  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>services: list[tuple[Priority, ServiceAsyncFunc]] = field(\n    default_factory=list, init=False\n)\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin.dist_name","title":"dist_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dist_name: str = field(init=False)\n</code></pre> <p>Name of the distribution (package) that provided this plugin, populated automatically during loading.</p>"},{"location":"api/core/#tangram_core.Plugin.register_service","title":"register_service","text":"<pre><code>register_service(\n    priority: Priority = 0,\n) -&gt; Callable[[ServiceFunc], ServiceFunc]\n</code></pre> <p>Decorator to register a background service function.</p> <p>Services are long-running async functions that receive the BackendState and are started when the application launches.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>def register_service(\n    self, priority: Priority = 0\n) -&gt; Callable[[ServiceFunc], ServiceFunc]:\n    \"\"\"Decorator to register a background service function.\n\n    Services are long-running async functions that receive the BackendState\n    and are started when the application launches.\n    \"\"\"\n\n    def decorator(func: ServiceFunc) -&gt; ServiceFunc:\n        @functools.wraps(func)\n        async def async_wrapper(backend_state: BackendState) -&gt; None:\n            if asyncio.iscoroutinefunction(func):\n                await func(backend_state)\n            else:\n                await asyncio.to_thread(func, backend_state)\n\n        self.services.append((priority, async_wrapper))\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/core/#tangram_core.backend","title":"backend","text":""},{"location":"api/core/#tangram_core.backend.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.InjectBackendState","title":"InjectBackendState  <code>module-attribute</code>","text":"<pre><code>InjectBackendState: TypeAlias = Annotated[\n    BackendState, Depends(get_state)\n]\n</code></pre>"},{"location":"api/core/#tangram_core.backend.CACHE_PARAM_PATTERN","title":"CACHE_PARAM_PATTERN  <code>module-attribute</code>","text":"<pre><code>CACHE_PARAM_PATTERN = compile('\\\\{(\\\\w+)\\\\}')\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState","title":"BackendState  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>@dataclass\nclass BackendState:\n    redis_client: redis.Redis\n    http_client: httpx.AsyncClient\n    config: Config\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState.redis_client","title":"redis_client  <code>instance-attribute</code>","text":"<pre><code>redis_client: Redis\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState.http_client","title":"http_client  <code>instance-attribute</code>","text":"<pre><code>http_client: AsyncClient\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: Config\n</code></pre>"},{"location":"api/core/#tangram_core.backend.get_state","title":"get_state  <code>async</code>","text":"<pre><code>get_state(request: Request) -&gt; BackendState\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def get_state(request: Request) -&gt; BackendState:\n    return request.app.state.backend_state  # type: ignore\n</code></pre>"},{"location":"api/core/#tangram_core.backend.get_distribution_path","title":"get_distribution_path","text":"<pre><code>get_distribution_path(dist_name: str) -&gt; Path\n</code></pre> <p>Get the local path of a distribution, handling both editable installs (<code>direct_url.json</code>) and standard wheel installs.</p> <p>See: https://packaging.python.org/en/latest/specifications/direct-url-data-structure/</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def get_distribution_path(dist_name: str) -&gt; Path:\n    \"\"\"Get the local path of a distribution, handling both editable installs\n    (`direct_url.json`) and standard wheel installs.\n\n    See: https://packaging.python.org/en/latest/specifications/direct-url-data-structure/\n    \"\"\"\n    # always try direct_url.json first (e.g. for the case of `uv sync --all-packages`)\n    try:\n        dist = Distribution.from_name(dist_name)\n        if direct_url_content := dist.read_text(\"direct_url.json\"):\n            direct_url_data = json.loads(direct_url_content)\n            if (\n                (url := direct_url_data.get(\"url\"))\n                # url may point to a git or zip archive, but since we only care\n                # about local paths, we only handle the file:// scheme here\n                and url.startswith(\"file://\")\n                and (\n                    path1 := Path(urllib.parse.unquote(urllib.parse.urlparse(url).path))\n                ).is_dir()\n            ):\n                return path1\n    except (PackageNotFoundError, json.JSONDecodeError, FileNotFoundError):\n        pass\n\n    # fallback in case it was installed via a wheel\n    if (trav := importlib.resources.files(dist_name)).is_dir():\n        with importlib.resources.as_file(trav) as path2:\n            return path2\n    raise FileNotFoundError(f\"could not find distribution path for {dist_name}\")\n</code></pre>"},{"location":"api/core/#tangram_core.backend.resolve_frontend","title":"resolve_frontend","text":"<pre><code>resolve_frontend(plugin: Plugin) -&gt; Path | None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def resolve_frontend(plugin: Plugin) -&gt; Path | None:\n    if not plugin.frontend_path:\n        return None\n    return get_distribution_path(plugin.dist_name) / plugin.frontend_path\n</code></pre>"},{"location":"api/core/#tangram_core.backend.load_enabled_plugins","title":"load_enabled_plugins","text":"<pre><code>load_enabled_plugins(config: Config) -&gt; list[Plugin]\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def load_enabled_plugins(\n    config: Config,\n) -&gt; list[Plugin]:\n    loaded_plugins = []\n    enabled_plugin_names = set(config.core.plugins)\n\n    for entry_point in scan_plugins():\n        # TODO: should we check entry_point.dist.name instead?\n        if entry_point.name not in enabled_plugin_names:\n            continue\n        if (plugin := load_plugin(entry_point)) is not None:\n            loaded_plugins.append(plugin)\n\n    return loaded_plugins\n</code></pre>"},{"location":"api/core/#tangram_core.backend.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(\n    app: FastAPI,\n    backend_state: BackendState,\n    loaded_plugins: Iterable[Plugin],\n) -&gt; AsyncGenerator[None, None]\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(\n    app: FastAPI, backend_state: BackendState, loaded_plugins: Iterable[Plugin]\n) -&gt; AsyncGenerator[None, None]:\n    async with AsyncExitStack() as stack:\n        for plugin in loaded_plugins:\n            if plugin.lifespan:\n                logger.info(f\"initializing lifespan for {plugin.dist_name}\")\n                await stack.enter_async_context(plugin.lifespan(backend_state))\n\n        app.state.backend_state = backend_state\n        yield\n</code></pre>"},{"location":"api/core/#tangram_core.backend.default_cache_dir","title":"default_cache_dir","text":"<pre><code>default_cache_dir() -&gt; Path\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def default_cache_dir() -&gt; Path:\n    if (xdg_cache := os.environ.get(\"XDG_CACHE_HOME\")) is not None:\n        cache_dir = Path(xdg_cache) / \"tangram\"\n    else:\n        cache_dir = Path(platformdirs.user_cache_dir(appname=\"tangram\"))\n    if not cache_dir.exists():\n        cache_dir.mkdir(parents=True, exist_ok=True)\n\n    return cache_dir\n</code></pre>"},{"location":"api/core/#tangram_core.backend.make_cache_route_handler","title":"make_cache_route_handler","text":"<pre><code>make_cache_route_handler(\n    entry: CacheEntry, state: BackendState\n) -&gt; Callable[..., Awaitable[FileResponse]]\n</code></pre> <p>Factory function that creates a route handler for caching and serving files. Dynamically handles URL parameters found in both serve_route and origin.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>CacheEntry</code> <p>Cache entry configuration</p> required <code>state</code> <code>BackendState</code> <p>Backend state with http_client for fetching remote resources</p> required <p>Returns:</p> Type Description <code>Callable[..., Awaitable[FileResponse]]</code> <p>Async function that handles the route with dynamic parameters</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def make_cache_route_handler(\n    entry: CacheEntry, state: BackendState\n) -&gt; Callable[..., Awaitable[FileResponse]]:\n    \"\"\"\n    Factory function that creates a route handler for caching and serving files.\n    Dynamically handles URL parameters found in both serve_route and origin.\n\n    :param entry: Cache entry configuration\n    :param state: Backend state with http_client for fetching remote resources\n    :returns: Async function that handles the route with dynamic parameters\n    \"\"\"\n    from inspect import Parameter, Signature\n\n    # Extract parameter names from the serve_route (e.g., {fontstack}, {range})\n    params = CACHE_PARAM_PATTERN.findall(entry.serve_route)\n\n    async def cache_route_handler(**kwargs: str) -&gt; FileResponse:\n        if (local_path := entry.local_path) is None:\n            local_path = default_cache_dir()\n        else:\n            local_path = local_path.expanduser()\n\n        # Build the local file path by replacing parameters\n        local_file = local_path\n        for param in params:\n            if param in kwargs:\n                local_file = local_file / kwargs[param]\n\n        logger.info(f\"Serving cached file from {local_file}\")\n\n        if not local_file.exists():\n            assert entry.origin is not None\n            # Build the remote URL by replacing parameters\n            remote_url = entry.origin\n            for param, value in kwargs.items():\n                remote_url = remote_url.replace(f\"{{{param}}}\", value)\n\n            logger.info(f\"Downloading from {remote_url} to {local_file}\")\n            c = await state.http_client.get(remote_url)\n            c.raise_for_status()\n            local_file.parent.mkdir(parents=True, exist_ok=True)\n            local_file.write_bytes(c.content)\n\n        return FileResponse(path=local_file, media_type=entry.media_type)\n\n    # Create explicit parameters for the function signature\n    sig_params = [\n        Parameter(\n            name=param,\n            kind=Parameter.POSITIONAL_OR_KEYWORD,\n            annotation=str,\n        )\n        for param in params\n    ]\n    cache_route_handler.__signature__ = Signature(  # type: ignore\n        parameters=sig_params,\n        return_annotation=FileResponse,\n    )\n\n    return cache_route_handler\n</code></pre>"},{"location":"api/core/#tangram_core.backend.create_app","title":"create_app","text":"<pre><code>create_app(\n    backend_state: BackendState,\n    loaded_plugins: Iterable[Plugin],\n) -&gt; FastAPI\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def create_app(\n    backend_state: BackendState,\n    loaded_plugins: Iterable[Plugin],\n) -&gt; FastAPI:\n    app = FastAPI(\n        lifespan=partial(\n            lifespan, backend_state=backend_state, loaded_plugins=loaded_plugins\n        ),\n        default_response_class=ORJSONResponse,\n    )\n    frontend_plugins = {}\n\n    for plugin in loaded_plugins:\n        for router in plugin.routers:\n            app.include_router(router)\n\n        if (frontend_path_resolved := resolve_frontend(plugin)) is not None:\n            app.mount(\n                f\"/plugins/{plugin.dist_name}\",\n                StaticFiles(directory=str(frontend_path_resolved)),\n                name=plugin.dist_name,\n            )\n            plugin_json_path = frontend_path_resolved / \"plugin.json\"\n            if plugin_json_path.exists():\n                try:\n                    with plugin_json_path.open(\"rb\") as f:\n                        plugin_meta = json.load(f)\n\n                    conf_backend = backend_state.config.plugins.get(\n                        plugin.dist_name, {}\n                    )\n                    if to_frontend_conf := plugin.into_frontend_config_function:\n                        conf_frontend = to_frontend_conf(conf_backend)\n                    else:\n                        conf_frontend = conf_backend\n\n                    plugin_meta[\"config\"] = conf_frontend\n                    frontend_plugins[plugin.dist_name] = plugin_meta\n                except Exception as e:\n                    logger.error(\n                        f\"failed to read plugin.json for {plugin.dist_name}: {e}\"\n                    )\n\n    # unlike v0.1 which uses `process.env`, v0.2 *compiles* the js so we no\n    # no longer have access to it, so we selectively forward the config.\n    @app.get(\"/config\")\n    async def get_frontend_config(\n        state: Annotated[BackendState, Depends(get_state)],\n    ) -&gt; FrontendConfig:\n        channel_cfg = state.config.channel\n        if channel_cfg.public_url:\n            channel_url = channel_cfg.public_url\n        else:\n            # for local/non-proxied setups, user must set a reachable host.\n            # '0.0.0.0' is for listening, not connecting.\n            host = \"localhost\" if channel_cfg.host == \"0.0.0.0\" else channel_cfg.host\n            channel_url = f\"http://{host}:{channel_cfg.port}\"\n\n        return FrontendConfig(\n            channel=FrontendChannelConfig(url=channel_url),\n            map=state.config.map,\n        )\n\n    @app.get(\"/manifest.json\")\n    async def get_manifest() -&gt; ORJSONResponse:\n        return ORJSONResponse(content={\"plugins\": frontend_plugins})\n\n    # Cache mechanism - MUST be registered BEFORE the catch-all frontend mount\n    for cache_entry in backend_state.config.cache.entries:\n        logger.info(\n            f\"caching {cache_entry.origin} to {cache_entry.local_path} \"\n            f\"and serving at {cache_entry.serve_route}\"\n        )\n        route_handler = make_cache_route_handler(cache_entry, backend_state)\n\n        logger.info(\n            f\"Registering route: GET {cache_entry.serve_route} with dynamic params\"\n        )\n        app.add_api_route(\n            cache_entry.serve_route,\n            route_handler,\n            methods=[\"GET\"],\n            name=f\"cache-{cache_entry.serve_route.replace('/', '_')}\",\n        )\n\n    if not (\n        frontend_path := get_distribution_path(\"tangram_core\") / \"dist-frontend\"\n    ).is_dir():\n        raise ValueError(\n            f\"error: frontend {frontend_path} was not found, \"\n            \"did you run `pnpm i &amp;&amp; pnpm run build`?\"\n        )\n    app.mount(\"/\", StaticFiles(directory=str(frontend_path), html=True), name=\"core\")\n\n    return app\n</code></pre>"},{"location":"api/core/#tangram_core.backend.run_channel_service","title":"run_channel_service  <code>async</code>","text":"<pre><code>run_channel_service(config: Config) -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def run_channel_service(config: Config) -&gt; None:\n    from . import _core\n\n    _core.init_tracing_stderr(config.core.log_level)\n\n    rust_config = _core.ChannelConfig(\n        host=config.channel.host,\n        port=config.channel.port,\n        redis_url=config.core.redis_url,\n        jwt_secret=config.channel.jwt_secret,\n        jwt_expiration_secs=config.channel.jwt_expiration_secs,\n        id_length=config.channel.id_length,\n    )\n    await _core.run(rust_config)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.run_services","title":"run_services  <code>async</code>","text":"<pre><code>run_services(\n    backend_state: BackendState,\n    loaded_plugins: Iterable[Plugin],\n) -&gt; AsyncGenerator[Task[None], None]\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def run_services(\n    backend_state: BackendState,\n    loaded_plugins: Iterable[Plugin],\n) -&gt; AsyncGenerator[asyncio.Task[None], None]:\n    yield asyncio.create_task(run_channel_service(backend_state.config))\n\n    for plugin in loaded_plugins:\n        for _, service_func in sorted(\n            plugin.services, key=lambda s: (s[0], s[1].__name__)\n        ):\n            yield asyncio.create_task(service_func(backend_state))\n            logger.info(f\"started service from plugin: {plugin.dist_name}\")\n</code></pre>"},{"location":"api/core/#tangram_core.backend.run_server","title":"run_server  <code>async</code>","text":"<pre><code>run_server(\n    backend_state: BackendState,\n    loaded_plugins: list[Plugin],\n) -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def run_server(backend_state: BackendState, loaded_plugins: list[Plugin]) -&gt; None:\n    app_instance = create_app(backend_state, loaded_plugins)\n    server_config = uvicorn.Config(\n        app_instance,\n        host=backend_state.config.server.host,\n        port=backend_state.config.server.port,\n        log_config=get_log_config_dict(backend_state.config),\n    )\n    server = uvicorn.Server(server_config)\n    await server.serve()\n</code></pre>"},{"location":"api/core/#tangram_core.backend.start_tasks","title":"start_tasks  <code>async</code>","text":"<pre><code>start_tasks(config: Config) -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def start_tasks(config: Config) -&gt; None:\n    loaded_plugins = load_enabled_plugins(config)\n\n    async with AsyncExitStack() as stack:\n        redis_client = await stack.enter_async_context(\n            redis.from_url(config.core.redis_url)  # type: ignore\n        )\n        http_client = await stack.enter_async_context(httpx.AsyncClient(http2=True))\n        state = BackendState(\n            redis_client=redis_client, http_client=http_client, config=config\n        )\n\n        server_task = asyncio.create_task(run_server(state, loaded_plugins))\n        service_tasks = [s async for s in run_services(state, loaded_plugins)]\n\n        await asyncio.gather(server_task, *service_tasks)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.get_log_config_dict","title":"get_log_config_dict","text":"<pre><code>get_log_config_dict(config: Config) -&gt; dict[str, Any]\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def get_log_config_dict(config: Config) -&gt; dict[str, Any]:\n    def format_time(dt: datetime) -&gt; str:\n        return dt.astimezone(timezone.utc).strftime(\"%Y-%m-%dT%H:%M:%S.%fZ \")\n\n    return {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"handlers\": {\n            \"default\": {\n                \"class\": \"rich.logging.RichHandler\",\n                \"log_time_format\": format_time,\n                \"omit_repeated_times\": False,\n            },\n        },\n        \"root\": {\"handlers\": [\"default\"], \"level\": config.core.log_level.upper()},\n    }\n</code></pre>"},{"location":"api/core/#tangram_core.config","title":"config","text":""},{"location":"api/core/#tangram_core.config.HasTopbarUiConfig","title":"HasTopbarUiConfig","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@runtime_checkable\nclass HasTopbarUiConfig(Protocol):\n    topbar_order: int\n</code></pre>"},{"location":"api/core/#tangram_core.config.HasTopbarUiConfig.topbar_order","title":"topbar_order  <code>instance-attribute</code>","text":"<pre><code>topbar_order: int\n</code></pre>"},{"location":"api/core/#tangram_core.config.HasSidebarUiConfig","title":"HasSidebarUiConfig","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@runtime_checkable\nclass HasSidebarUiConfig(Protocol):\n    sidebar_order: int\n</code></pre>"},{"location":"api/core/#tangram_core.config.HasSidebarUiConfig.sidebar_order","title":"sidebar_order  <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int\n</code></pre>"},{"location":"api/core/#tangram_core.config.ServerConfig","title":"ServerConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass ServerConfig:\n    host: str = \"127.0.0.1\"\n    port: int = 2346\n</code></pre>"},{"location":"api/core/#tangram_core.config.ServerConfig.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host: str = '127.0.0.1'\n</code></pre>"},{"location":"api/core/#tangram_core.config.ServerConfig.port","title":"port  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port: int = 2346\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig","title":"ChannelConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass ChannelConfig:\n    # TODO: we should make it clear that host:port is for the *backend* to\n    # listen on, and not to be confused with the frontend.\n    host: str = \"127.0.0.1\"\n    port: int = 2347\n    public_url: str | None = None\n    jwt_secret: str = \"secret\"\n    jwt_expiration_secs: int = 315360000  # 10 years\n    id_length: int = 8\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host: str = '127.0.0.1'\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.port","title":"port  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port: int = 2347\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.public_url","title":"public_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>public_url: str | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.jwt_secret","title":"jwt_secret  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jwt_secret: str = 'secret'\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.jwt_expiration_secs","title":"jwt_expiration_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jwt_expiration_secs: int = 315360000\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.id_length","title":"id_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id_length: int = 8\n</code></pre>"},{"location":"api/core/#tangram_core.config.UrlConfig","title":"UrlConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass UrlConfig:\n    url: str\n    type: str = \"vector\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.UrlConfig.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"api/core/#tangram_core.config.UrlConfig.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: str = 'vector'\n</code></pre>"},{"location":"api/core/#tangram_core.config.SourceSpecification","title":"SourceSpecification  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass SourceSpecification:\n    carto: UrlConfig | None = None\n    protomaps: UrlConfig | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.SourceSpecification.carto","title":"carto  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>carto: UrlConfig | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.SourceSpecification.protomaps","title":"protomaps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>protomaps: UrlConfig | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification","title":"StyleSpecification  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass StyleSpecification:\n    sources: SourceSpecification | None = None\n    glyphs: str = \"https://cdn.protomaps.com/fonts/pbf/{fontstack}/{range}.pbf\"\n    layers: list[Any] | None = None\n    version: Literal[8] = 8\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.sources","title":"sources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sources: SourceSpecification | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.glyphs","title":"glyphs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>glyphs: str = \"https://cdn.protomaps.com/fonts/pbf/{fontstack}/{range}.pbf\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.layers","title":"layers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layers: list[Any] | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: Literal[8] = 8\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig","title":"MapConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass MapConfig:\n    style: str | StyleSpecification = (\n        \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\"\n    )\n    attribution: str = (\n        '&amp;copy; &lt;a href=\"https://www.openstreetmap.org/copyright\"&gt;'\n        \"OpenStreetMap&lt;/a&gt; contributors &amp;copy; \"\n        '&lt;a href=\"https://carto.com/attributions\"&gt;CARTO&lt;/a&gt;'\n    )\n    center_lat: float = 48.0\n    center_lon: float = 7.0\n    zoom: float = 4\n    pitch: float = 0\n    bearing: float = 0\n    lang: str = \"en\"\n    min_zoom: float = 0\n    max_zoom: float = 24\n    max_pitch: float = 70\n    allow_pitch: bool = True\n    allow_bearing: bool = True\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.style","title":"style  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>style: str | StyleSpecification = (\n    \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\"\n)\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.attribution","title":"attribution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attribution: str = '&amp;copy; &lt;a href=\"https://www.openstreetmap.org/copyright\"&gt;OpenStreetMap&lt;/a&gt; contributors &amp;copy; &lt;a href=\"https://carto.com/attributions\"&gt;CARTO&lt;/a&gt;'\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.center_lat","title":"center_lat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>center_lat: float = 48.0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.center_lon","title":"center_lon  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>center_lon: float = 7.0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.zoom","title":"zoom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zoom: float = 4\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.pitch","title":"pitch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pitch: float = 0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.bearing","title":"bearing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bearing: float = 0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.lang","title":"lang  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lang: str = 'en'\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.min_zoom","title":"min_zoom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_zoom: float = 0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.max_zoom","title":"max_zoom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_zoom: float = 24\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.max_pitch","title":"max_pitch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_pitch: float = 70\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.allow_pitch","title":"allow_pitch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_pitch: bool = True\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.allow_bearing","title":"allow_bearing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_bearing: bool = True\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig","title":"CoreConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass CoreConfig:\n    redis_url: str = \"redis://127.0.0.1:6379\"\n    plugins: list[str] = field(default_factory=list)\n    log_level: str = \"INFO\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig.redis_url","title":"redis_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis_url: str = 'redis://127.0.0.1:6379'\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plugins: list[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level: str = 'INFO'\n</code></pre>"},{"location":"api/core/#tangram_core.config.CacheEntry","title":"CacheEntry  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass CacheEntry:\n    origin: str | None = None\n    \"\"\"Origin URL. If None, the local file is served directly.\"\"\"\n    local_path: Path | None = None\n    \"\"\"Local path to cache the file.\"\"\"\n    serve_route: str = \"\"\n    \"\"\"Where to serve the file in FastAPI.\"\"\"\n    media_type: str = \"application/octet-stream\"\n    \"\"\"Media type for the response.\"\"\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.CacheEntry.origin","title":"origin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>origin: str | None = None\n</code></pre> <p>Origin URL. If None, the local file is served directly.</p>"},{"location":"api/core/#tangram_core.config.CacheEntry.local_path","title":"local_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_path: Path | None = None\n</code></pre> <p>Local path to cache the file.</p>"},{"location":"api/core/#tangram_core.config.CacheEntry.serve_route","title":"serve_route  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serve_route: str = ''\n</code></pre> <p>Where to serve the file in FastAPI.</p>"},{"location":"api/core/#tangram_core.config.CacheEntry.media_type","title":"media_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>media_type: str = 'application/octet-stream'\n</code></pre> <p>Media type for the response.</p>"},{"location":"api/core/#tangram_core.config.CacheConfig","title":"CacheConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass CacheConfig:\n    entries: list[CacheEntry] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.CacheConfig.entries","title":"entries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entries: list[CacheEntry] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config","title":"Config  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass Config:\n    core: CoreConfig = field(default_factory=CoreConfig)\n    server: ServerConfig = field(default_factory=ServerConfig)\n    channel: ChannelConfig = field(default_factory=ChannelConfig)\n    map: MapConfig = field(default_factory=MapConfig)\n    plugins: dict[str, Any] = field(default_factory=dict)\n    cache: CacheConfig = field(default_factory=CacheConfig)\n\n    @classmethod\n    def from_file(cls, config_path: Path) -&gt; Config:\n        if sys.version_info &lt; (3, 11):\n            import tomli as tomllib\n        else:\n            import tomllib\n        from pydantic import TypeAdapter\n\n        with open(config_path, \"rb\") as f:\n            cfg_data = tomllib.load(f)\n\n        config_adapter = TypeAdapter(cls)\n        config = config_adapter.validate_python(cfg_data)\n        return config\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.core","title":"core  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>core: CoreConfig = field(default_factory=CoreConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.server","title":"server  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>server: ServerConfig = field(default_factory=ServerConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.channel","title":"channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>channel: ChannelConfig = field(\n    default_factory=ChannelConfig\n)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.map","title":"map  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>map: MapConfig = field(default_factory=MapConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plugins: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.cache","title":"cache  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache: CacheConfig = field(default_factory=CacheConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(config_path: Path) -&gt; Config\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Path) -&gt; Config:\n    if sys.version_info &lt; (3, 11):\n        import tomli as tomllib\n    else:\n        import tomllib\n    from pydantic import TypeAdapter\n\n    with open(config_path, \"rb\") as f:\n        cfg_data = tomllib.load(f)\n\n    config_adapter = TypeAdapter(cls)\n    config = config_adapter.validate_python(cfg_data)\n    return config\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendChannelConfig","title":"FrontendChannelConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass FrontendChannelConfig:\n    url: str\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendChannelConfig.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendConfig","title":"FrontendConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass FrontendConfig:\n    channel: FrontendChannelConfig\n    map: MapConfig\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendConfig.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: FrontendChannelConfig\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendConfig.map","title":"map  <code>instance-attribute</code>","text":"<pre><code>map: MapConfig\n</code></pre>"},{"location":"api/core/#tangram_core.plugin","title":"plugin","text":""},{"location":"api/core/#tangram_core.plugin.ServiceAsyncFunc","title":"ServiceAsyncFunc  <code>module-attribute</code>","text":"<pre><code>ServiceAsyncFunc: TypeAlias = Callable[\n    [BackendState], Awaitable[None]\n]\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.ServiceFunc","title":"ServiceFunc  <code>module-attribute</code>","text":"<pre><code>ServiceFunc: TypeAlias = (\n    ServiceAsyncFunc | Callable[[BackendState], None]\n)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Priority","title":"Priority  <code>module-attribute</code>","text":"<pre><code>Priority: TypeAlias = int\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.IntoFrontendConfigFunction","title":"IntoFrontendConfigFunction  <code>module-attribute</code>","text":"<pre><code>IntoFrontendConfigFunction: TypeAlias = Callable[\n    [dict[str, Any]], Any\n]\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Lifespan","title":"Lifespan  <code>module-attribute</code>","text":"<pre><code>Lifespan: TypeAlias = Callable[\n    [BackendState], AsyncGenerator[None, None]\n]\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin","title":"Plugin  <code>dataclass</code>","text":"<p>Stores the metadata and registered API routes, background services and frontend assets for a tangram plugin.</p> <p>Packages should declare an entry point in the <code>tangram_core.plugins</code> group in their <code>pyproject.toml</code> pointing to an instance of this class.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>@dataclass\nclass Plugin:\n    \"\"\"Stores the metadata and registered API routes, background services and\n    frontend assets for a tangram plugin.\n\n    Packages should declare an entry point in the `tangram_core.plugins` group\n    in their `pyproject.toml` pointing to an instance of this class.\n    \"\"\"\n\n    frontend_path: str | None = None\n    \"\"\"Path to the compiled frontend assets, *relative* to the distribution root\n    (editable) or package root (wheel).\n    \"\"\"\n    routers: list[APIRouter] = field(default_factory=list)\n    into_frontend_config_function: IntoFrontendConfigFunction | None = None\n    \"\"\"Function to parse plugin-scoped backend configuration (within the\n    `tangram.toml`) into a frontend-safe configuration object.\n\n    If not specified, the backend configuration dict is passed as-is.\"\"\"\n    lifespan: Lifespan | None = None\n    \"\"\"Async context manager for plugin initialization and teardown.\"\"\"\n    services: list[tuple[Priority, ServiceAsyncFunc]] = field(\n        default_factory=list, init=False\n    )\n    dist_name: str = field(init=False)\n    \"\"\"Name of the distribution (package) that provided this plugin, populated\n    automatically during loading.\n    \"\"\"  # we do this so plugins can know their own package name if needed\n\n    def register_service(\n        self, priority: Priority = 0\n    ) -&gt; Callable[[ServiceFunc], ServiceFunc]:\n        \"\"\"Decorator to register a background service function.\n\n        Services are long-running async functions that receive the BackendState\n        and are started when the application launches.\n        \"\"\"\n\n        def decorator(func: ServiceFunc) -&gt; ServiceFunc:\n            @functools.wraps(func)\n            async def async_wrapper(backend_state: BackendState) -&gt; None:\n                if asyncio.iscoroutinefunction(func):\n                    await func(backend_state)\n                else:\n                    await asyncio.to_thread(func, backend_state)\n\n            self.services.append((priority, async_wrapper))\n            return func\n\n        return decorator\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin.frontend_path","title":"frontend_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frontend_path: str | None = None\n</code></pre> <p>Path to the compiled frontend assets, relative to the distribution root (editable) or package root (wheel).</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.routers","title":"routers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routers: list[APIRouter] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin.into_frontend_config_function","title":"into_frontend_config_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>into_frontend_config_function: (\n    IntoFrontendConfigFunction | None\n) = None\n</code></pre> <p>Function to parse plugin-scoped backend configuration (within the <code>tangram.toml</code>) into a frontend-safe configuration object.</p> <p>If not specified, the backend configuration dict is passed as-is.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.lifespan","title":"lifespan  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lifespan: Lifespan | None = None\n</code></pre> <p>Async context manager for plugin initialization and teardown.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.services","title":"services  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>services: list[tuple[Priority, ServiceAsyncFunc]] = field(\n    default_factory=list, init=False\n)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin.dist_name","title":"dist_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dist_name: str = field(init=False)\n</code></pre> <p>Name of the distribution (package) that provided this plugin, populated automatically during loading.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.register_service","title":"register_service","text":"<pre><code>register_service(\n    priority: Priority = 0,\n) -&gt; Callable[[ServiceFunc], ServiceFunc]\n</code></pre> <p>Decorator to register a background service function.</p> <p>Services are long-running async functions that receive the BackendState and are started when the application launches.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>def register_service(\n    self, priority: Priority = 0\n) -&gt; Callable[[ServiceFunc], ServiceFunc]:\n    \"\"\"Decorator to register a background service function.\n\n    Services are long-running async functions that receive the BackendState\n    and are started when the application launches.\n    \"\"\"\n\n    def decorator(func: ServiceFunc) -&gt; ServiceFunc:\n        @functools.wraps(func)\n        async def async_wrapper(backend_state: BackendState) -&gt; None:\n            if asyncio.iscoroutinefunction(func):\n                await func(backend_state)\n            else:\n                await asyncio.to_thread(func, backend_state)\n\n        self.services.append((priority, async_wrapper))\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.scan_plugins","title":"scan_plugins","text":"<pre><code>scan_plugins() -&gt; EntryPoints\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>def scan_plugins() -&gt; importlib.metadata.EntryPoints:\n    return importlib.metadata.entry_points(group=\"tangram_core.plugins\")\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.load_plugin","title":"load_plugin","text":"<pre><code>load_plugin(entry_point: EntryPoint) -&gt; Plugin | None\n</code></pre> <p>Instantiates the plugin object defined in the entry point and injects the name of the distribution into it.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>def load_plugin(\n    entry_point: importlib.metadata.EntryPoint,\n) -&gt; Plugin | None:\n    \"\"\"Instantiates the plugin object defined in the entry point\n    and injects the name of the distribution into it.\"\"\"\n    try:\n        plugin_instance = entry_point.load()\n    except Exception as e:\n        tb = traceback.format_exc()\n        logger.error(\n            f\"failed to load plugin {entry_point.name}: {e}. {tb}\"\n            f\"\\n= help: does {entry_point.value} exist?\"\n        )\n        return None\n    if not isinstance(plugin_instance, Plugin):\n        logger.error(f\"entry point {entry_point.name} is not an instance of `Plugin`\")\n        return None\n    if entry_point.dist is None:\n        logger.error(f\"could not determine distribution for plugin {entry_point.name}\")\n        return None\n    # NOTE: we ignore `entry_point.name` for now and simply use the distribution's name\n    # should we raise an error if they differ? not for now\n\n    plugin_instance.dist_name = entry_point.dist.name\n    return plugin_instance\n</code></pre>"},{"location":"api/core/#tangram_core.redis","title":"redis","text":""},{"location":"api/core/#tangram_core.redis.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/core/#tangram_core.redis.StateT","title":"StateT  <code>module-attribute</code>","text":"<pre><code>StateT = TypeVar('StateT')\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber","title":"Subscriber","text":"<p>               Bases: <code>ABC</code>, <code>Generic[StateT]</code></p> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>class Subscriber(abc.ABC, Generic[StateT]):\n    redis: Redis\n    task: asyncio.Task[None]\n    pubsub: PubSub\n\n    def __init__(\n        self, name: str, redis_url: str, channels: List[str], initial_state: StateT\n    ):\n        self.name = name\n        self.redis_url: str = redis_url\n        self.channels: List[str] = channels\n        self.state: StateT = initial_state\n        self._running = False\n\n    async def subscribe(self) -&gt; None:\n        if self._running:\n            log.warning(\"%s already running\", self.name)\n            return\n\n        try:\n            self.redis = await Redis.from_url(self.redis_url)\n            self.pubsub = self.redis.pubsub()\n            await self.pubsub.psubscribe(*self.channels)\n        except RedisError as e:\n            log.error(\"%s failed to connect to Redis: %s\", self.name, e)\n            raise\n\n        async def listen() -&gt; None:\n            try:\n                log.info(\"%s listening ...\", self.name)\n                async for message in self.pubsub.listen():\n                    log.debug(\"message: %s\", message)\n                    if message[\"type\"] == \"pmessage\":\n                        await self.message_handler(\n                            message[\"channel\"].decode(\"utf-8\"),\n                            message[\"data\"].decode(\"utf-8\"),\n                            message[\"pattern\"].decode(\"utf-8\"),\n                            self.state,\n                        )\n            except asyncio.CancelledError:\n                log.warning(\"%s cancelled\", self.name)\n\n        self._running = True\n\n        self.task = asyncio.create_task(listen())\n        log.info(\"%s task created, running ...\", self.name)\n\n    async def cleanup(self) -&gt; None:\n        if not self._running:\n            return\n\n        if self.task:\n            log.debug(\"%s canceling task ...\", self.name)\n            self.task.cancel()\n            try:\n                log.debug(\"%s await task to finish ...\", self.name)\n                await self.task\n                log.debug(\"%s task canceled\", self.name)\n            except asyncio.CancelledError as exc:\n                log.error(\"%s task canceling error: %s\", self.name, exc)\n        if self.pubsub:\n            await self.pubsub.unsubscribe()\n        if self.redis:\n            await self.redis.close()\n        self._running = False\n\n    def is_active(self) -&gt; bool:\n        \"\"\"Return True if the subscriber is actively listening.\"\"\"\n        return self._running and self.task is not None and not self.task.done()\n\n    @abc.abstractmethod\n    async def message_handler(\n        self, event: str, payload: str, pattern: str, state: StateT\n    ) -&gt; None:\n        pass\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.redis","title":"redis  <code>instance-attribute</code>","text":"<pre><code>redis: Redis\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: Task[None]\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.pubsub","title":"pubsub  <code>instance-attribute</code>","text":"<pre><code>pubsub: PubSub\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.redis_url","title":"redis_url  <code>instance-attribute</code>","text":"<pre><code>redis_url: str = redis_url\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.channels","title":"channels  <code>instance-attribute</code>","text":"<pre><code>channels: List[str] = channels\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: StateT = initial_state\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.subscribe","title":"subscribe  <code>async</code>","text":"<pre><code>subscribe() -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>async def subscribe(self) -&gt; None:\n    if self._running:\n        log.warning(\"%s already running\", self.name)\n        return\n\n    try:\n        self.redis = await Redis.from_url(self.redis_url)\n        self.pubsub = self.redis.pubsub()\n        await self.pubsub.psubscribe(*self.channels)\n    except RedisError as e:\n        log.error(\"%s failed to connect to Redis: %s\", self.name, e)\n        raise\n\n    async def listen() -&gt; None:\n        try:\n            log.info(\"%s listening ...\", self.name)\n            async for message in self.pubsub.listen():\n                log.debug(\"message: %s\", message)\n                if message[\"type\"] == \"pmessage\":\n                    await self.message_handler(\n                        message[\"channel\"].decode(\"utf-8\"),\n                        message[\"data\"].decode(\"utf-8\"),\n                        message[\"pattern\"].decode(\"utf-8\"),\n                        self.state,\n                    )\n        except asyncio.CancelledError:\n            log.warning(\"%s cancelled\", self.name)\n\n    self._running = True\n\n    self.task = asyncio.create_task(listen())\n    log.info(\"%s task created, running ...\", self.name)\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.cleanup","title":"cleanup  <code>async</code>","text":"<pre><code>cleanup() -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>async def cleanup(self) -&gt; None:\n    if not self._running:\n        return\n\n    if self.task:\n        log.debug(\"%s canceling task ...\", self.name)\n        self.task.cancel()\n        try:\n            log.debug(\"%s await task to finish ...\", self.name)\n            await self.task\n            log.debug(\"%s task canceled\", self.name)\n        except asyncio.CancelledError as exc:\n            log.error(\"%s task canceling error: %s\", self.name, exc)\n    if self.pubsub:\n        await self.pubsub.unsubscribe()\n    if self.redis:\n        await self.redis.close()\n    self._running = False\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.is_active","title":"is_active","text":"<pre><code>is_active() -&gt; bool\n</code></pre> <p>Return True if the subscriber is actively listening.</p> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>def is_active(self) -&gt; bool:\n    \"\"\"Return True if the subscriber is actively listening.\"\"\"\n    return self._running and self.task is not None and not self.task.done()\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.message_handler","title":"message_handler  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>message_handler(\n    event: str, payload: str, pattern: str, state: StateT\n) -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>@abc.abstractmethod\nasync def message_handler(\n    self, event: str, payload: str, pattern: str, state: StateT\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/core/#tangram_core._core","title":"tangram_core._core","text":""},{"location":"api/core/#tangram_core._core.ChannelConfig","title":"ChannelConfig","text":""},{"location":"api/core/#tangram_core._core.ChannelConfig.host","title":"host  <code>property</code> <code>writable</code>","text":"<pre><code>host: str\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.port","title":"port  <code>property</code> <code>writable</code>","text":"<pre><code>port: int\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.redis_url","title":"redis_url  <code>property</code> <code>writable</code>","text":"<pre><code>redis_url: str\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.jwt_secret","title":"jwt_secret  <code>property</code> <code>writable</code>","text":"<pre><code>jwt_secret: str\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.jwt_expiration_secs","title":"jwt_expiration_secs  <code>property</code> <code>writable</code>","text":"<pre><code>jwt_expiration_secs: int\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.id_length","title":"id_length  <code>property</code> <code>writable</code>","text":"<pre><code>id_length: int\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.__new__","title":"__new__","text":"<pre><code>__new__(\n    host: str,\n    port: int,\n    redis_url: str,\n    jwt_secret: str,\n    jwt_expiration_secs: int,\n    id_length: int,\n) -&gt; ChannelConfig\n</code></pre>"},{"location":"api/core/#tangram_core._core.init_tracing_stderr","title":"init_tracing_stderr","text":"<pre><code>init_tracing_stderr(filter_str: str) -&gt; None\n</code></pre>"},{"location":"api/core/#tangram_core._core.run","title":"run","text":"<pre><code>run(config: ChannelConfig) -&gt; Any\n</code></pre>"},{"location":"api/jet1090/","title":"Jet1090","text":""},{"location":"api/jet1090/#tangram_jet1090","title":"tangram_jet1090","text":""},{"location":"api/jet1090/#tangram_jet1090.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix=\"/jet1090\",\n    tags=[\"jet1090\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\",\n    routers=[router],\n    into_frontend_config_function=transform_config,\n)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.FrontendPlanesConfig","title":"FrontendPlanesConfig  <code>dataclass</code>","text":"<p>               Bases: <code>HasTopbarUiConfig</code>, <code>HasSidebarUiConfig</code></p> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass FrontendPlanesConfig(\n    tangram_core.config.HasTopbarUiConfig, tangram_core.config.HasSidebarUiConfig\n):\n    show_route_lines: bool\n    topbar_order: int\n    sidebar_order: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.FrontendPlanesConfig.show_route_lines","title":"show_route_lines  <code>instance-attribute</code>","text":"<pre><code>show_route_lines: bool\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.FrontendPlanesConfig.topbar_order","title":"topbar_order  <code>instance-attribute</code>","text":"<pre><code>topbar_order: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.FrontendPlanesConfig.sidebar_order","title":"sidebar_order  <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.FrontendPlanesConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    show_route_lines: bool,\n    topbar_order: int,\n    sidebar_order: int,\n) -&gt; None\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig","title":"PlanesConfig  <code>dataclass</code>","text":"<p>               Bases: <code>HasTopbarUiConfig</code>, <code>HasSidebarUiConfig</code></p> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass PlanesConfig(\n    tangram_core.config.HasTopbarUiConfig, tangram_core.config.HasSidebarUiConfig\n):\n    jet1090_channel: str = \"jet1090\"\n    history_table_name: str = \"jet1090\"\n    history_control_channel: str = \"history:control\"\n    state_vector_expire: int = 20\n    stream_interval_secs: float = 1.0\n    aircraft_db_url: str = (\n        \"https://jetvision.de/resources/sqb_databases/basestation.zip\"\n    )\n    jet1090_url: str = \"http://localhost:8080\"\n    path_cache: Path = Path(platformdirs.user_cache_dir(\"tangram_jet1090\"))\n    log_level: str = \"INFO\"\n    show_route_lines: bool = True\n    # flush is primarily time-based. this buffer is a backpressure mechanism.\n    history_buffer_size: int = 100_000\n    history_flush_interval_secs: int = 5\n    history_optimize_interval_secs: int = 120\n    history_optimize_target_file_size: int = 134217728\n    history_vacuum_interval_secs: int = 120\n    history_vacuum_retention_period_secs: int | None = 120\n    topbar_order: int = 50\n    sidebar_order: int = 50\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.jet1090_channel","title":"jet1090_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jet1090_channel: str = 'jet1090'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_table_name","title":"history_table_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_table_name: str = 'jet1090'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_control_channel","title":"history_control_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_control_channel: str = 'history:control'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.state_vector_expire","title":"state_vector_expire  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state_vector_expire: int = 20\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.stream_interval_secs","title":"stream_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stream_interval_secs: float = 1.0\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.aircraft_db_url","title":"aircraft_db_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aircraft_db_url: str = \"https://jetvision.de/resources/sqb_databases/basestation.zip\"\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.jet1090_url","title":"jet1090_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jet1090_url: str = 'http://localhost:8080'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.path_cache","title":"path_cache  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path_cache: Path = Path(user_cache_dir('tangram_jet1090'))\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level: str = 'INFO'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.show_route_lines","title":"show_route_lines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_route_lines: bool = True\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_buffer_size","title":"history_buffer_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_buffer_size: int = 100000\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_flush_interval_secs","title":"history_flush_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_flush_interval_secs: int = 5\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_optimize_interval_secs","title":"history_optimize_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_optimize_interval_secs: int = 120\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_optimize_target_file_size","title":"history_optimize_target_file_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_optimize_target_file_size: int = 134217728\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_vacuum_interval_secs","title":"history_vacuum_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_vacuum_interval_secs: int = 120\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_vacuum_retention_period_secs","title":"history_vacuum_retention_period_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_vacuum_retention_period_secs: int | None = 120\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.topbar_order","title":"topbar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topbar_order: int = 50\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.sidebar_order","title":"sidebar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int = 50\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    jet1090_channel: str = \"jet1090\",\n    history_table_name: str = \"jet1090\",\n    history_control_channel: str = \"history:control\",\n    state_vector_expire: int = 20,\n    stream_interval_secs: float = 1.0,\n    aircraft_db_url: str = \"https://jetvision.de/resources/sqb_databases/basestation.zip\",\n    jet1090_url: str = \"http://localhost:8080\",\n    path_cache: Path = Path(\n        user_cache_dir(\"tangram_jet1090\")\n    ),\n    log_level: str = \"INFO\",\n    show_route_lines: bool = True,\n    history_buffer_size: int = 100000,\n    history_flush_interval_secs: int = 5,\n    history_optimize_interval_secs: int = 120,\n    history_optimize_target_file_size: int = 134217728,\n    history_vacuum_interval_secs: int = 120,\n    history_vacuum_retention_period_secs: int | None = 120,\n    topbar_order: int = 50,\n    sidebar_order: int = 50,\n) -&gt; None\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_trajectory_data","title":"get_trajectory_data  <code>async</code>","text":"<pre><code>get_trajectory_data(\n    icao24: str, backend_state: InjectBackendState\n) -&gt; Response\n</code></pre> <p>Get the full trajectory for a given ICAO24 address.</p> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@router.get(\"/data/{icao24}\")\nasync def get_trajectory_data(\n    icao24: str, backend_state: tangram_core.InjectBackendState\n) -&gt; Response:\n    \"\"\"Get the full trajectory for a given ICAO24 address.\"\"\"\n    if not _HISTORY_AVAILABLE:\n        raise HTTPException(\n            status_code=501,\n            detail=\"History feature is not installed. \"\n            \"Install with `pip install 'tangram_jet1090[history]'`\",\n        )\n\n    redis_key = \"tangram:history:table_uri:jet1090\"\n    table_uri_bytes = await backend_state.redis_client.get(redis_key)\n\n    if not table_uri_bytes:\n        raise HTTPException(\n            status_code=404,\n            detail=(\n                \"Table 'jet1090' not found.\\nhelp: is the history service running?\"\n            ),\n        )\n    table_uri = table_uri_bytes.decode(\"utf-8\")\n\n    try:\n        df = (\n            pl.scan_delta(table_uri)\n            .filter(pl.col(\"icao24\") == icao24)\n            .with_columns(pl.col(\"timestamp\").dt.epoch(time_unit=\"s\"))\n            .sort(\"timestamp\")\n            .collect()\n        )\n        return Response(df.write_json(), media_type=\"application/json\")\n    except Exception as e:\n        log.error(f\"Failed to query trajectory for {icao24}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to query trajectory data.\")\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_route_data","title":"get_route_data  <code>async</code>","text":"<pre><code>get_route_data(\n    callsign: str, backend_state: InjectBackendState\n) -&gt; ORJSONResponse\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@router.get(\"/route/{callsign}\")\nasync def get_route_data(\n    callsign: str, backend_state: tangram_core.InjectBackendState\n) -&gt; ORJSONResponse:\n    url = \"https://flightroutes.opensky-network.org/api/routeset\"\n    payload = {\"planes\": [{\"callsign\": callsign}]}\n    client = backend_state.http_client\n    try:\n        response = await client.post(url, json=payload, timeout=5.0)\n        response.raise_for_status()\n        data = response.json()\n        return ORJSONResponse(content=data)\n    except Exception as e:\n        log.error(f\"Failed to fetch route data for {callsign}: {e}\")\n        return ORJSONResponse(content=[], status_code=500)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_sensors_data","title":"get_sensors_data  <code>async</code>","text":"<pre><code>get_sensors_data(\n    backend_state: InjectBackendState,\n) -&gt; ORJSONResponse\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@router.get(\"/sensors\")\nasync def get_sensors_data(\n    backend_state: tangram_core.InjectBackendState,\n) -&gt; ORJSONResponse:\n    plugin_config = backend_state.config.plugins.get(\"tangram_jet1090\", {})\n    config = TypeAdapter(PlanesConfig).validate_python(plugin_config)\n    # Keeping \"localhost\" in the URL can lead to issues on systems where localhost\n    # does not resolve to 127.0.0.1 first but rather to ::1 (IPv6).\n    # Therefore, we replace it explicitly.\n    url = f\"{config.jet1090_url}/sensors\".replace(\"localhost\", \"127.0.0.1\")\n\n    try:\n        response = await backend_state.http_client.get(url, timeout=10.0)\n        response.raise_for_status()\n        return ORJSONResponse(content=response.json())\n    except Exception as e:\n        log.error(f\"Failed to fetch sensors data from {url}: {e}\")\n        raise HTTPException(status_code=502, detail=str(e))\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.transform_config","title":"transform_config","text":"<pre><code>transform_config(\n    config_dict: dict[str, Any],\n) -&gt; FrontendPlanesConfig\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>def transform_config(config_dict: dict[str, Any]) -&gt; FrontendPlanesConfig:\n    config = TypeAdapter(PlanesConfig).validate_python(config_dict)\n    return FrontendPlanesConfig(\n        show_route_lines=config.show_route_lines,\n        topbar_order=config.topbar_order,\n        sidebar_order=config.sidebar_order,\n    )\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_aircraft_db","title":"get_aircraft_db  <code>async</code>","text":"<pre><code>get_aircraft_db(\n    client: AsyncClient, url: str, path_cache: Path\n) -&gt; dict[str, Aircraft]\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>async def get_aircraft_db(\n    client: httpx.AsyncClient, url: str, path_cache: Path\n) -&gt; dict[str, _planes.Aircraft]:\n    from . import _planes\n\n    path_cache.mkdir(parents=True, exist_ok=True)\n    zip_path = path_cache / \"basestation.zip\"\n    db_path = path_cache / \"basestation.sqb\"\n\n    if not zip_path.exists():\n        log.info(f\"downloading aircraft database from {url} to {zip_path}\")\n        async with client.stream(\"GET\", url, follow_redirects=True) as response:\n            response.raise_for_status()\n            with zip_path.open(\"wb\") as f:\n                async for chunk in response.aiter_bytes():\n                    f.write(chunk)\n\n    if not db_path.exists():\n        log.info(f\"extracting {zip_path} to {db_path}\")\n        with zipfile.ZipFile(zip_path, \"r\") as zip_ref:\n            db_filename = zip_ref.namelist()[0]\n            zip_ref.extract(db_filename, path=path_cache)\n            (path_cache / db_filename).rename(db_path)\n\n    db = {}\n    try:\n        con = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n        cur = con.cursor()\n        res = cur.execute(\"SELECT ModeS, Registration, ICAOTypeCode FROM Aircraft\")\n        for modes, registration, icaotypecode in res.fetchall():\n            if modes:\n                db[modes.lower()] = _planes.Aircraft(\n                    registration=registration,\n                    typecode=icaotypecode,\n                )\n        con.close()\n    except sqlite3.Error as e:\n        log.error(f\"error reading aircraft database {db_path}: {e}\")\n        db_path.unlink(missing_ok=True)\n\n    return db\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.run_planes","title":"run_planes  <code>async</code>","text":"<pre><code>run_planes(backend_state: BackendState) -&gt; None\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@plugin.register_service()\nasync def run_planes(backend_state: tangram_core.BackendState) -&gt; None:\n    from . import _planes\n\n    plugin_config = backend_state.config.plugins.get(\"tangram_jet1090\", {})\n    config_planes = TypeAdapter(PlanesConfig).validate_python(plugin_config)\n\n    default_log_level = plugin_config.get(\n        \"log_level\", backend_state.config.core.log_level\n    )\n\n    _planes.init_tracing_stderr(default_log_level)\n\n    aircraft_db = await get_aircraft_db(\n        backend_state.http_client,\n        config_planes.aircraft_db_url,\n        config_planes.path_cache,\n    )\n\n    rust_config = _planes.PlanesConfig(\n        redis_url=backend_state.config.core.redis_url,\n        jet1090_channel=config_planes.jet1090_channel,\n        history_table_name=config_planes.history_table_name,\n        state_vector_expire=config_planes.state_vector_expire,\n        stream_interval_secs=config_planes.stream_interval_secs,\n        aircraft_db=aircraft_db,\n        history_buffer_size=config_planes.history_buffer_size,\n        history_flush_interval_secs=config_planes.history_flush_interval_secs,\n        history_control_channel=config_planes.history_control_channel,\n        history_optimize_interval_secs=config_planes.history_optimize_interval_secs,\n        history_optimize_target_file_size=config_planes.history_optimize_target_file_size,\n        history_vacuum_interval_secs=config_planes.history_vacuum_interval_secs,\n        history_vacuum_retention_period_secs=config_planes.history_vacuum_retention_period_secs,\n    )\n    await _planes.run_planes(rust_config)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes","title":"tangram_jet1090._planes","text":""},{"location":"api/jet1090/#tangram_jet1090._planes.Aircraft","title":"Aircraft","text":""},{"location":"api/jet1090/#tangram_jet1090._planes.Aircraft.typecode","title":"typecode  <code>property</code> <code>writable</code>","text":"<pre><code>typecode: Optional[str]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.Aircraft.registration","title":"registration  <code>property</code> <code>writable</code>","text":"<pre><code>registration: Optional[str]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.Aircraft.__new__","title":"__new__","text":"<pre><code>__new__(\n    typecode: Optional[str], registration: Optional[str]\n) -&gt; Aircraft\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig","title":"PlanesConfig","text":""},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.redis_url","title":"redis_url  <code>property</code> <code>writable</code>","text":"<pre><code>redis_url: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.jet1090_channel","title":"jet1090_channel  <code>property</code> <code>writable</code>","text":"<pre><code>jet1090_channel: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_table_name","title":"history_table_name  <code>property</code> <code>writable</code>","text":"<pre><code>history_table_name: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_control_channel","title":"history_control_channel  <code>property</code> <code>writable</code>","text":"<pre><code>history_control_channel: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.state_vector_expire","title":"state_vector_expire  <code>property</code> <code>writable</code>","text":"<pre><code>state_vector_expire: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.stream_interval_secs","title":"stream_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>stream_interval_secs: float\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.aircraft_db","title":"aircraft_db  <code>property</code> <code>writable</code>","text":"<pre><code>aircraft_db: dict[str, Aircraft]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_buffer_size","title":"history_buffer_size  <code>property</code> <code>writable</code>","text":"<pre><code>history_buffer_size: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_flush_interval_secs","title":"history_flush_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_flush_interval_secs: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_optimize_interval_secs","title":"history_optimize_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_optimize_interval_secs: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_optimize_target_file_size","title":"history_optimize_target_file_size  <code>property</code> <code>writable</code>","text":"<pre><code>history_optimize_target_file_size: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_vacuum_interval_secs","title":"history_vacuum_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_vacuum_interval_secs: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_vacuum_retention_period_secs","title":"history_vacuum_retention_period_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_vacuum_retention_period_secs: Optional[int]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.__new__","title":"__new__","text":"<pre><code>__new__(\n    redis_url: str,\n    jet1090_channel: str,\n    history_table_name: str,\n    history_control_channel: str,\n    state_vector_expire: int,\n    stream_interval_secs: float,\n    aircraft_db: Mapping[str, Aircraft],\n    history_buffer_size: int,\n    history_flush_interval_secs: int,\n    history_optimize_interval_secs: int,\n    history_optimize_target_file_size: int,\n    history_vacuum_interval_secs: int,\n    history_vacuum_retention_period_secs: Optional[int],\n) -&gt; PlanesConfig\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.init_tracing_stderr","title":"init_tracing_stderr","text":"<pre><code>init_tracing_stderr(filter_str: str) -&gt; None\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.run_planes","title":"run_planes","text":"<pre><code>run_planes(config: PlanesConfig) -&gt; Any\n</code></pre>"},{"location":"api/ship162/","title":"Ship162","text":""},{"location":"api/ship162/#tangram_ship162","title":"tangram_ship162","text":""},{"location":"api/ship162/#tangram_ship162.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix=\"/ship162\",\n    tags=[\"ship162\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\",\n    routers=[router],\n    into_frontend_config_function=transform_config,\n)\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig","title":"ShipsConfig  <code>dataclass</code>","text":"<p>               Bases: <code>HasTopbarUiConfig</code>, <code>HasSidebarUiConfig</code></p> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass ShipsConfig(\n    tangram_core.config.HasTopbarUiConfig, tangram_core.config.HasSidebarUiConfig\n):\n    ship162_channel: str = \"ship162\"\n    history_table_name: str = \"ship162\"\n    history_control_channel: str = \"history:control\"\n    state_vector_expire: int = 600  # 10 minutes\n    stream_interval_secs: float = 1.0\n    log_level: str = \"INFO\"\n    history_buffer_size: int = 100_000\n    history_flush_interval_secs: int = 5\n    history_optimize_interval_secs: int = 120\n    history_optimize_target_file_size: int = 134217728\n    history_vacuum_interval_secs: int = 120\n    history_vacuum_retention_period_secs: int | None = 120\n    topbar_order: int = 100\n    sidebar_order: int = 100\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.ship162_channel","title":"ship162_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ship162_channel: str = 'ship162'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_table_name","title":"history_table_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_table_name: str = 'ship162'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_control_channel","title":"history_control_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_control_channel: str = 'history:control'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.state_vector_expire","title":"state_vector_expire  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state_vector_expire: int = 600\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.stream_interval_secs","title":"stream_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stream_interval_secs: float = 1.0\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level: str = 'INFO'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_buffer_size","title":"history_buffer_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_buffer_size: int = 100000\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_flush_interval_secs","title":"history_flush_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_flush_interval_secs: int = 5\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_optimize_interval_secs","title":"history_optimize_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_optimize_interval_secs: int = 120\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_optimize_target_file_size","title":"history_optimize_target_file_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_optimize_target_file_size: int = 134217728\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_vacuum_interval_secs","title":"history_vacuum_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_vacuum_interval_secs: int = 120\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_vacuum_retention_period_secs","title":"history_vacuum_retention_period_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_vacuum_retention_period_secs: int | None = 120\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.topbar_order","title":"topbar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topbar_order: int = 100\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.sidebar_order","title":"sidebar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int = 100\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    ship162_channel: str = \"ship162\",\n    history_table_name: str = \"ship162\",\n    history_control_channel: str = \"history:control\",\n    state_vector_expire: int = 600,\n    stream_interval_secs: float = 1.0,\n    log_level: str = \"INFO\",\n    history_buffer_size: int = 100000,\n    history_flush_interval_secs: int = 5,\n    history_optimize_interval_secs: int = 120,\n    history_optimize_target_file_size: int = 134217728,\n    history_vacuum_interval_secs: int = 120,\n    history_vacuum_retention_period_secs: int | None = 120,\n    topbar_order: int = 100,\n    sidebar_order: int = 100,\n) -&gt; None\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.FrontendShipsConfig","title":"FrontendShipsConfig  <code>dataclass</code>","text":"<p>               Bases: <code>HasTopbarUiConfig</code>, <code>HasSidebarUiConfig</code></p> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass FrontendShipsConfig(\n    tangram_core.config.HasTopbarUiConfig, tangram_core.config.HasSidebarUiConfig\n):\n    topbar_order: int\n    sidebar_order: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.FrontendShipsConfig.topbar_order","title":"topbar_order  <code>instance-attribute</code>","text":"<pre><code>topbar_order: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.FrontendShipsConfig.sidebar_order","title":"sidebar_order  <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.FrontendShipsConfig.__init__","title":"__init__","text":"<pre><code>__init__(topbar_order: int, sidebar_order: int) -&gt; None\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.get_trajectory_data","title":"get_trajectory_data  <code>async</code>","text":"<pre><code>get_trajectory_data(\n    mmsi: int, backend_state: InjectBackendState\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Get the full trajectory for a given ship MMSI.</p> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@router.get(\"/data/{mmsi}\")\nasync def get_trajectory_data(\n    mmsi: int, backend_state: tangram_core.InjectBackendState\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get the full trajectory for a given ship MMSI.\"\"\"\n    if not _HISTORY_AVAILABLE:\n        raise HTTPException(\n            status_code=501,\n            detail=\"History feature is not installed. \"\n            \"Install with `pip install 'tangram_ship162[history]'`\",\n        )\n\n    redis_key = \"tangram:history:table_uri:ship162\"\n    table_uri_bytes = await backend_state.redis_client.get(redis_key)\n\n    if not table_uri_bytes:\n        raise HTTPException(\n            status_code=404,\n            detail=(\n                \"Table 'ship162' not found.\\nhelp: is the history service running?\"\n            ),\n        )\n    table_uri = table_uri_bytes.decode(\"utf-8\")\n\n    try:\n        df = (\n            pl.scan_delta(table_uri)\n            .filter(pl.col(\"mmsi\") == mmsi)\n            .with_columns(pl.col(\"timestamp\").dt.epoch(time_unit=\"s\"))\n            .sort(\"timestamp\")\n            .collect()\n        )\n        return Response(df.write_json(), media_type=\"application/json\")\n    except Exception as e:\n        raise HTTPException(\n            status_code=500, detail=f\"Failed to query trajectory data: {e}\"\n        )\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.transform_config","title":"transform_config","text":"<pre><code>transform_config(\n    config_dict: dict[str, Any],\n) -&gt; FrontendShipsConfig\n</code></pre> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>def transform_config(config_dict: dict[str, Any]) -&gt; FrontendShipsConfig:\n    config = TypeAdapter(ShipsConfig).validate_python(config_dict)\n    return FrontendShipsConfig(\n        topbar_order=config.topbar_order,\n        sidebar_order=config.sidebar_order,\n    )\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.run_ships","title":"run_ships  <code>async</code>","text":"<pre><code>run_ships(backend_state: BackendState) -&gt; None\n</code></pre> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@plugin.register_service()\nasync def run_ships(backend_state: tangram_core.BackendState) -&gt; None:\n    from . import _ships\n\n    plugin_config = backend_state.config.plugins.get(\"tangram_ship162\", {})\n    config_ships = TypeAdapter(ShipsConfig).validate_python(plugin_config)\n\n    default_log_level = plugin_config.get(\n        \"log_level\", backend_state.config.core.log_level\n    )\n\n    _ships.init_tracing_stderr(default_log_level)\n\n    rust_config = _ships.ShipsConfig(\n        redis_url=backend_state.config.core.redis_url,\n        ship162_channel=config_ships.ship162_channel,\n        history_control_channel=config_ships.history_control_channel,\n        state_vector_expire=config_ships.state_vector_expire,\n        stream_interval_secs=config_ships.stream_interval_secs,\n        history_table_name=config_ships.history_table_name,\n        history_buffer_size=config_ships.history_buffer_size,\n        history_flush_interval_secs=config_ships.history_flush_interval_secs,\n        history_optimize_interval_secs=config_ships.history_optimize_interval_secs,\n        history_optimize_target_file_size=config_ships.history_optimize_target_file_size,\n        history_vacuum_interval_secs=config_ships.history_vacuum_interval_secs,\n        history_vacuum_retention_period_secs=config_ships.history_vacuum_retention_period_secs,\n    )\n    await _ships.run_ships(rust_config)\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships","title":"tangram_ship162._ships","text":""},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig","title":"ShipsConfig","text":""},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.redis_url","title":"redis_url  <code>property</code> <code>writable</code>","text":"<pre><code>redis_url: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.ship162_channel","title":"ship162_channel  <code>property</code> <code>writable</code>","text":"<pre><code>ship162_channel: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_control_channel","title":"history_control_channel  <code>property</code> <code>writable</code>","text":"<pre><code>history_control_channel: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.state_vector_expire","title":"state_vector_expire  <code>property</code> <code>writable</code>","text":"<pre><code>state_vector_expire: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.stream_interval_secs","title":"stream_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>stream_interval_secs: float\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_table_name","title":"history_table_name  <code>property</code> <code>writable</code>","text":"<pre><code>history_table_name: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_buffer_size","title":"history_buffer_size  <code>property</code> <code>writable</code>","text":"<pre><code>history_buffer_size: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_flush_interval_secs","title":"history_flush_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_flush_interval_secs: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_optimize_interval_secs","title":"history_optimize_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_optimize_interval_secs: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_optimize_target_file_size","title":"history_optimize_target_file_size  <code>property</code> <code>writable</code>","text":"<pre><code>history_optimize_target_file_size: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_vacuum_interval_secs","title":"history_vacuum_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_vacuum_interval_secs: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_vacuum_retention_period_secs","title":"history_vacuum_retention_period_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_vacuum_retention_period_secs: Optional[int]\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.__new__","title":"__new__","text":"<pre><code>__new__(\n    redis_url: str,\n    ship162_channel: str,\n    history_control_channel: str,\n    state_vector_expire: int,\n    stream_interval_secs: float,\n    history_table_name: str,\n    history_buffer_size: int,\n    history_flush_interval_secs: int,\n    history_optimize_interval_secs: int,\n    history_optimize_target_file_size: int,\n    history_vacuum_interval_secs: int,\n    history_vacuum_retention_period_secs: Optional[int],\n) -&gt; ShipsConfig\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.init_tracing_stderr","title":"init_tracing_stderr","text":"<pre><code>init_tracing_stderr(filter_str: str) -&gt; None\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.run_ships","title":"run_ships","text":"<pre><code>run_ships(config: ShipsConfig) -&gt; Any\n</code></pre>"},{"location":"api/system/","title":"System","text":""},{"location":"api/system/#tangram_system","title":"tangram_system","text":""},{"location":"api/system/#tangram_system.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/system/#tangram_system.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\",\n    into_frontend_config_function=transform_config,\n)\n</code></pre>"},{"location":"api/system/#tangram_system.SystemConfig","title":"SystemConfig  <code>dataclass</code>","text":"<p>               Bases: <code>HasSidebarUiConfig</code></p> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>@dataclass\nclass SystemConfig(tangram_core.config.HasSidebarUiConfig):\n    topbar_order: int = 0\n</code></pre>"},{"location":"api/system/#tangram_system.SystemConfig.topbar_order","title":"topbar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topbar_order: int = 0\n</code></pre>"},{"location":"api/system/#tangram_system.SystemConfig.sidebar_order","title":"sidebar_order  <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int\n</code></pre>"},{"location":"api/system/#tangram_system.SystemConfig.__init__","title":"__init__","text":"<pre><code>__init__(topbar_order: int = 0) -&gt; None\n</code></pre>"},{"location":"api/system/#tangram_system.transform_config","title":"transform_config","text":"<pre><code>transform_config(\n    config_dict: dict[str, Any],\n) -&gt; SystemConfig\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def transform_config(config_dict: dict[str, Any]) -&gt; SystemConfig:\n    from pydantic import TypeAdapter\n\n    return TypeAdapter(SystemConfig).validate_python(config_dict)\n</code></pre>"},{"location":"api/system/#tangram_system.uptime","title":"uptime","text":"<pre><code>uptime(counter: int) -&gt; dict[str, str]\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def uptime(counter: int) -&gt; dict[str, str]:\n    return {\n        \"el\": \"uptime\",\n        \"value\": f\"{timedelta(seconds=counter)}\",\n    }\n</code></pre>"},{"location":"api/system/#tangram_system.info_utc","title":"info_utc","text":"<pre><code>info_utc() -&gt; dict[str, str | int]\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def info_utc() -&gt; dict[str, str | int]:\n    return {\n        \"el\": \"info_utc\",\n        \"value\": 1000 * int(datetime.now(timezone.utc).timestamp()),\n    }\n</code></pre>"},{"location":"api/system/#tangram_system.cpu_load","title":"cpu_load","text":"<pre><code>cpu_load() -&gt; dict[str, str]\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def cpu_load() -&gt; dict[str, str]:\n    try:\n        load1, _load5, _load15 = psutil.getloadavg()\n        cpu_count = psutil.cpu_count(logical=True) or 1\n        load_percent = (load1 / cpu_count) * 100\n        return {\"el\": \"cpu_load\", \"value\": f\"{load_percent:.2f}%\"}\n    except Exception:\n        return {\"el\": \"cpu_load\", \"value\": \"Unavailable\"}\n</code></pre>"},{"location":"api/system/#tangram_system.ram_usage","title":"ram_usage","text":"<pre><code>ram_usage() -&gt; dict[str, str]\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def ram_usage() -&gt; dict[str, str]:\n    try:\n        mem = psutil.virtual_memory()\n        return {\"el\": \"ram_usage\", \"value\": f\"{mem.percent:.2f}%\"}\n    except Exception:\n        return {\"el\": \"ram_usage\", \"value\": \"Unavailable\"}\n</code></pre>"},{"location":"api/system/#tangram_system.server_events","title":"server_events  <code>async</code>","text":"<pre><code>server_events(redis_client: Redis) -&gt; NoReturn\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>async def server_events(redis_client: redis.Redis) -&gt; NoReturn:\n    counter = 0\n    log.info(\"serving system events...\")\n\n    while True:\n        await redis_client.publish(\n            \"to:system:update-node\", orjson.dumps(uptime(counter))\n        )\n        await redis_client.publish(\"to:system:update-node\", orjson.dumps(info_utc()))\n        await redis_client.publish(\"to:system:update-node\", orjson.dumps(cpu_load()))\n        await redis_client.publish(\"to:system:update-node\", orjson.dumps(ram_usage()))\n        counter += 1\n\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"api/system/#tangram_system.run_system","title":"run_system  <code>async</code>","text":"<pre><code>run_system(backend_state: BackendState) -&gt; None\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>@plugin.register_service()\nasync def run_system(backend_state: tangram_core.BackendState) -&gt; None:\n    await server_events(backend_state.redis_client)\n</code></pre>"},{"location":"api/weather/","title":"Weather","text":""},{"location":"api/weather/#tangram_weather","title":"tangram_weather","text":""},{"location":"api/weather/#tangram_weather.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/weather/#tangram_weather.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix=\"/weather\",\n    tags=[\"weather\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n</code></pre>"},{"location":"api/weather/#tangram_weather.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\", routers=[router]\n)\n</code></pre>"},{"location":"api/weather/#tangram_weather.get_weather","title":"get_weather  <code>async</code>","text":"<pre><code>get_weather() -&gt; dict[str, str]\n</code></pre> Source code in <code>packages/tangram_weather/src/tangram_weather/__init__.py</code> <pre><code>@router.get(\"/\")\nasync def get_weather() -&gt; dict[str, str]:\n    return {\"message\": \"This is the weather plugin response\"}\n</code></pre>"},{"location":"api/weather/#tangram_weather.wind","title":"wind  <code>async</code>","text":"<pre><code>wind(\n    isobaric: int, backend_state: InjectBackendState\n) -&gt; ORJSONResponse\n</code></pre> Source code in <code>packages/tangram_weather/src/tangram_weather/__init__.py</code> <pre><code>@router.get(\"/wind\")\nasync def wind(\n    isobaric: int, backend_state: tangram_core.InjectBackendState\n) -&gt; ORJSONResponse:\n    logger.info(\"fetching wind data for %s\", isobaric)\n\n    now = pd.Timestamp.now(tz=\"UTC\").floor(\"1h\")\n    ds = await latest_arpege_data(backend_state.http_client, now)\n    res = ds.sel(isobaricInhPa=isobaric, time=now.tz_convert(None))[[\"u\", \"v\"]]\n\n    u_attrs = res.data_vars[\"u\"].attrs\n\n    bounds = [\n        u_attrs[\"GRIB_longitudeOfFirstGridPointInDegrees\"],\n        u_attrs[\"GRIB_latitudeOfLastGridPointInDegrees\"],\n        u_attrs[\"GRIB_longitudeOfLastGridPointInDegrees\"],\n        u_attrs[\"GRIB_latitudeOfFirstGridPointInDegrees\"],\n    ]\n\n    u_data = res[\"u\"].values\n    v_data = res[\"v\"].values\n\n    valid_data_mask = ~np.isnan(u_data)\n\n    min_val, max_val = -70.0, 70.0\n    image_unscale = [min_val, max_val]\n    value_range = max_val - min_val\n\n    u_scaled = (np.nan_to_num(u_data, nan=0.0) - min_val) / value_range * 255\n    v_scaled = (np.nan_to_num(v_data, nan=0.0) - min_val) / value_range * 255\n\n    rgba_data = np.zeros((*u_data.shape, 4), dtype=np.uint8)\n    rgba_data[..., 0] = u_scaled.astype(np.uint8)\n    rgba_data[..., 1] = v_scaled.astype(np.uint8)\n    rgba_data[..., 3] = np.where(valid_data_mask, 255, 0)\n\n    image = Image.fromarray(rgba_data, \"RGBA\")\n    buffer = io.BytesIO()\n    image.save(buffer, format=\"PNG\")\n    img_str = base64.b64encode(buffer.getvalue()).decode(\"utf-8\")\n    image_data_uri = f\"data:image/png;base64,{img_str}\"\n\n    response_content = {\n        \"imageDataUri\": image_data_uri,\n        \"bounds\": bounds,\n        \"imageUnscale\": image_unscale,\n    }\n\n    return ORJSONResponse(content=response_content)\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege","title":"arpege","text":""},{"location":"api/weather/#tangram_weather.arpege.bare_url","title":"bare_url  <code>module-attribute</code>","text":"<pre><code>bare_url = (\n    \"https://object.data.gouv.fr/meteofrance-pnt/pnt/\"\n)\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.DEFAULT_LEVELS_37","title":"DEFAULT_LEVELS_37  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LEVELS_37 = [\n    100,\n    125,\n    150,\n    175,\n    200,\n    225,\n    250,\n    300,\n    350,\n    400,\n    450,\n    500,\n    550,\n    600,\n    650,\n    700,\n    750,\n    800,\n    850,\n    900,\n    950,\n    1000,\n]\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.DEFAULT_IP1_FEATURES","title":"DEFAULT_IP1_FEATURES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_IP1_FEATURES = ['u', 'v', 't', 'r']\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.tempdir","title":"tempdir  <code>module-attribute</code>","text":"<pre><code>tempdir = Path(gettempdir())\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.download_with_progress","title":"download_with_progress  <code>async</code>","text":"<pre><code>download_with_progress(\n    client: AsyncClient, url: str, file: Path\n) -&gt; None\n</code></pre> Source code in <code>packages/tangram_weather/src/tangram_weather/arpege.py</code> <pre><code>async def download_with_progress(\n    client: httpx.AsyncClient, url: str, file: Path\n) -&gt; None:\n    try:\n        async with client.stream(\"GET\", url) as r:\n            if r.status_code != 200:\n                raise httpx.HTTPStatusError(\n                    f\"Error downloading data from {url}\", request=r.request, response=r\n                )\n\n            total_size = int(r.headers.get(\"Content-Length\", 0))\n            with file.open(\"wb\") as buffer:\n                with tqdm(\n                    total=total_size,\n                    unit=\"B\",\n                    unit_scale=True,\n                    desc=url.split(\"/\")[-1],\n                ) as progress_bar:\n                    first_chunk = True\n                    async for chunk in r.aiter_bytes():\n                        if first_chunk and chunk.startswith(b\"&lt;?xml\"):\n                            raise RuntimeError(\n                                f\"Error downloading data from {url}. \"\n                                \"Check if the requested data is available.\"\n                            )\n                        first_chunk = False\n                        await asyncio.to_thread(buffer.write, chunk)\n                        progress_bar.update(len(chunk))\n    except (httpx.RequestError, RuntimeError) as e:\n        if file.exists():\n            file.unlink()\n        raise e\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.latest_data","title":"latest_data  <code>async</code>","text":"<pre><code>latest_data(\n    client: AsyncClient,\n    hour: Timestamp,\n    model: str = \"ARPEGE\",\n    resolution: Literal[\"025\", \"01\"] = \"025\",\n    package: Literal[\n        \"SP1\", \"SP2\", \"IP1\", \"IP2\", \"IP3\", \"IP4\", \"HP1\"\n    ] = \"IP1\",\n    time_range: Literal[\n        \"000H024H\",\n        \"025H048H\",\n        \"049H072H\",\n        \"073H102H\",\n        \"000H012H\",\n        \"013H024H\",\n        \"025H036H\",\n        \"037H048H\",\n        \"049H060H\",\n        \"061H072H\",\n        \"073H084H\",\n        \"085H096H\",\n        \"097H102H\",\n    ] = \"000H024H\",\n    recursion: int = 0,\n) -&gt; Dataset\n</code></pre> <p>Fetch the latest ARPEGE data for a given hour.</p> Source code in <code>packages/tangram_weather/src/tangram_weather/arpege.py</code> <pre><code>async def latest_data(\n    client: httpx.AsyncClient,\n    hour: pd.Timestamp,\n    model: str = \"ARPEGE\",\n    resolution: Literal[\"025\", \"01\"] = \"025\",\n    package: Literal[\"SP1\", \"SP2\", \"IP1\", \"IP2\", \"IP3\", \"IP4\", \"HP1\"] = \"IP1\",\n    time_range: Literal[\n        \"000H024H\",  # on the 0.25 degree grid\n        \"025H048H\",  # on the 0.25 degree grid\n        \"049H072H\",  # on the 0.25 degree grid\n        \"073H102H\",  # on the 0.25 degree grid\n        \"000H012H\",  # on the 0.1 degree grid\n        \"013H024H\",  # on the 0.1 degree grid\n        \"025H036H\",  # on the 0.1 degree grid\n        \"037H048H\",  # on the 0.1 degree grid\n        \"049H060H\",  # on the 0.1 degree grid\n        \"061H072H\",  # on the 0.1 degree grid\n        \"073H084H\",  # on the 0.1 degree grid\n        \"085H096H\",  # on the 0.1 degree grid\n        \"097H102H\",  # on the 0.1 degree grid\n    ] = \"000H024H\",\n    recursion: int = 0,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Fetch the latest ARPEGE data for a given hour.\n    \"\"\"\n    # let's give them time to upload data to the repo\n    runtime = (hour - pd.Timedelta(\"2h\")).floor(\"6h\")\n\n    url = f\"{bare_url}{runtime.isoformat()}/\"\n    url += f\"{model.lower()}/{resolution}/{package}/\"\n    filename = f\"{model.lower()}__{resolution}__{package}__\"\n    filename += f\"{time_range}__{runtime.isoformat()}.grib2\"\n    filename = filename.replace(\"+00:00\", \"Z\")\n    url += filename\n    url = url.replace(\"+00:00\", \"Z\")\n\n    if not (tempdir / filename).exists():\n        # If the file does not exist, we try to download it.\n        try:\n            await download_with_progress(client, url, tempdir / filename)\n        except Exception:\n            (tempdir / filename).unlink(missing_ok=True)  # remove the file if it exists\n            # If the download fails, we try to fetch the latest data\n            # (or survive with older data we may have in the /tmp directory)\n            if recursion &gt;= 3:\n                raise  # do not insist too much in history\n            return await latest_data(\n                client,\n                hour - pd.Timedelta(\"6h\"),\n                model,\n                resolution,\n                package,\n                time_range,\n                recursion + 1,\n            )\n\n    def _load_and_process_dataset() -&gt; xr.Dataset:\n        log.info(f\"Loading dataset from {tempdir / filename}\")\n        ds = xr.open_dataset(\n            tempdir / filename,\n            engine=\"cfgrib\",\n            backend_kwargs={\n                \"filter_by_keys\": {\n                    \"typeOfLevel\": \"isobaricInhPa\",\n                    \"level\": DEFAULT_LEVELS_37,\n                }\n            },\n        )\n        ds = ds.assign(step=ds.time + ds.step).drop_vars(\"time\")\n        ds = ds.rename(step=\"time\")\n        return ds  # type: ignore\n\n    return await asyncio.to_thread(_load_and_process_dataset)\n</code></pre>"},{"location":"architecture/","title":"Architecture of the tangram framework","text":"<p>The <code>tangram</code> framework consists of a lightweight core and a suite of independent, installable plugins that can be combined to create a powerful and flexible aviation data processing and visualization system.</p> <p>The system consists of a web-based frontend (in Javascript  based on Vite), a backend service (in Python ), and performance-critical components in Rust .</p> <p>Communication between the frontend and backend is done through a REST API, while real-time data streaming is handled via WebSockets. A Redis  pub/sub system is used for efficient data distribution between backend components.</p>"},{"location":"architecture/#a-plugin-first-architecture","title":"A Plugin-First Architecture","text":"<p>The core <code>tangram</code> package provides the essential scaffolding: a web server, a plugin loader, and a frontend API. All domain-specific functionality, including data decoding and processing, is implemented in separate, <code>pip</code>-installable plugins.</p> <p>This design allows you to:</p> <ul> <li>install only the functionality you need.</li> <li>develop, version, and distribute your own extensions (e.g., <code>my-simulation-plugin</code>) without modifying the core <code>tangram</code> codebase.</li> </ul> Component Technology Frontend  JavaScript (Vue.js, Vite) Backend  Python for most applications (FastAPI for the REST API)  Rust for performance critical components Data communication  Redis (pub/sub messaging system)"},{"location":"architecture/#system-overview","title":"System Overview","text":"<p>When you run <code>tangram serve</code>, it starts a single Python process that manages multiple asynchronous tasks for the application's core components and enabled plugins.</p> <pre><code>graph LR\n    subgraph User\n        B[Browser/Frontend]\n    end\n\n    subgraph \"Tangram Process (Python)\"\n        direction TB\n        FAS[FastAPI Server]\n        CS[Channel Service]\n        PS[Plugin Services e.g., planes]\n    end\n\n    subgraph \"External Services\"\n        J[jet1090 Container]\n    end\n\n    R[Redis Pub/Sub]\n\n    B -- HTTP API Requests --&gt; FAS\n    B &lt;-- WebSocket --&gt; CS\n    FAS -- Serves Frontend Assets --&gt; B\n    FAS &lt;-- Reads/Writes --&gt; R\n    CS &lt;-- Relays Messages --&gt; R\n    PS -- \u25c0 Subscribes to --&gt; R\n    J -- Publishes \u25b6 --&gt; R</code></pre> Component Provided By Description <code>tangram</code> (Core) <code>tangram_core</code> package REST API server, CLI, and frontend shell. <code>channel</code> (Bundled with <code>tangram</code>) WebSocket bridge between the frontend and Redis pub/sub. <code>jet1090</code> integration <code>tangram_jet1090</code> plugin Decodes Mode S/ADS-B messages and provides data streams. State Vectors &amp; History <code>tangram_jet1090</code> plugin Maintains real-time state and stores historical aircraft data. System Info <code>tangram_system</code> plugin Provides backend server metrics like CPU and memory usage. Weather Layers <code>tangram_weather</code> plugin Provides API endpoints for meteorological data."},{"location":"architecture/#backend-plugin-system","title":"Backend Plugin System","text":"<p>The backend discovers plugins using Python's standard entry point mechanism. When you <code>pip install tangram_jet1090</code>, it registers itself under the <code>tangram_core.plugins</code> group in its <code>pyproject.toml</code>. The core <code>tangram</code> application queries these groups at startup to find and load all available plugins, allowing them to add their own API routes and background tasks.</p> <p>For a detailed guide on creating your own backend extensions, see the Backend Plugin Guide.</p>"},{"location":"architecture/#frontend-plugin-system","title":"Frontend Plugin System","text":"<p>The frontend loads plugins dynamically. The backend serves a <code>/manifest.json</code> file listing all enabled frontend plugins. The core <code>tangram</code> web application fetches this manifest and dynamically imports the JavaScript entry point for each plugin. The plugin's entry point then calls the <code>tangramApi.registerWidget()</code> function to add its Vue components to the main application.</p> <p>For more details, see the Frontend Plugin Guide.</p>"},{"location":"architecture/channel/","title":"Channel: WebSocket Communication Service","text":"<p>The Channel component is a Rust implementation that provides real-time bidirectional communication for Tangram using WebSockets. It implements a subset of the Phoenix Channels protocol, enabling seamless integration with both the frontend and backend components through Redis pub/sub messaging.</p>"},{"location":"architecture/channel/#overview","title":"Overview","text":"<p>Channel serves as the central communication hub in Tangram, connecting the frontend visualization with the backend processing plugins. It manages WebSocket connections, handles client authentication, and facilitates the bidirectional flow of data through Redis.</p>"},{"location":"architecture/channel/#key-features","title":"Key Features","text":"<ul> <li>Channel-based Communication: Supports multiple named channels that clients can join and leave</li> <li>Redis Integration: Uses Redis pub/sub for message distribution between components</li> <li>JWT Authentication: Secures channel access with JSON Web Tokens</li> <li>Presence Tracking: Tracks and broadcasts client presence information</li> </ul>"},{"location":"architecture/channel/#communication-flow","title":"Communication Flow","text":""},{"location":"architecture/channel/#backend-to-frontend","title":"Backend to Frontend","text":"<ol> <li>Backend plugins publish messages to Redis topics in the format <code>to:&lt;channel&gt;:&lt;event&gt;</code></li> <li>Channel subscribes to these Redis topics and listens for messages</li> <li>When a message is received, Channel forwards it to all WebSocket clients connected to the specified channel</li> <li>Clients receive the message and can update their visualizations in real-time</li> </ol> <pre><code>sequenceDiagram\n    participant P as Backend Plugin\n    participant R as Redis\n    participant C as Channel Service\n    participant F as Frontend Client\n\n    P-&gt;&gt;R: PUBLISH to:system:update, \"data\"\n    R--&gt;&gt;C: Receives message\n    C-&gt;&gt;F: PUSH system:update, \"data\"</code></pre>"},{"location":"architecture/channel/#frontend-to-backend","title":"Frontend to Backend","text":"<ol> <li>WebSocket clients send messages to a specific channel with an event name</li> <li>Channel receives these messages and publishes them to Redis topics in the format <code>from:&lt;channel&gt;:&lt;event&gt;</code></li> <li>Backend plugins subscribe to these Redis topics to receive client messages</li> <li>Plugins process the messages and can respond by publishing back to <code>to:&lt;channel&gt;:&lt;event&gt;</code></li> </ol> <pre><code>sequenceDiagram\n    participant F as Frontend Client\n    participant C as Channel Service\n    participant R as Redis\n    participant P as Backend Plugin\n\n    F-&gt;&gt;C: PUSH system:command, \"payload\"\n    C-&gt;&gt;R: PUBLISH from:system:command, \"payload\"\n    R--&gt;&gt;P: Receives message</code></pre>"},{"location":"architecture/channel/#channel-protocol","title":"Channel Protocol","text":"<p>The WebSocket protocol follows the Phoenix Channels message format, which uses JSON arrays with the following structure:</p> <pre><code>[join_ref, ref, topic, event, payload]\n</code></pre> <p>Where:</p> <ul> <li><code>join_ref</code>: Reference to the channel join request (null for system messages)</li> <li><code>ref</code>: Message reference for tracking responses</li> <li><code>topic</code>: Channel name</li> <li><code>event</code>: Event name</li> <li><code>payload</code>: Message data</li> </ul>"},{"location":"architecture/channel/#events","title":"Events","text":"<ul> <li><code>phx_join</code>: Join a channel (requires JWT token)</li> <li><code>phx_leave</code>: Leave a channel</li> <li><code>phx_reply</code>: Acknowledgment of a message</li> <li><code>presence_state</code>: Current state of all clients in a channel</li> <li><code>presence_diff</code>: Changes in channel presence</li> <li>Custom events: Any custom event name can be used for application-specific messages</li> </ul>"},{"location":"architecture/channel/#usage-in-tangram","title":"Usage in Tangram","text":""},{"location":"architecture/channel/#predefined-channels","title":"Predefined Channels","text":"<ul> <li><code>phoenix</code>: System channel for heartbeats and connection management</li> <li><code>admin</code>: Administrative channel for monitoring and control</li> <li><code>system</code>: General system information (includes regular datetime broadcasts)</li> <li>Custom channels: Application-specific channels can be created dynamically</li> </ul>"},{"location":"architecture/channel/#client-connection","title":"Client Connection","text":"<p>Clients connect to the WebSocket endpoint and can join multiple channels:</p> <pre><code>// Connect to the WebSocket\nconst socket = new Phoenix.Socket(\"/websocket\", {\n  params: { userToken: token },\n});\nsocket.connect();\n\n// Join a channel\nconst channel = socket.channel(\"system\", { token: systemToken });\nchannel\n  .join()\n  .receive(\"ok\", (response) =&gt; console.log(\"Joined successfully\", response))\n  .receive(\"error\", (response) =&gt; console.log(\"Join failed\", response));\n\n// Listen for events\nchannel.on(\"datetime\", (payload) =&gt; {\n  console.log(\"Current time:\", payload.response.datetime);\n});\n\n// Send events\nchannel.push(\"custom_event\", { message: \"Hello from client\" });\n</code></pre>"},{"location":"architecture/channel/#backend-integration","title":"Backend Integration","text":"<p>Backend plugins can communicate with the frontend by using Redis pub/sub:</p> <pre><code>import redis\nimport json\n\nr = redis.Redis()\n\n# Send message to frontend clients\nawait r.publish('to:system:update', json.dumps({\n    'type': 'message',\n    'message': 'Update from backend'\n}))\n\n# Listen for messages from frontend\np = r.pubsub()\nawait p.psubscribe('from:system:*')\nasync for message in p.listen():\n    if message['type'] == 'pmessage':\n        print(f\"Received: {message['data']}\")\n</code></pre>"},{"location":"architecture/channel/#running-the-channel-service","title":"Running the Channel Service","text":"<p>The Channel service is an integrated part of the core <code>tangram</code> application. It is automatically started as a background service when you run the <code>tangram serve</code> command. You do not need to run it separately.</p> <p>Its behavior is configured in the <code>[channel]</code> section of your <code>tangram.toml</code> file.</p> tangram.toml<pre><code>[channel]\nhost = \"127.0.0.1\"\nport = 2347\n# The public-facing URL for the channel service.\n# Required when running behind a reverse proxy.\n# public_url = \"http://localhost:2347\"\njwt_secret = \"a-better-secret-than-this\"\n</code></pre>"},{"location":"architecture/channel/#token-authentication","title":"Token Authentication","text":"<p>Channels require JWT tokens for authentication. Tokens can be requested from the <code>/token</code> endpoint, which is exposed on the port defined in your configuration.</p> <pre><code>curl -X POST http://localhost:2347/token \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"channel\": \"system\", \"id\": \"client1\"}'\n</code></pre> <p>The response includes a JWT token that can be used for channel authentication:</p> <pre><code>{\n  \"id\": \"client1\",\n  \"channel\": \"system\",\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n</code></pre>"},{"location":"architecture/channel/#redis-commands-for-debugging","title":"Redis Commands for Debugging","text":"<pre><code># Subscribe to all outgoing messages from clients\nredis-cli psubscribe \"from:*\"\n\n# Subscribe to all incoming messages to clients\nredis-cli psubscribe \"to:*\"\n\n# Publish a test message to clients\nredis-cli publish \"to:system:test\" '{\"type\":\"message\",\"message\":\"Test from Redis\"}'\n</code></pre>"},{"location":"plugins/","title":"Plugins","text":"<p><code>tangram</code> is designed to be extended with plugins. This modular approach allows you to tailor the system to your specific needs, whether you are working with real-world ADS-B data, simulation outputs, or other data sources.</p> <p>Plugins are developed as standalone packages, enabling them to be versioned, tested, and distributed independently.</p> <ul> <li>Backend Plugins are installable Python packages that extend the server's functionality, typically by adding new API endpoints or background data processing services.</li> <li>Frontend Plugins are installable NPM packages that add new Vue.js components and widgets to the web interface.</li> </ul> <p>A single Python package can provide both backend and frontend components by bundling the pre-built frontend assets within its wheel distribution. This is the recommended approach for creating a cohesive feature.</p>"},{"location":"plugins/#official-plugins-as-examples","title":"Official Plugins as Examples","text":"<p>The best way to learn how to build plugins is to study the official ones:</p> <ul> <li><code>tangram_example</code>: A minimal template demonstrating both backend and frontend plugin structure.</li> <li><code>tangram_system</code>: A simple plugin that adds a background service.</li> <li><code>tangram_jet1090</code>: A complex plugin that adds API routes, a background service for real-time data, and a historical trajectory API.</li> <li><code>tangram_weather</code>: A plugin that adds a new API endpoint for external data.</li> </ul>"},{"location":"plugins/airports/","title":"Airports Plugin","text":"<p>The <code>tangram_airports</code> plugin adds an airport search widget as an overlay on the top-right corner of the map. This allows users to quickly find and center the map on any airport by name, IATA code, or ICAO code.</p>"},{"location":"plugins/airports/#how-it-works","title":"How It Works","text":"<p>This is a frontend-only plugin that requires no additional backend configuration.</p> <ol> <li>It registers a Vue component, <code>AirportSearchWidget.vue</code>, in the <code>MapOverlay</code> location of the UI.</li> <li>The component uses the <code>rs1090-wasm</code> library, which is bundled with the core <code>tangram</code> application, to perform a fast, client-side search of a comprehensive airport database.</li> <li>When a user selects an airport from the search results, the plugin uses the <code>MapApi</code> to pan and zoom the map to the airport's location.</li> </ol>"},{"location":"plugins/airports/#configuration","title":"Configuration","text":"<p>To enable this plugin, add <code>\"tangram_airports\"</code> to the <code>plugins</code> list in your <code>tangram.toml</code> file:</p>"},{"location":"plugins/backend/","title":"Backend","text":"<p>Backend plugins are the standard way to add new server-side capabilities to <code>tangram</code>. They are self-contained Python packages that <code>tangram</code> discovers and loads at runtime, allowing for clean separation from the core framework.</p> <p>This guide covers the key concepts for building a backend plugin.</p>"},{"location":"plugins/backend/#plugin-anatomy","title":"Plugin Anatomy","text":"<p>A <code>tangram</code> plugin is a standard Python package that exposes its functionality through two key mechanisms: an entry point and a <code>Plugin</code> object.</p> <p>Assuming you have the following project structure:</p> <pre><code>my-tangram-plugin/\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 my_plugin/\n        \u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"plugins/backend/#1-the-pyprojecttoml-entry-point","title":"1. The <code>pyproject.toml</code> Entry Point","text":"<p>Your <code>pyproject.toml</code> must declare an entry point under the <code>tangram_core.plugins</code> group. This makes your package discoverable by the core application.</p> pyproject.toml<pre><code>[project]\nname = \"my-tangram-plugin\"\nversion = \"0.1.0\"\ndependencies = [\"tangram_core&gt;=0.2.1\"]\n\n[project.entry-points.\"tangram_core.plugins\"]\nmy_plugin = \"my_plugin:plugin\"\n</code></pre>"},{"location":"plugins/backend/#2-the-plugin-object","title":"2. The <code>Plugin</code> Object","text":"<p>The entry point must point to an instance of the <code>tangram_core.Plugin</code> class. This object is the central hub for registering your plugin's components.</p> src/my_plugin/__init__.py<pre><code>import tangram_core\n\nplugin = tangram_core.Plugin(\n    # ... component registrations go here ...\n)\n</code></pre>"},{"location":"plugins/backend/#adding-api-endpoints","title":"Adding API Endpoints","text":"<p>To add REST API endpoints, define a standard FastAPI <code>APIRouter</code> and pass a list of routers to the <code>Plugin</code> constructor. <code>tangram</code> will automatically mount them into the main application.</p> src/my_plugin/__init__.py<pre><code>import tangram_core\nfrom fastapi import APIRouter\n\nrouter = APIRouter(prefix=\"/my-plugin\")\n\n@router.get(\"/\")\nasync def my_endpoint():\n    return {\"message\": \"Hello from my custom plugin!\"}\n\nplugin = tangram_core.Plugin(\n    routers=[router]\n)\n</code></pre>"},{"location":"plugins/backend/#creating-background-services","title":"Creating Background Services","text":"<p>To run persistent background tasks, use the <code>@plugin.register_service</code> decorator. The decorated function will be started as a background task when <code>tangram serve</code> runs.</p> <p>The service function receives a <code>tangram_core.BackendState</code> object, which provides access to core components like the Redis client.</p> src/my_plugin/__init__.py<pre><code>import asyncio\nimport tangram_core\n\nplugin = tangram_core.Plugin()\n\n@plugin.register_service()\nasync def run_periodic_task(backend_state: tangram_core.BackendState):\n    \"\"\"A background service that publishes a message every 10 seconds.\"\"\"\n    redis_client = backend_state.redis_client\n    while True:\n        await redis_client.publish(\"my-plugin:status\", \"alive\")\n        await asyncio.sleep(10)\n</code></pre>"},{"location":"plugins/backend/#inter-component-communication-with-redis","title":"Inter-Component Communication with Redis","text":"<p>Redis pub/sub is the backbone for real-time communication between all <code>tangram</code> components, including backend services, the frontend, and performance-critical Rust modules.</p>"},{"location":"plugins/backend/#communicating-with-the-frontend-via-websockets","title":"Communicating with the Frontend via WebSockets","text":"<p>The <code>channel</code> service acts as a transparent bridge between Redis and frontend WebSockets. A simple convention is used for routing messages:</p> <pre><code>graph TB\n    subgraph Frontend\n        direction TB\n        FC[Client]\n    end\n\n    subgraph Backend\n        direction TB\n        BP[Plugin]\n    end\n\n    WS[WebSocket Channel]\n    R[Redis Pub/Sub]\n\n    FC -- \"push('event', payload)\" --&gt; WS\n    WS -- \"PUBLISH from:channel:event\" --&gt; R\n    R -- \"LISTEN from:*\" --&gt; BP\n\n    BP -- \"PUBLISH to:channel:event\" --&gt; R\n    R -- \"LISTEN to:*\" --&gt; WS\n    WS -- \"on('event', payload)\" --&gt; FC</code></pre> <ul> <li>Backend to Frontend: To send a message to the frontend, publish it to a Redis channel prefixed with <code>to:&lt;channel_name&gt;:&lt;event_name&gt;</code>. The <code>channel</code> service relays this to the browser.</li> <li>Frontend to Backend: When the frontend sends a message, the <code>channel</code> service relays it to a Redis channel prefixed with <code>from:&lt;channel_name&gt;:&lt;event_name&gt;</code>.</li> </ul>"},{"location":"plugins/backend/#publishing-messages","title":"Publishing Messages","text":"<p>You can publish messages from any backend service using the Redis client available in <code>tangram_core.BackendState</code>.</p> PythonRust <pre><code># from within a service function\nredis_client = backend_state.redis_client\nawait redis_client.publish(\"to:system:update\", \"Hello from plugin\")\n</code></pre> <pre><code>let redis_client = redis::Client::open(\"redis://localhost:6379\").unwrap()?;\nlet mut con = redis_client.get_multiplexed_async_connection().await?;\ncon.publish(\"to:system:update\", \"Hello from plugin\").await?;\n</code></pre>"},{"location":"plugins/backend/#subscribing-to-messages","title":"Subscribing to Messages","text":"<p>To handle incoming messages, <code>tangram</code> provides a <code>Subscriber</code> base class. This is the recommended pattern for creating robust, long-running listeners within a service.</p> src/my_plugin/__init__.py<pre><code>import asyncio\nfrom dataclasses import dataclass\nimport tangram_core\nfrom tangram_core.redis import Subscriber\n\nplugin = tangram_core.Plugin()\n\n@dataclass\nclass CommandSubscriberState:\n    command_count: int = 0\n\nclass CommandSubscriber(Subscriber[CommandSubscriberState]):\n    \"\"\"A subscriber that listens for commands on a Redis channel.\"\"\"\n    async def message_handler(\n        self, event: str, payload: str, pattern: str, state: CommandSubscriberState\n    ) -&gt; None:\n        state.command_count += 1\n        print(f\"Command #{state.command_count} received on `{event}`: {payload}\")\n\n@plugin.register_service()\nasync def run_command_listener(backend_state: tangram_core.BackendState) -&gt; None:\n    \"\"\"This service listens for commands from the frontend.\"\"\"\n    subscriber = CommandSubscriber(\n        name=\"CommandListener\",\n        redis_url=backend_state.config.core.redis_url,\n        channels=[\"from:system:my-plugin-command\"],\n        initial_state=CommandSubscriberState(),\n    )\n    await subscriber.subscribe()\n    try:\n        await asyncio.Future()  # run forever\n    finally:\n        await subscriber.cleanup()\n</code></pre>"},{"location":"plugins/backend/#using-your-plugin","title":"Using Your Plugin","text":"<p>Install your package in the same environment as <code>tangram</code> and enable it in your <code>tangram.toml</code>:</p> <pre><code>[core]\nplugins = [\"my_tangram_plugin\"]\n</code></pre> <p>Run <code>tangram serve</code>. The core application will load your plugin, making its API endpoints available and starting its background services. The full API documentation, including your new endpoint, is available at http://localhost:2346/docs.</p>"},{"location":"plugins/frontend/","title":"Frontend","text":"<p>Frontend plugins are standalone NPM packages that add new widgets and functionality to the <code>tangram</code> web interface. This system is designed for modularity, allowing you to build and share custom UI components.</p>"},{"location":"plugins/frontend/#1-project-structure","title":"1. Project Structure","text":"<p>A frontend plugin is a standard TypeScript/Vue project that produces a library build.</p> <pre><code>my-tangram-frontend-plugin/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 vite.config.ts\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 MyWidget.vue\n    \u2514\u2500\u2500 index.ts\n</code></pre>"},{"location":"plugins/frontend/#2-plugin-entry-point-indexts","title":"2. Plugin Entry Point (<code>index.ts</code>)","text":"<p>The <code>main</code> file specified in your <code>package.json</code> must export an <code>install</code> function. This function is the plugin's entry point and receives the <code>TangramApi</code> object, which provides methods for interacting with the core application.</p> src/index.ts<pre><code>import type { TangramApi } from \"@open-aviation/tangram-core/api\";\nimport MyWidget from \"./MyWidget.vue\";\n\nexport function install(api: TangramApi) {\n  // use the API to register a new widget component.\n  // the first argument is a unique ID for your widget.\n  // the second is the Vue component itself.\n  api.registerWidget(\"my-widget\", MyWidget);\n}\n</code></pre> <p>The <code>TangramApi</code> provides two main functions:</p> <ul> <li><code>registerWidget(id: string, component: Component)</code>: Makes your component available to the core UI.</li> <li><code>getVueApp(): App</code>: Provides access to the core Vue application instance for advanced use cases.</li> </ul>"},{"location":"plugins/frontend/#3-vite-configuration","title":"3. <code>vite</code> configuration","text":"<p>To simplify the build process, <code>tangram</code> provides a shared Vite plugin. This handles the complex configuration needed to build your plugin as a library and generate a <code>plugin.json</code> manifest file.</p> vite.config.ts<pre><code>import { defineConfig } from \"vite\";\nimport { tangramPlugin } from \"@open-aviation/tangram-core/vite-plugin\";\n\nexport default defineConfig({\n  plugins: [tangramPlugin()],\n});\n</code></pre> <p>This standardized build produces a <code>dist-frontend</code> directory containing your compiled JavaScript and the manifest file. <code>tangram</code> uses this manifest to discover and load your plugin.</p>"},{"location":"plugins/frontend/#4-building-and-using-your-plugin","title":"4. Building and using your plugin","text":"<p>First, build your frontend assets. If you are in the monorepo, <code>pnpm build</code> will handle this.</p> <p>Next, ensure the generated <code>dist-frontend</code> directory is included in your Python package's wheel. This is typically done in <code>pyproject.toml</code>.</p> hatchlingmaturin <pre><code>[tool.hatch.build.targets.wheel.force-include]\n\"dist-frontend\" = \"my_plugin/dist-frontend\"\n</code></pre> <p>Configuring <code>vite</code> to output to a subdirectory of your python source (e.g. <code>src/my_plugin/dist-frontend</code>) ensures <code>maturin</code> includes it automatically.</p> vite.config.ts<pre><code>build: {\n    outDir: path.resolve(__dirname, \"./src/my_plugin/dist-frontend\"),\n}\n</code></pre> <p>Finally, install your Python package and enable it in your <code>tangram.toml</code>:</p> <pre><code>[core]\nplugins = [\"my_tangram_plugin\"]\n</code></pre> <p>When <code>tangram serve</code> runs, it will:</p> <ol> <li>Read the <code>plugin.json</code> manifest from every enabled plugin at startup.</li> <li>Amalgamate these into a single cached response for <code>/manifest.json</code>.</li> <li>The core web app fetches this single manifest and dynamically loads resources.</li> </ol> <pre><code>sequenceDiagram\n    participant P as Plugin Module\n    participant B as Browser\n    participant S as Tangram Server\n\n    B-&gt;&gt;S: GET /manifest.json\n    S--&gt;&gt;B: Respond with {\"plugins\": {\"my_plugin\": {\"main\": \"index.js\"}}}\n    B-&gt;&gt;S: GET /plugins/my_plugin/index.js\n    S--&gt;&gt;B: Serve plugin's JS entry point\n    Note over B, P: Browser executes plugin code\n    P-&gt;&gt;B: install(tangramApi)\n    Note over B: Plugin registers its widgets</code></pre>"},{"location":"plugins/history/","title":"History Plugin","text":"<p>The <code>tangram_history</code> plugin provides a centralized, durable persistence layer for tangram. It ingests high-frequency, append-only time-series data from producer plugins (like <code>tangram_jet1090</code> or <code>tangram_ship162</code>) and stores it efficiently in Delta Lake tables.</p> <ul> <li>buffers incoming records in memory and flushes them periodically as larger, optimized parquet files.</li> <li>uses Delta Lake for transactional writes, schema enforcement, and compatibility with query engines (datafusion, polars, duckdb...).</li> <li>makes no assumptions about data content: producers register their own schemas and data retention policies.</li> </ul> <pre><code>sequenceDiagram\n    participant P as Producer (e.g., planes)\n    participant R as Redis\n    participant H as history service\n    participant C as Consumer (e.g., API endpoint)\n    participant D as Delta Lake (Filesystem)\n\n    note over P,H: startup\n    P-&gt;&gt;R: PUBLISH history:control, {type: \"register_table\", ...}\n    H--&gt;&gt;P: PUBLISH history:control:response:..., {type: \"table_registered\", ...}\n\n    loop real-time data\n        P-&gt;&gt;R: XADD history:ingest:&lt;table&gt;, *, \"data\", \"base64(arrow_ipc)\"\n    end\n\n    H--&gt;&gt;H: buffer batches in memory\n    H-&gt;&gt;D: periodically flush buffer to delta table\n\n    note over C,D: on-demand query\n    C-&gt;&gt;D: read delta table directly</code></pre>"},{"location":"plugins/history/#protocol","title":"Protocol","text":""},{"location":"plugins/history/#control-channel-historycontrol","title":"Control channel (<code>history:control</code>)","text":"<p>Used for managing tables. Producers must register a table and its schema before sending data.</p> <ul> <li>message: <code>register_table</code></li> <li>payload fields:<ul> <li><code>sender_id</code>: a unique id for the producer instance.</li> <li><code>table_name</code>: a unique name for the table (e.g., <code>\"aircraft_states\"</code>).</li> <li><code>schema</code>: base64-encoded arrow ipc schema bytes.</li> <li><code>partition_columns</code>: list of column names to partition by.</li> <li><code>optimize_interval_secs</code>: how often to run <code>optimize</code>.</li> <li><code>vacuum_interval_secs</code>: how often to run <code>vacuum</code>.</li> <li><code>vacuum_retention_period_secs</code>: retention for <code>vacuum</code>.</li> </ul> </li> </ul>"},{"location":"plugins/history/#ingest-stream-historyingesttable_name","title":"Ingest stream (<code>history:ingest:&lt;table_name&gt;</code>)","text":"<p>A fire-and-forget redis stream for producers to send data.</p> <ul> <li>command: <code>XADD</code></li> <li>payload: a key-value pair <code>data</code> and a base64-encoded arrow ipc recordbatch in stream format.</li> </ul>"},{"location":"plugins/history/#configuration","title":"Configuration","text":"<p>The history service itself has minimal configuration. All per-table settings are provided by the producer plugins that use it.</p> tangram.toml<pre><code>[core]\nplugins = [\"tangram_history\", \"tangram_jet1090\"]\n\n# global settings for the history service\n[plugins.tangram_history]\n# base path on the local filesystem for storing delta tables.\nbase_path = \"/tmp/tangram_history\"\n# redis channel for control messages.\ncontrol_channel = \"history:control\"\n\n# producer-specific settings\n[plugins.tangram_jet1090]\nhistory_table_name = \"jet1090\"\nhistory_flush_interval_secs = 5\n# ... other history settings for this table\n</code></pre> <p>Warning</p> <p>Note that the Delta Lake protocol only supports a subset of Parquet primitive types.</p> <p>Notably, unsigned integers are not supported and will be implicitly downcasted!</p>"},{"location":"plugins/jet1090/","title":"Jet1090 Plugin","text":"<p>The <code>tangram_jet1090</code> plugin is the primary tool for integrating Mode S and ADS-B data into the <code>tangram</code> framework. It processes raw aviation surveillance data from a <code>jet1090</code> instance and makes it available for both real-time visualization and historical analysis.</p>"},{"location":"plugins/jet1090/#overview","title":"Overview","text":"<p>This plugin consists of:</p> <ul> <li>A background service (planes) to maintain a real-time state of all visible aircraft and persist their data for historical queries.</li> <li>A REST API endpoint (<code>/data/{icao24}</code>) to fetch the full, time-ordered trajectory for a specific aircraft.</li> <li>A frontend widget to display a placeholder in the UI.</li> </ul>"},{"location":"plugins/jet1090/#planes-service","title":"<code>planes</code> Service","text":"<p>The <code>planes</code> service is the core of the real-time functionality. It is a Rust-based component, wrapped with PyO3 for integration into the Python ecosystem.</p> <pre><code>sequenceDiagram\n    participant J as jet1090\n    participant R as Redis\n    participant P as planes service\n    participant C as channel service\n    participant F as Frontend\n\n    J-&gt;&gt;R: PUBLISH jet1090 (raw message)\n    P-&gt;&gt;R: SUBSCRIBE jet1090\n    Note over P: Process message, update state vector\n    P-&gt;&gt;R: XADD history:ingest:jet1090, *, ...\n\n    F-&gt;&gt;C: PUSH system:bound-box\n    C-&gt;&gt;R: PUBLISH from:system:bound-box\n    P-&gt;&gt;R: SUBSCRIBE from:system:bound-box\n    Note over P: Update client's visible area\n\n    loop Every second\n        Note over P: Filter aircraft by each client's bbox\n        P-&gt;&gt;R: PUBLISH to:streaming-client1:new-jet1090-data\n    end\n\n    C-&gt;&gt;R: SUBSCRIBE to:streaming-client1:*\n    C-&gt;&gt;F: PUSH new-jet1090-data</code></pre> <ul> <li>Continuous Tracking: It subscribes to the <code>jet1090</code> Redis channel to receive decoded aircraft messages.</li> <li>State Vector Maintenance: It maintains a comprehensive in-memory view of the current air traffic situation by collecting and processing state vectors for all active aircraft.</li> <li>History Persistence: It acts as a producer for the <code>tangram_history</code> plugin. It batches raw messages into arrow Recordbatches and sends them to a redis stream. The history service consumes this stream and persists the data into a delta lake table.</li> <li>Client-Specific Filtering: The service listens for bounding box updates from each connected frontend client. It filters the aircraft data for each client, sending only the aircraft visible within their map view.</li> <li>Data Publishing: Once per second, it publishes the filtered state vectors to a dedicated Redis channel for each client (e.g., <code>to:streaming-&lt;client_id&gt;:new-jet1090-data</code>), which are then relayed to the browser via the WebSocket <code>channel</code> service.</li> </ul>"},{"location":"plugins/jet1090/#redis-events","title":"Redis Events","text":"Direction Channel Event/Command Payload Input <code>jet1090</code> <code>PUBLISH</code> Raw JSON message from <code>jet1090</code>. Output <code>to:streaming-{id}:new-jet1090-data</code> <code>PUBLISH</code> <code>{ \"count\": 123, \"aircraft\": [...] }</code> containing visible aircraft. Output <code>history:ingest:jet1090</code> <code>XADD</code> Apache Arrow record batch (binary)."},{"location":"plugins/jet1090/#trajectory-api","title":"Trajectory API","text":"<p>The plugin provides an API for querying the historical data persisted by the <code>planes</code> service.</p> <p>Endpoint: <code>GET /jet1090/data/{icao24}</code></p> <p>Retrieves all historical data points for the given aircraft <code>icao24</code> by querying the delta lake table managed by the history service.</p> <p>This endpoint is used by the frontend to draw historical flight paths and populate data charts when an aircraft is selected.</p>"},{"location":"plugins/jet1090/#configuration","title":"Configuration","text":"<p>To use this plugin, you must have a running <code>jet1090</code> instance publishing data to Redis. You can also configure the plugin in your tangram.toml::</p> <pre><code>[core]\nplugins = [\"tangram_jet1090\", \"tangram_history\"]\n\n[plugins.tangram_jet1090]\n# the redis channel that jet1090 is publishing to.\njet1090_channel = \"jet1090\"\n# how long (in seconds) to keep an aircraft in the state vector table\n# after its last message.\nstate_vector_expire = 20\n\n# history persistence settings (requires `tangram_history` plugin)\nhistory_table_name = \"jet1090\"\nhistory_flush_interval_secs = 5\nhistory_buffer_size = 100000\n</code></pre> <p>See [tangram_jet1090.PlanesConfig] for more information.</p>"},{"location":"plugins/ship162/","title":"Ship162 Plugin","text":"<p>The <code>tangram_ship162</code> plugin integrates AIS data from a <code>ship162</code> instance, enabling real-time visualization and historical analysis of maritime traffic.</p>"},{"location":"plugins/ship162/#overview","title":"Overview","text":"<ul> <li>a background service to maintain a real-time state of all visible ships and persist their data.</li> <li>a rest api endpoint (<code>/data/ship/{mmsi}</code>) to fetch the full, time-ordered trajectory for a specific ship.</li> <li>frontend components to render ships on the map and display detailed information.</li> </ul> <pre><code>sequenceDiagram\n    participant S as ship162\n    participant R as Redis\n    participant P as ships service\n    participant C as channel service\n    participant F as Frontend\n\n    S-&gt;&gt;R: PUBLISH ship162 (raw message)\n    P-&gt;&gt;R: SUBSCRIBE ship162\n    Note over P: Process message, update state vector\n    P-&gt;&gt;R: XADD history:ingest:ship162, *, ...\n\n    loop every second\n        Note over P: Filter ships by client's bbox\n        P-&gt;&gt;R: PUBLISH to:streaming-client1:new-ship162-data\n    end\n\n    C-&gt;&gt;R: SUBSCRIBE to:streaming-client1:*\n    C-&gt;&gt;F: PUSH new-ship162-data</code></pre>"},{"location":"plugins/ship162/#redis-events","title":"Redis Events","text":"Direction Channel Event/Command Payload Input <code>ship162</code> <code>PUBLISH</code> Raw JSON message from <code>ship162</code>. Output <code>to:streaming-{id}:new-ship162-data</code> <code>PUBLISH</code> <code>{ \"count\": 123, \"ship\": [...] }</code> containing visible ships. Output <code>history:ingest:ship162</code> <code>XADD</code> Apache Arrow record batch (binary)."},{"location":"plugins/ship162/#configuration","title":"Configuration","text":"<p>To use this plugin, you must have a running <code>ship162</code> instance publishing data to redis.</p> tangram.toml<pre><code>[core]\nplugins = [\"tangram_ship162\", \"tangram_history\"]\n\n[plugins.tangram_ship162]\n# redis channel that ship162 is publishing to.\nship162_channel = \"ship162\"\n\n# how long (in seconds) to keep a ship in the state vector table\n# after its last message.\nstate_vector_expire = 600\n\n# history persistence settings\nhistory_table_name = \"ship162\"\nhistory_flush_interval_secs = 5\nhistory_buffer_size = 100000\n</code></pre>"},{"location":"plugins/system/","title":"System Plugin","text":"<p>The <code>tangram_system</code> plugin provides a background service that monitors and broadcasts server metrics like CPU load, RAM usage, and uptime. These metrics are displayed in the frontend UI.</p>"},{"location":"plugins/system/#how-it-works","title":"How It Works","text":"<ol> <li>The plugin's <code>pyproject.toml</code> registers its <code>plugin</code> object via the <code>tangram_core.plugins</code> entry point.</li> <li>This <code>plugin</code> object uses the <code>@plugin.register_service()</code> decorator to mark the <code>run_system</code> function as a background service.</li> <li>When <code>tangram serve</code> starts, the core framework discovers and runs the <code>run_system</code> service.</li> <li>It publishes these metrics as JSON payloads to the <code>to:system:update-node</code> Redis channel.</li> <li>The core <code>tangram</code> frontend is subscribed to the <code>system</code> WebSocket channel. The <code>channel</code> service forwards these Redis messages to the UI, where components like <code>SystemInfo.vue</code> update to display the live data.</li> </ol>"},{"location":"plugins/system/#redis-events","title":"Redis Events","text":"Direction Channel Event/Command Payload Output <code>to:system:update-node</code> <code>PUBLISH</code> <code>{\"el\": \"uptime\" \\| \"cpu_load\" \\| ..., \"value\": \"...\"}</code>"},{"location":"plugins/weather/","title":"Weather Plugin","text":"<p>The <code>tangram_weather</code> plugin provides API endpoints to serve meteorological data, enabling features like wind field visualization on the map.</p>"},{"location":"plugins/weather/#overview","title":"Overview","text":"<p>This plugin fetches weather prediction data from Meteo-France's ARPEGE model, processes it, and exposes it via a REST API. The data is provided as GRIB files, which are downloaded and parsed on the backend.</p>"},{"location":"plugins/weather/#how-it-works","title":"How It Works","text":"<ol> <li> <p>The plugin downloads GRIB files containing ARPEGE weather model predictions from the public data.gouv.fr repository. These files are cached locally in a temporary directory.</p> </li> <li> <p>It registers a <code>/weather</code> router with the main FastAPI application. The key endpoint is <code>/weather/wind</code>.</p> </li> <li> <p>When a request is made to <code>/weather/wind?isobaric=&lt;level&gt;</code>, the plugin:</p> <ul> <li>Determines the latest available GRIB file for the current time.</li> <li>Uses <code>xarray</code> and <code>cfgrib</code> to open the GRIB file.</li> <li>Selects the U and V wind components for the specified isobaric pressure level (e.g., 300 hPa).</li> <li>Returns the data as a JSON response.</li> </ul> </li> <li> <p>The frontend <code>WindField.vue</code> component calls this endpoint.</p> </li> </ol>"},{"location":"plugins/examples/citypair/","title":"Origin and Destination","text":""},{"location":"plugins/examples/citypair/#statement-of-need","title":"Statement of need","text":"<p>The <code>tangram_jet1090</code> plugin includes a widget that displays the origin and destination information for a selected aircraft, showing both the airport ICAO codes and the city names. This makes it easy to quickly understand the flight's route without leaving the main map interface.</p>"},{"location":"plugins/examples/citypair/#implementation","title":"Implementation","text":"<p>The city pair widget is part of the <code>AircraftInfoWidget.vue</code> component, which appears in the sidebar when an aircraft is selected.</p> <p>It works as follows:</p> <ol> <li>When an aircraft is selected, the widget uses the aircraft's callsign to make a request to the <code>/route/{callsign}</code> API endpoint.</li> <li>This endpoint, provided by the <code>tangram_jet1090</code> backend plugin, proxies the request to the OpenSky Network's route database.</li> <li>If a route is found, the widget displays the origin and destination airport ICAO codes.</li> <li>It then uses the <code>rs1090-wasm</code> library (bundled with <code>tangram</code> core) to look up and display the corresponding city names for each airport.</li> </ol> <p>This functionality is self-contained within the <code>tangram_jet1090</code> plugin and requires no extra configuration beyond enabling the plugin itself.</p> <p></p> <p>Warning</p> <p>The OpenSky Network's route service is not guaranteed to be available for all aircraft. If no route information is found, the widget will display an appropriate message.</p>"},{"location":"plugins/examples/sensors/","title":"Data Receiver Map Layer","text":""},{"location":"plugins/examples/sensors/#statement-of-need","title":"Statement of need","text":"<p>Mode S data is provided by one or more <code>jet1090</code> processes, which decode data from various sources like software-defined radios or network streams. Each source corresponds to a receiver at a specific location.</p> <p>The <code>tangram_jet1090</code> plugin provides a map layer to visualize the positions of these receivers, allowing users to see where their data is coming from.</p>"},{"location":"plugins/examples/sensors/#implementation","title":"Implementation","text":"<p>The implementation is a Vue component, <code>SensorsLayer.vue</code>, which is registered as a map overlay by the <code>tangram_jet1090</code> frontend plugin. It uses Deck.gl to render the sensor locations.</p> <ol> <li>When the map is initialized, the component fetches a list of sensors from the <code>/sensors</code> API endpoint.</li> <li>This endpoint, provided by the <code>tangram_jet1090</code> backend, proxies the request to the configured <code>jet1090</code> service. The sensor information must be configured within the <code>jet1090</code> instance itself. See the jet1090 configuration guide for details.</li> <li>The component then maps the sensor data into an array of objects suitable for Deck.gl, with each object containing a <code>position</code> array (<code>[longitude, latitude]</code>), <code>name</code>, and <code>aircraft_count</code>.</li> <li>Finally, it creates a Deck.gl <code>ScatterplotLayer</code> to render the sensor locations as points on the map. The layer's <code>onHover</code> property is used to display a tooltip with the sensor's name and the number of aircraft it is currently tracking.</li> </ol>"},{"location":"plugins/examples/windfield/","title":"Add a wind field layer","text":""},{"location":"plugins/examples/windfield/#statement-of-need","title":"Statement of need","text":"<p>Meteorological data is essential for understanding the impact of weather on aviation operations. Meteo France provides weather prediction data from their ARPEGE model. The most basic features include zonal and meridional wind components, but also temperature, pressure, and humidity. More advanced features are also available but we will not cover them here.</p> <p>A web API is available after registration, but we will prefer here the GRIB files that can also be downloaded directly from the data.gouv.fr initiative, also provided by Meteo France under an Open License.</p> <p>New predictions are published every 6 hours, and the data is available for 3 days in advance. The data is provided in GRIB format, which is a standard format for meteorological data. In each file, each grid point represents spatio-temporal coordinates, and the data is provided for each hour of the day. The data is available at a resolution of 0.1 degrees, which is approximately 11 km at the equator. Altitude is provided in isobars, which is a standard unit for atmospheric pressure.</p>"},{"location":"plugins/examples/windfield/#implementation","title":"Implementation","text":"<p>The <code>tangram_weather</code> plugin displays a wind field on the map at a user-specified isobaric level. It consists of a backend service to provide the data and a frontend widget to control and display it.</p>"},{"location":"plugins/examples/windfield/#1-backend-wind-information-api","title":"1. Backend: Wind Information API","text":"<p>The <code>tangram_weather</code> plugin is a self-contained, installable Python package. Its <code>pyproject.toml</code> registers it as a <code>tangram</code> plugin via an entry point:</p> <pre><code>[project.entry-points.\"tangram_core.plugins\"]\ntangram_weather = \"tangram_weather:plugin\"\n</code></pre> <p>The plugin's <code>src/tangram_weather/__init__.py</code> file defines a FastAPI <code>APIRouter</code> and registers it with the <code>tangram_core</code> application.</p> <pre><code>import tangram_core\nfrom fastapi import APIRouter\n# ...\n\nrouter = APIRouter(...)\n\n@router.get(\"/wind\")\nasync def wind(isobaric: int = 300) -&gt; ORJSONResponse:\n    # ... implementation ...\n\nplugin = tangram_core.Plugin(routers=[router])\n</code></pre> <p>The plugin, associated with the <code>/weather</code> router will provide an API endpoint to fetch the wind field data for a specific isobar.</p> <p>The logic for downloading the data is implemented in the <code>arpege.py</code> file.</p> <p>The code is self-explanatory, but the following points are worth noting:</p> <ul> <li>in <code>__init__.py</code>, the <code>wind(isobaric: int)</code> function returns a <code>ORJSONResponse</code> (from <code>fastapi.responses</code>) rather than a <code>JSONResponse</code>. This is because the data is large and we want to avoid the overhead of converting it to JSON. The <code>ORJSONResponse</code> is a faster alternative, based on <code>orjson</code> that can handle large data efficiently. It also automatically deals with datetime objects, which are used in the GRIB data.</li> </ul> <p>Tip</p> <p>Extra Python libraries can be included with the <code>uv add</code> command.</p> <p>The command edits both the <code>pyproject.toml</code> and the <code>uv.lock</code> files:</p> <pre><code>uv add xarray cfgrib orjson\n</code></pre> <ul> <li> <p>in <code>arpege.py</code>, the download of the GRIB file is wrapped in a try/except block. If the file is not found (or Internet is momentarily unavailable), the function will try to get the previous file (6 hours before) and return it. It can be useful to fallback to older files when the newer versions are not yet available.</p> </li> <li> <p>the <code>xarray</code> library offers a <code>load_dataset</code> and an <code>open_dataset</code> function to read GRIB files. The <code>open_dataset</code> function is used here, as it allows to read the file without loading it entirely into memory, which is useful for large files.</p> </li> </ul> <p>Warning</p> <p>There is an issue with the packaging of the <code>ecCodes</code> library that is used by <code>xarray</code> to read GRIB files. The specific version of the <code>ecCodes</code> library for Linux/arm64 is not yet available at the time of writing this documentation.</p> <p>You are most likely to be impacted by this issue if you run this plugin on Apple Silicon Mac computers. In that case, you may want to run <code>just c-build eccodes_strategy='fromsource'</code> to create a new Docker image with the latest version of the <code>ecCodes</code> library. The <code>just c-run</code> command will then use this image to run the application.</p>"},{"location":"plugins/examples/windfield/#2-frontend-the-windfieldlayer","title":"2. Frontend: The <code>WindFieldLayer</code>","text":"<p>The frontend component, <code>WindFieldLayer.vue</code>, provides the user interface for the wind layer. It is rendered using Deck.gl and the <code>weatherlayers-gl</code> library for high-performance visualization.</p>"},{"location":"plugins/examples/windfield/#user-interface","title":"User Interface","text":"<p>The component renders a slider as a map overlay. This slider allows the user to select an isobaric level (in hPa) and displays the corresponding approximate flight level (FL). When the user changes the slider's value, the component calls the <code>/weather/wind</code> backend endpoint.</p>"},{"location":"plugins/examples/windfield/#wind-field-rendering-with-deckgl","title":"Wind Field Rendering with Deck.gl","text":"<p>The rendering process leverages WebGL for smooth particle animation:</p> <ol> <li>The backend API (<code>/weather/wind</code>) processes the GRIB file and returns the U and V wind components encoded as an RGBA PNG image (in a Base64 data URI), along with geographic bounds.</li> <li>The frontend decodes this image data into a texture.</li> <li>A <code>ParticleLayer</code> from <code>weatherlayers-gl</code> is created using this texture to visualize the wind flow with animated particles.</li> <li>This Deck.gl layer is added to the map via the <code>tangramApi</code>.</li> </ol>"},{"location":"plugins/examples/windfield/#3-enabling-the-plugin","title":"3. Enabling the Plugin","text":"<p>To use the wind field layer, install the <code>tangram_weather</code> package and add it to the <code>plugins</code> list in your <code>tangram.toml</code>:</p> <pre><code>[core]\nplugins = [\"tangram_weather\"]\n</code></pre> <p>After restarting <code>tangram</code>, the wind field widget will appear on the map. It may take a few moments to download the GRIB file the first time.</p> <p></p> <p>Tip</p> <p>Note that the wind field that is displayed for <code>TRA6424</code> is consistent with the groundspeed and true airspeed measured by the aircraft: 30 m/s (displayed on the lower right corner of the map) roughly corresponds to 60 kts, which is compatible with the delta in the speed values in the plot. Also a higher ground speed value is observed when the aircraft is flying with a strong tail wind.</p>"}]}