{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"An open framework for modular, real-time air traffic management research","text":"<p>tangram is an open research framework for ADS-B and Mode S flight surveillance data designed for various real-time aviation research topics such as GNSS jamming detection, aviation weather monitoring, emission analysis, and airport performance monitoring.</p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p><code>tangram</code> is built on a plugin-first architecture. It provides a lightweight core application, and all major functionality, from data processing to new UI widgets, is added through <code>pip</code>-installable packages.</p> <p>The core framework includes a JavaScript-based web application and a backend powered by Python and Rust. This foundation is designed to be extended, allowing researchers to develop and integrate their own plugins for specific research needs. This modularity enables the community to contribute to the platform, encouraging collaboration and knowledge sharing.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Quickstart: A step-by-step guide to get started with tangram</li> <li>Configuration: Information on how to configure the system for your needs</li> <li>Architecture: An overview of the system architecture and components</li> <li>Plugins: Extend the system with custom functionalities</li> <li>Contribute to tangram: Guidelines for contributing to the project</li> </ul> <p>For more information, visit GitHub</p>"},{"location":"configuration/","title":"Configuration","text":"<p><code>tangram</code> is configured through a single <code>tangram.toml</code> file. This provides a centralized and clear way to manage the entire platform, from core services to plugins.</p>"},{"location":"configuration/#example-tangramtoml","title":"Example <code>tangram.toml</code>","text":"<pre><code>[core]\n# URL for the Redis instance used for pub/sub messaging.\nredis_url = \"redis://localhost:6379\"\n\n# a list of installed plugin packages to activate.\n# tangram will look for entry points provided by these packages.\nplugins = [\n    \"tangram_system\",\n    \"tangram_jet1090\",\n    \"my_awesome_package\"\n]\n\n[server]  # (1)!\n# main FastAPI web server, which serves the\n# frontend application and plugin API routes.\nhost = \"127.0.0.1\"\nport = 2346\n\n[channel]  # (2)!\n# integrated real-time WebSocket service.\nhost = \"127.0.0.1\"\nport = 2347\n# (optional) the public-facing base URL for the channel service, e.g., \"https://tangram.example.com\".\n# use this when running behind a reverse proxy.\n# public_url = \"http://localhost:2347\"\n# a secret key used to sign JSON Web Tokens (JWTs) for authenticating\n# WebSocket connections. Change this to a strong, unique secret.\njwt_secret = \"a-better-secret-than-this\"\n\n[map]\n# The basemap style can be a URL, a path to a local JSON file (relative to this config or absolute),\n# or the id of a style defined in [[map.styles]].\nstyle = \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\"\n# style = \"./my-custom-style.json\"\n# style = \"dark-matter\"\n\n# You can define multiple map styles available to the application.\n[[map.styles]]\nname = \"Dark Matter\"\nid = \"dark-matter\"\nversion = 8\nsources = { openmaptiles = { type = \"vector\", url = \"https://d17gef4m69t9r4.cloudfront.net/planet.json\" } }\nsprite = \"https://openmaptiles.github.io/dark-matter-gl-style/sprite\"\nglyphs = \"https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf\"\n# ... layers ...\n</code></pre> <ol> <li>See <code>tangram_core.config.CoreConfig</code>.</li> <li>See <code>tangram_core.config.ServerConfig</code></li> <li>See <code>tangram_core.config.ChannelConfig</code></li> </ol>"},{"location":"configuration/#plugin-configuration","title":"Plugin Configuration","text":"<p>Plugin-specific configuration is defined in its own table, following the pattern <code>[plugins.&lt;plugin_package_name&gt;]</code>.</p> <p>For details on each plugin's available settings, refer to their respective documentation:</p> <ul> <li><code>tangram_jet1090</code></li> <li><code>tangram_ship162</code></li> <li><code>tangram_history</code></li> <li><code>tangram_explore</code></li> <li><code>tangram_system</code></li> <li><code>tangram_airports</code></li> </ul>"},{"location":"contribute/","title":"Contribute to tangram","text":"<p>We aim to provide a quality codebase with documentation, but expect that you will find bugs and issues, and hope you will also imagine very creative plugins.</p> <p>We welcome contributions to the project, whether it is code, documentation, or bug reports.</p>"},{"location":"contribute/#bug-reports","title":"Bug reports","text":"<p>Please file bug reports on the GitHub issue tracker.</p> <p>When filing a bug report, please include the following information:</p> <ul> <li>A clear description of the issue</li> <li>Steps to reproduce the issue</li> <li>Expected and actual behaviour</li> <li>Any relevant logs or error messages</li> <li>Your environment (OS, browser, etc.)</li> </ul>"},{"location":"contribute/#bug-fixes-and-contributions","title":"Bug fixes and contributions","text":"<p>If you want to contribute code, please follow these steps:</p> <ol> <li>Fork the repository on GitHub</li> <li>Create a new branch for your feature or bug fix</li> <li>Make your changes and commit them with a clear message</li> <li>Push your changes to your forked repository</li> <li>Create a pull request against the <code>main</code> branch of the original repository</li> <li>Include a clear description of your changes and why they are needed</li> <li>Ensure your code follows the project's coding standards and passes all tests</li> <li>If your changes are related to a specific issue, reference that issue in your pull request description</li> </ol>"},{"location":"contribute/#plugins","title":"Plugins","text":"<p>If you want to share a plugin you have developed, please start by sharing a preview in the Discussions</p>"},{"location":"contribute/#style-guide","title":"Style guide","text":"<p>We do not want to be too strict about the coding standards, but we expect that you will follow the general style guides of the rest of the codebase. Ensure your contribution doesn't reformat existing code unnecessarily, as this can make it harder to review changes.</p> <p>Please take into account the <code>.editorconfig</code> file in the root of the repository, which defines the coding style for the project. You can find more information about EditorConfig here and install plugins for your favourite editor.</p>"},{"location":"contribute/#development-workflow","title":"Development Workflow","text":"<p>The project is structured as a monorepo with <code>uv</code> managing the Python workspaces and <code>pnpm</code> managing the frontend workspaces.</p>"},{"location":"contribute/#building-for-distribution","title":"Building for Distribution","text":"<p>Each Python package (the core <code>tangram</code> and its plugins) can be built into a standard wheel for distribution. The frontend assets should first be built so downstream users won't have to install npm.</p> <pre><code># from the repository root\npnpm i\npnpm build\nuv build --all-packages\n</code></pre>"},{"location":"contribute/#testing-channel-core","title":"Testing Channel Core","text":"<p>The core WebSocket logic is written in Rust. To run these tests, you need a local Redis instance:</p> <pre><code># in packages/tangram_core/rust\ncargo test --features channel\n</code></pre>"},{"location":"contribute/#continuous-integration","title":"Continuous Integration","text":"<p>The CI pipeline, defined in GitHub Actions, automates quality checks and builds. The primary steps are:</p> <ol> <li>Building Wheel: The build process above is automated for all versions from Python 3.10 to 3.13, on Linux, MacOS, Windows and processor architectures.</li> <li>Testing: Python tests are executed using <code>pytest</code> (scope is limited for now)</li> <li>Container Build: A podman image is built using the root <code>Containerfile</code>, serving as an integration test.</li> </ol> <p>Warning</p> <p>The <code>tangram_weather</code> plugin depends on the <code>eccodes</code> library, which is problematic on non-<code>x86_64</code> systems. You can choose to build the <code>eccodes</code> library from source with the <code>ECCODES_STRATEGY</code> in the container build argument.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<ul> <li>For Users: To install and run <code>tangram</code> with official plugins, start here \u00bb</li> <li>For Developers: To contribute to the <code>tangram</code> core project, set up the monorepo \u00bb</li> <li>For Plugin Authors: To build your own extensions for <code>tangram</code>, read the plugin development guide \u00bb</li> </ul>"},{"location":"quickstart/#user-quickstart","title":"User Quickstart","text":""},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following installed:</p> <ul> <li>redis 5 or above (via podman/docker or system-installed version)</li> <li>Python 3.10 or above</li> </ul>"},{"location":"quickstart/#1-install-the-tangram-core","title":"1. Install the <code>tangram</code> core","text":"uvpip <pre><code>uv tool install tangram_core\n</code></pre> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install tangram_core\n</code></pre> <p>For end users, the only supported installation method is from a package index (like PyPI) that hosts pre-built binary wheels. For developers wanting to use the latest git version, refer to the developer guide below.</p>"},{"location":"quickstart/#2-configuration","title":"2. Configuration","text":"<p>Create a <code>tangram.toml</code> file to control the application. This is where you define which plugins are active.</p> <pre><code>[core]\nredis_url = \"redis://127.0.0.1:6379\"\nplugins = []\n\n[server]\nhost = \"127.0.0.1\"\nport = 2346\n\n[channel]\nhost = \"127.0.0.1\"\nport = 2347\njwt_secret = \"a-better-secret-than-this\"\njwt_expiration_secs = 315360000\n</code></pre>"},{"location":"quickstart/#3-running-tangram","title":"3. Running <code>tangram</code>","text":"<p><code>tangram</code> uses Redis for messaging. The easiest way to run one is with a container. Install podman or docker and run:</p> <pre><code>podman run -d --rm -p 6379:6379 --name redis redis:8-alpine\n</code></pre> <p>On Windows, running podman/redis will require WSL2.</p> <p>To start tangram, run:</p> <pre><code>tangram serve --config /path/to/your/tangram.toml\n</code></pre> <p>Open your browser and navigate to http://localhost:2346 to access the web interface.</p>"},{"location":"quickstart/#4-adding-functionality-with-plugins","title":"4. Adding functionality with plugins","text":"<p>The core <code>tangram</code> application provides the shell. All features are added by installing and enabling plugins.</p>"},{"location":"quickstart/#example-1-add-system-monitoring","title":"Example 1: add system monitoring","text":"<p>The <code>tangram_system</code> plugin adds a widget to the UI that displays server metrics like CPU and memory usage. It is a pure-Python package with no external services.</p>"},{"location":"quickstart/#1-install-the-plugin-package","title":"1. Install the plugin package","text":"uvpip <pre><code>uv tool install --with tangram_system tangram_core\n</code></pre> <pre><code># assuming you have an active virtual environment with tangram_core installed\npip install tangram_system\n</code></pre>"},{"location":"quickstart/#2-enable-the-plugin-in-your-tangramtoml","title":"2. Enable the plugin in your <code>tangram.toml</code>","text":"<pre><code>[core]\nredis_url = \"redis://127.0.0.1:6379\"\nplugins = [\"tangram_system\"]\n\n[server]\n# ...\n</code></pre>"},{"location":"quickstart/#3-restart-the-server","title":"3. Restart the server","text":"<p>Stop the running <code>tangram serve</code> process (Ctrl + C) and start it again. The web interface will now include the system monitoring widget.</p>"},{"location":"quickstart/#example-2-add-live-aircraft-data","title":"Example 2: add live aircraft data","text":"<p>To display live flight data, you need the <code>tangram_jet1090</code> plugin. This plugin acts as a bridge: it collects decoded aircraft states from Redis and serves them to the frontend. It requires an external data source (like the <code>jet1090</code> tool) to decode raw radio messages and push them to Redis.</p>"},{"location":"quickstart/#1-run-the-jet1090-service","title":"1. Run the <code>jet1090</code> service","text":"<p>The plugin needs a running <code>jet1090</code> instance to receive Mode S/ADS-B data. The easiest way to run one is with a container.</p> Install pre-built binariesPodman/Docker <p>Follow instructions on the jet1090 documentation to install <code>jet1090</code> on your system (Shell script, Powershell or Homebrew).</p> <p>Then run it in a separate terminal:</p> <pre><code># connects to a public feed.\njet1090 --redis-url redis://127.0.0.1:6379 ws://feedme.mode-s.org:9876/40128@EHRD\n--interactive\n</code></pre> <pre><code># connects to a public feed.\npodman run -d --rm --name jet1090 \\\n--network=host \\\nghcr.io/xoolive/jet1090:latest \\\njet1090 --redis-url redis://127.0.0.1:6379 ws://feedme.mode-s.org:9876/40128@EHRD\n--interactive\n</code></pre> <p>Use your own receiver feed URL if you have one. See jet1090 documentation</p> <p>Tip</p> <p>The <code>jet1090</code> container is a dependency of the plugin, not the <code>tangram</code> core. You can run it on any machine as long as it can connect to your Redis instance.</p>"},{"location":"quickstart/#2-install-and-enable-the-plugin","title":"2. Install and enable the plugin","text":"<p>Just like before, install the package and add it to your <code>tangram.toml</code>.</p> uvpip <pre><code>uv tool install --with tangram_system --with tangram_jet1090 tangram_core\n</code></pre> <pre><code># assuming you have an active virtual environment with tangram_core installed\npip install tangram_jet1090\n</code></pre> <pre><code>[core]\nredis_url = \"redis://127.0.0.1:6379\"\nplugins = [\n    \"tangram_system\",\n    \"tangram_jet1090\"\n]\n</code></pre>"},{"location":"quickstart/#3-restart-tangram-serve","title":"3. Restart <code>tangram serve</code>","text":"<p>After restarting, your map should begin to populate with live aircraft data.</p> <pre><code>graph LR\n    subgraph Your Machine\n        direction LR\n        J[jet1090 container] --&gt; R[Redis]\n        T[tangram process] --&gt; R\n    end\n    subgraph Internet\n        F[Public ADS-B Feed] --&gt; J\n    end\n\n    B[Browser] --&gt; T</code></pre>"},{"location":"quickstart/#developer-quickstart","title":"Developer Quickstart","text":"<p>This guide is for setting up a development environment for the <code>tangram</code> core and builtin plugins. To extend <code>tangram</code>, start with the Backend Plugin Guide instead. This is the definitive resource for creating your own installable plugins with custom APIs and services.</p> <p>Ensure you have the following installed:</p> <ul> <li>git</li> <li>redis 8 or above (via podman/docker or system-installed version)</li> <li>Python 3.10 or above</li> <li>uv (not required, but highly recommended)</li> <li>Rust</li> <li>Node and pnpm</li> </ul> <p>To get things quickly installed on a Unix-based system:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\ncurl -fsSL https://fnm.vercel.app/install | bash\nfnm install --latest\nnpm install -g corepack\ncorepack enable pnpm\n</code></pre> <p>??? Windows support</p> <pre><code>Use of WSL is strongly recommended.\n\nTo build Rust code, you will need `link.exe`, which can be obtained via MSVC Build Tools. Alternatively, set the default to the GNU ABI.\n\nTo build `tangram_core`, you will also need [NASM](https://www.nasm.us/pub/nasm/releasebuilds/) and [CMake](https://cmake.org/download/) for the `aws-lc-rs` for JSON web token. Alternatively, set `AWS_LC_SYS_PREBUILT_NASM=1` in the environment variables.\n\nTo run `just` commands, use Git Bash.\n\nFor Redis, use of podman is highly recommended.\n</code></pre> <p>??? Virtual Machine support</p> <pre><code>Tangram requires WebGL 2.\n\nOn Chromium, to force software rendering, go to `chrome://flags`, set `Override software rendering list` to `Enabled` and `ANGLE graphics backend` to OpenGL or D3D11.\n\nOtherwise, you will need to setup [GPU passthrough](https://juniorfox.net/article/gpu-passthrough-with-looking-glass).\n</code></pre>"},{"location":"quickstart/#environment-setup","title":"Environment Setup","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/open-aviation/tangram.git\ncd tangram\n</code></pre> <ol> <li>Build the frontend:</li> </ol> <pre><code>pnpm i\npnpm build\n</code></pre> <p>This will create <code>node_modules</code> and <code>dist-frontend</code> within each package, for example:</p> <pre><code>$ tree packages\npackages\n\u251c\u2500\u2500 tangram_airports\n\u2502   \u251c\u2500\u2500 dist-frontend\n\u2502   \u2502   \u251c\u2500\u2500 index.css\n\u2502   \u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2502   \u251c\u2500\u2500 index.js.map\n\u2502   \u2502   \u2514\u2500\u2500 plugin.json\n\u2502   \u251c\u2500\u2500 node_modules\n\u2502   \u2502   \u2514\u2500\u2500 @open-aviation\n\u2502   \u2502       \u2514\u2500\u2500 tangram-core -&gt; ../../../tangram_core\n...\n</code></pre> <ol> <li>Ensure Redis (and any other services like <code>jet1090</code>) are running, as described in the user guide above.</li> </ol>"},{"location":"quickstart/#running-in-development-mode","title":"Running in Development Mode","text":"<p>To install the core application and all plugins in editable mode, along with useful developer utilities:</p> <pre><code>uv sync --all-packages --all-groups --all-extras\n</code></pre> <p>This will create a virtual environment at <code>.venv/</code>. For Rust-based packages, the <code>maturin</code> build backend will create shared objects under each package:</p> <pre><code>$ rg --files -u packages | rg \"so$\" | xargs stat -c \"%s %n\"\n7857160 packages/tangram_jet1090/src/tangram_jet1090/_planes.cpython-313-x86_64-linux-gnu.so\n6503144 packages/tangram_core/src/tangram_core/_core.cpython-313-x86_64-linux-gnu.so\n7049616 packages/tangram_ship162/src/tangram_ship162/_ships.cpython-313-x86_64-linux-gnu.so\n151122456 packages/tangram_history/src/tangram_history/_history.cpython-313-x86_64-linux-gnu.so\n</code></pre> <p>Tip</p> <p>By default, <code>uv sync</code> builds the Rust code in release mode, which can take up to 4 minutes.</p> <p>You may want to use <code>uv sync --config-setting 'build-args=--profile=dev'</code> instead to significantly speed up recompilation, at the cost of much larger binary sizes and worse performance.</p> <p>To start the <code>tangram</code> server, run:</p> <pre><code>uv run tangram serve --config tangram.example.toml\n</code></pre> <p>This runs the FastAPI application, the <code>channel</code> service, and all enabled backend plugins.</p> <p>The application will be available at <code>http://localhost:2346</code>.</p> <p>Frontend Development</p> <p>Hot Module Replacement (HMR) for frontend plugins is not supported. To build or modify frontend components, you must have <code>node</code> and <code>pnpm</code> installed. Re-run <code>pnpm build</code> and restart <code>tangram serve</code> to see changes. If you made changes to Rust code, you may need to re-run <code>uv</code> with the <code>--force-reinstall</code> or <code>--reinstall-package</code> flag.</p> <p>To build the documentation:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>To format all Rust, Python and JS code:</p> <pre><code>just fmt\n</code></pre>"},{"location":"quickstart/#running-in-release-mode","title":"Running in Release Mode","text":"<p>Make sure the frontend is built, and run:</p> <pre><code>uv build --all-packages\n</code></pre> <p>You should see:</p> <pre><code>$ ls -sh1 dist/\ntotal 54M\n 12K tangram_airports-0.2.0-py2.py3-none-any.whl\n8.0K tangram_airports-0.2.0.tar.gz\n2.5M tangram_core-0.2.0-cp313-cp313-linux_x86_64.whl\n 64K tangram_core-0.2.0.tar.gz\n...\n</code></pre> <p>To verify things work, create a virtual environment separate from the usual <code>.venv</code> and install it:</p> <pre><code>uv venv .venv_whl\nuv pip install --python .venv_whl dist/tangram*.whl\n</code></pre> <p>To start the <code>tangram</code> server, run:</p> <pre><code>uv run --python .venv_whl tangram serve --config tangram.example.toml\n</code></pre>"},{"location":"api/core/","title":"Core","text":""},{"location":"api/core/#tangram_core","title":"tangram_core","text":""},{"location":"api/core/#tangram_core.InjectBackendState","title":"InjectBackendState  <code>module-attribute</code>","text":"<pre><code>InjectBackendState: TypeAlias = Annotated[\n    BackendState, Depends(get_state)\n]\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState","title":"BackendState  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>@dataclass\nclass BackendState:\n    redis_client: redis.Redis\n    http_client: httpx.AsyncClient\n    config: Config\n    loaded_plugins: dict[str, Plugin] = field(default_factory=dict)\n\n    @property\n    def base_url(self) -&gt; str:\n        host = self.config.server.host\n        port = self.config.server.port\n        if host == \"0.0.0.0\":\n            host = \"127.0.0.1\"\n        return f\"http://{host}:{port}\"\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState.redis_client","title":"redis_client  <code>instance-attribute</code>","text":"<pre><code>redis_client: Redis\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState.http_client","title":"http_client  <code>instance-attribute</code>","text":"<pre><code>http_client: AsyncClient\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: Config\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState.loaded_plugins","title":"loaded_plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loaded_plugins: dict[str, Plugin] = field(\n    default_factory=dict\n)\n</code></pre>"},{"location":"api/core/#tangram_core.BackendState.base_url","title":"base_url  <code>property</code>","text":"<pre><code>base_url: str\n</code></pre>"},{"location":"api/core/#tangram_core.Runtime","title":"Runtime","text":"<p>Manages the lifecycle of the Tangram backend, including the Uvicorn server, background services, and connection pools (Redis, HTTPX).</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>class Runtime:\n    \"\"\"Manages the lifecycle of the Tangram backend, including the\n    Uvicorn server, background services, and connection pools (Redis, HTTPX).\n    \"\"\"\n\n    def __init__(self, config: IntoConfig | None = None) -&gt; None:\n        if isinstance(config, (str, Path, os.PathLike)):\n            self.config = Config.from_file(config)\n        else:\n            self.config = config or Config()\n        self._stack = AsyncExitStack()\n        self._state: BackendState | None = None\n        self._server: uvicorn.Server | None = None\n        self._server_task: asyncio.Task[None] | None = None\n        self._service_tasks: list[asyncio.Task[None]] = []\n\n    @property\n    def state(self) -&gt; BackendState:\n        if self._state is None:\n            raise RuntimeError(\"runtime is not started, call start() first\")\n        return self._state\n\n    async def start(self) -&gt; Runtime:\n        \"\"\"Starts the backend runtime.\"\"\"\n        if self._state is not None:\n            raise RuntimeError(\"runtime is already started\")\n\n        redis_client = await self._stack.enter_async_context(\n            redis.from_url(self.config.core.redis_url)  # type: ignore\n        )\n        http_client = await self._stack.enter_async_context(\n            httpx.AsyncClient(http2=True)\n        )\n        self._state = BackendState(\n            redis_client=redis_client,\n            http_client=http_client,\n            config=self.config,\n        )\n\n        loaded_plugins = load_enabled_plugins(self.config)\n        app = create_app(self._state, loaded_plugins)\n\n        server_config = uvicorn.Config(\n            app,\n            host=self.config.server.host,\n            port=self.config.server.port,\n            log_config=get_log_config_dict(self.config),\n        )\n        self._server = uvicorn.Server(server_config)\n\n        self._service_tasks.append(\n            asyncio.create_task(run_channel_service(self.config))\n        )\n        for plugin in loaded_plugins:\n            for _, service_func in sorted(\n                plugin.services, key=lambda s: (s[0], s[1].__name__)\n            ):\n                self._service_tasks.append(\n                    asyncio.create_task(service_func(self._state))\n                )\n                logger.info(f\"started service from plugin: {plugin.dist_name}\")\n\n        self._server_task = asyncio.create_task(self._server.serve())\n\n        while not self._server.started:\n            if self._server_task.done():\n                await self._server_task\n            await asyncio.sleep(0.1)\n\n        return self\n\n    async def wait(self) -&gt; None:\n        \"\"\"Waits for the server task to complete (e.g. via signal or internal error).\"\"\"\n        if self._server_task:\n            try:\n                await self._server_task\n            except asyncio.CancelledError:\n                pass\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stops the backend runtime.\"\"\"\n        if self._server and self._server.started:\n            self._server.should_exit = True\n            if self._server_task:\n                try:\n                    await self._server_task\n                except asyncio.CancelledError:\n                    pass\n\n        for task in self._service_tasks:\n            task.cancel()\n        if self._service_tasks:\n            await asyncio.gather(*self._service_tasks, return_exceptions=True)\n        self._service_tasks.clear()\n\n        await self._stack.aclose()\n        self._state = None\n        self._server = None\n        self._server_task = None\n\n    async def __aenter__(self) -&gt; Runtime:\n        return await self.start()\n\n    async def __aexit__(self, *args: Any) -&gt; None:\n        await self.stop()\n</code></pre>"},{"location":"api/core/#tangram_core.Runtime.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = from_file(config)\n</code></pre>"},{"location":"api/core/#tangram_core.Runtime.state","title":"state  <code>property</code>","text":"<pre><code>state: BackendState\n</code></pre>"},{"location":"api/core/#tangram_core.Runtime.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; Runtime\n</code></pre> <p>Starts the backend runtime.</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def start(self) -&gt; Runtime:\n    \"\"\"Starts the backend runtime.\"\"\"\n    if self._state is not None:\n        raise RuntimeError(\"runtime is already started\")\n\n    redis_client = await self._stack.enter_async_context(\n        redis.from_url(self.config.core.redis_url)  # type: ignore\n    )\n    http_client = await self._stack.enter_async_context(\n        httpx.AsyncClient(http2=True)\n    )\n    self._state = BackendState(\n        redis_client=redis_client,\n        http_client=http_client,\n        config=self.config,\n    )\n\n    loaded_plugins = load_enabled_plugins(self.config)\n    app = create_app(self._state, loaded_plugins)\n\n    server_config = uvicorn.Config(\n        app,\n        host=self.config.server.host,\n        port=self.config.server.port,\n        log_config=get_log_config_dict(self.config),\n    )\n    self._server = uvicorn.Server(server_config)\n\n    self._service_tasks.append(\n        asyncio.create_task(run_channel_service(self.config))\n    )\n    for plugin in loaded_plugins:\n        for _, service_func in sorted(\n            plugin.services, key=lambda s: (s[0], s[1].__name__)\n        ):\n            self._service_tasks.append(\n                asyncio.create_task(service_func(self._state))\n            )\n            logger.info(f\"started service from plugin: {plugin.dist_name}\")\n\n    self._server_task = asyncio.create_task(self._server.serve())\n\n    while not self._server.started:\n        if self._server_task.done():\n            await self._server_task\n        await asyncio.sleep(0.1)\n\n    return self\n</code></pre>"},{"location":"api/core/#tangram_core.Runtime.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Waits for the server task to complete (e.g. via signal or internal error).</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Waits for the server task to complete (e.g. via signal or internal error).\"\"\"\n    if self._server_task:\n        try:\n            await self._server_task\n        except asyncio.CancelledError:\n            pass\n</code></pre>"},{"location":"api/core/#tangram_core.Runtime.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stops the backend runtime.</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stops the backend runtime.\"\"\"\n    if self._server and self._server.started:\n        self._server.should_exit = True\n        if self._server_task:\n            try:\n                await self._server_task\n            except asyncio.CancelledError:\n                pass\n\n    for task in self._service_tasks:\n        task.cancel()\n    if self._service_tasks:\n        await asyncio.gather(*self._service_tasks, return_exceptions=True)\n    self._service_tasks.clear()\n\n    await self._stack.aclose()\n    self._state = None\n    self._server = None\n    self._server_task = None\n</code></pre>"},{"location":"api/core/#tangram_core.Config","title":"Config  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass Config:\n    core: CoreConfig = field(default_factory=CoreConfig)\n    server: ServerConfig = field(default_factory=ServerConfig)\n    channel: ChannelConfig = field(default_factory=ChannelConfig)\n    map: MapConfig = field(default_factory=MapConfig)\n    plugins: dict[str, Any] = field(default_factory=dict)\n    \"\"\"Mapping of plugin name to plugin-specific config.\"\"\"\n    cache: CacheConfig = field(default_factory=CacheConfig)\n\n    @classmethod\n    def from_file(cls, config_path: StrOrPathLike) -&gt; Config:\n        if sys.version_info &lt; (3, 11):\n            import tomli as tomllib\n        else:\n            import tomllib\n        from pydantic import TypeAdapter\n\n        with open(config_path, \"rb\") as f:\n            cfg_data = tomllib.load(f)\n\n        base_dir = Path(config_path).parent\n        map = cfg_data.setdefault(\"map\", {})\n        if (s := map.get(\"style\", None)) is not None:\n            map[\"style\"] = try_resolve_local_style(base_dir, s, allow_style_name=True)\n\n        map[\"styles\"] = [\n            try_resolve_local_style(base_dir, style, allow_style_name=False)\n            for style in map.get(\"styles\", []) or default_styles()\n        ]\n\n        config_adapter = TypeAdapter(cls)\n        config = config_adapter.validate_python(cfg_data)\n        return config\n</code></pre>"},{"location":"api/core/#tangram_core.Config.core","title":"core  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>core: CoreConfig = field(default_factory=CoreConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.server","title":"server  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>server: ServerConfig = field(default_factory=ServerConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.channel","title":"channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>channel: ChannelConfig = field(\n    default_factory=ChannelConfig\n)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.map","title":"map  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>map: MapConfig = field(default_factory=MapConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plugins: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>Mapping of plugin name to plugin-specific config.</p>"},{"location":"api/core/#tangram_core.Config.cache","title":"cache  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache: CacheConfig = field(default_factory=CacheConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.Config.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(config_path: StrOrPathLike) -&gt; Config\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: StrOrPathLike) -&gt; Config:\n    if sys.version_info &lt; (3, 11):\n        import tomli as tomllib\n    else:\n        import tomllib\n    from pydantic import TypeAdapter\n\n    with open(config_path, \"rb\") as f:\n        cfg_data = tomllib.load(f)\n\n    base_dir = Path(config_path).parent\n    map = cfg_data.setdefault(\"map\", {})\n    if (s := map.get(\"style\", None)) is not None:\n        map[\"style\"] = try_resolve_local_style(base_dir, s, allow_style_name=True)\n\n    map[\"styles\"] = [\n        try_resolve_local_style(base_dir, style, allow_style_name=False)\n        for style in map.get(\"styles\", []) or default_styles()\n    ]\n\n    config_adapter = TypeAdapter(cls)\n    config = config_adapter.validate_python(cfg_data)\n    return config\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin","title":"Plugin  <code>dataclass</code>","text":"<p>Stores the metadata and registered API routes, background services and frontend assets for a tangram plugin.</p> <p>Packages should declare an entry point in the <code>tangram_core.plugins</code> group in their <code>pyproject.toml</code> pointing to an instance of this class.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>@dataclass\nclass Plugin:\n    \"\"\"Stores the metadata and registered API routes, background services and\n    frontend assets for a tangram plugin.\n\n    Packages should declare an entry point in the `tangram_core.plugins` group\n    in their `pyproject.toml` pointing to an instance of this class.\n    \"\"\"\n\n    frontend_path: str | None = None\n    \"\"\"Path to the compiled frontend assets, *relative* to the distribution root\n    (editable) or package root (wheel).\n    \"\"\"\n    routers: list[APIRouter] = field(default_factory=list)\n    config_class: type | None = None\n    \"\"\"The **backend** configuration class (dataclass, TypedDict or Pydantic model)\n    for the plugin.\"\"\"\n    frontend_config_class: type | None = None\n    \"\"\"The **frontend** configuration class for the plugin. If set, it will be used to\n    generate the frontend schema and validate settings updates.\n    Fields should be annotated with [tangram_core.config.FrontendMutable][] if they\n    are allowed to be modified from the frontend settings UI.\n    \"\"\"\n    into_frontend_config_function: IntoFrontendConfigFunction | None = None\n    \"\"\"Function to transform the backend configuration into the frontend\n    configuration. It receives the validated backend configuration object and\n    should return an instance of `frontend_config_class`.\n    Useful if the user wants to hide sensitive fields (e.g. API keys) from the frontend\n    or dynamically compute certain fields.\n    Required if `frontend_config_class` is set.\n    \"\"\"\n    lifespan: Lifespan | None = None\n    \"\"\"Async context manager for plugin initialization and teardown.\"\"\"\n    services: list[tuple[Priority, ServiceAsyncFunc]] = field(\n        default_factory=list, init=False\n    )\n    get_typer: Callable[[], Typer] | None = None\n    \"\"\"A function that returns the subcommands which will later be registered.\"\"\"\n    dist_name: str = field(init=False)\n    \"\"\"Name of the distribution (package) that provided this plugin, populated\n    automatically during loading.\n    \"\"\"  # we do this so plugins can know their own package name if needed\n\n    def register_service(\n        self, priority: Priority = 0\n    ) -&gt; Callable[[ServiceFunc], ServiceFunc]:\n        \"\"\"Decorator to register a background service function.\n\n        Services are long-running async functions that receive the BackendState\n        and are started when the application launches.\n        \"\"\"\n\n        def decorator(func: ServiceFunc) -&gt; ServiceFunc:\n            @functools.wraps(func)\n            async def async_wrapper(backend_state: BackendState) -&gt; None:\n                if asyncio.iscoroutinefunction(func):\n                    await func(backend_state)\n                else:\n                    await asyncio.to_thread(func, backend_state)\n\n            self.services.append((priority, async_wrapper))\n            return func\n\n        return decorator\n\n    # HACK: so lru_cache on adapter works.\n    # since we have mutable fields (routers, register_service, dist_name on init)\n    # its difficult to make this class frozen,\n    # so maybe we should implement __eq__ and __hash__ ourselves?\n    __hash__ = object.__hash__\n\n    @functools.lru_cache\n    def adapter(self) -&gt; TypeAdapter | None:\n        \"\"\"Returns a cached Pydantic TypeAdapter for the plugin's configuration class.\n\n        Avoids expensive rebuilds on every validation request, such as those from the\n        settings UI.\n        \"\"\"\n        from pydantic import TypeAdapter\n\n        if self.config_class:\n            return TypeAdapter(self.config_class)\n        return None\n\n    @functools.lru_cache\n    def frontend_adapter(self) -&gt; TypeAdapter | None:\n        \"\"\"Returns a cached Pydantic TypeAdapter for the plugin's frontend\n        configuration class.\"\"\"\n        from pydantic import TypeAdapter\n\n        if self.frontend_config_class:\n            return TypeAdapter(self.frontend_config_class)\n        return None\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin.frontend_path","title":"frontend_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frontend_path: str | None = None\n</code></pre> <p>Path to the compiled frontend assets, relative to the distribution root (editable) or package root (wheel).</p>"},{"location":"api/core/#tangram_core.Plugin.routers","title":"routers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routers: list[APIRouter] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin.config_class","title":"config_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_class: type | None = None\n</code></pre> <p>The backend configuration class (dataclass, TypedDict or Pydantic model) for the plugin.</p>"},{"location":"api/core/#tangram_core.Plugin.frontend_config_class","title":"frontend_config_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frontend_config_class: type | None = None\n</code></pre> <p>The frontend configuration class for the plugin. If set, it will be used to generate the frontend schema and validate settings updates. Fields should be annotated with tangram_core.config.FrontendMutable if they are allowed to be modified from the frontend settings UI.</p>"},{"location":"api/core/#tangram_core.Plugin.into_frontend_config_function","title":"into_frontend_config_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>into_frontend_config_function: (\n    IntoFrontendConfigFunction | None\n) = None\n</code></pre> <p>Function to transform the backend configuration into the frontend configuration. It receives the validated backend configuration object and should return an instance of <code>frontend_config_class</code>. Useful if the user wants to hide sensitive fields (e.g. API keys) from the frontend or dynamically compute certain fields. Required if <code>frontend_config_class</code> is set.</p>"},{"location":"api/core/#tangram_core.Plugin.lifespan","title":"lifespan  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lifespan: Lifespan | None = None\n</code></pre> <p>Async context manager for plugin initialization and teardown.</p>"},{"location":"api/core/#tangram_core.Plugin.services","title":"services  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>services: list[tuple[Priority, ServiceAsyncFunc]] = field(\n    default_factory=list, init=False\n)\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin.get_typer","title":"get_typer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_typer: Callable[[], Typer] | None = None\n</code></pre> <p>A function that returns the subcommands which will later be registered.</p>"},{"location":"api/core/#tangram_core.Plugin.dist_name","title":"dist_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dist_name: str = field(init=False)\n</code></pre> <p>Name of the distribution (package) that provided this plugin, populated automatically during loading.</p>"},{"location":"api/core/#tangram_core.Plugin.register_service","title":"register_service","text":"<pre><code>register_service(\n    priority: Priority = 0,\n) -&gt; Callable[[ServiceFunc], ServiceFunc]\n</code></pre> <p>Decorator to register a background service function.</p> <p>Services are long-running async functions that receive the BackendState and are started when the application launches.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>def register_service(\n    self, priority: Priority = 0\n) -&gt; Callable[[ServiceFunc], ServiceFunc]:\n    \"\"\"Decorator to register a background service function.\n\n    Services are long-running async functions that receive the BackendState\n    and are started when the application launches.\n    \"\"\"\n\n    def decorator(func: ServiceFunc) -&gt; ServiceFunc:\n        @functools.wraps(func)\n        async def async_wrapper(backend_state: BackendState) -&gt; None:\n            if asyncio.iscoroutinefunction(func):\n                await func(backend_state)\n            else:\n                await asyncio.to_thread(func, backend_state)\n\n        self.services.append((priority, async_wrapper))\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin.adapter","title":"adapter  <code>cached</code>","text":"<pre><code>adapter() -&gt; TypeAdapter | None\n</code></pre> <p>Returns a cached Pydantic TypeAdapter for the plugin's configuration class.</p> <p>Avoids expensive rebuilds on every validation request, such as those from the settings UI.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>@functools.lru_cache\ndef adapter(self) -&gt; TypeAdapter | None:\n    \"\"\"Returns a cached Pydantic TypeAdapter for the plugin's configuration class.\n\n    Avoids expensive rebuilds on every validation request, such as those from the\n    settings UI.\n    \"\"\"\n    from pydantic import TypeAdapter\n\n    if self.config_class:\n        return TypeAdapter(self.config_class)\n    return None\n</code></pre>"},{"location":"api/core/#tangram_core.Plugin.frontend_adapter","title":"frontend_adapter  <code>cached</code>","text":"<pre><code>frontend_adapter() -&gt; TypeAdapter | None\n</code></pre> <p>Returns a cached Pydantic TypeAdapter for the plugin's frontend configuration class.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>@functools.lru_cache\ndef frontend_adapter(self) -&gt; TypeAdapter | None:\n    \"\"\"Returns a cached Pydantic TypeAdapter for the plugin's frontend\n    configuration class.\"\"\"\n    from pydantic import TypeAdapter\n\n    if self.frontend_config_class:\n        return TypeAdapter(self.frontend_config_class)\n    return None\n</code></pre>"},{"location":"api/core/#tangram_core.backend","title":"backend","text":""},{"location":"api/core/#tangram_core.backend.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.InjectBackendState","title":"InjectBackendState  <code>module-attribute</code>","text":"<pre><code>InjectBackendState: TypeAlias = Annotated[\n    BackendState, Depends(get_state)\n]\n</code></pre>"},{"location":"api/core/#tangram_core.backend.CACHE_PARAM_PATTERN","title":"CACHE_PARAM_PATTERN  <code>module-attribute</code>","text":"<pre><code>CACHE_PARAM_PATTERN = compile('\\\\{(\\\\w+)\\\\}')\n</code></pre>"},{"location":"api/core/#tangram_core.backend.DEFAULT_THEMES","title":"DEFAULT_THEMES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_THEMES = (\n    ThemeDefinition(\n        name=\"light\",\n        background=\"#ffffff\",\n        foreground=\"#000000\",\n        surface=\"#f8f9fa\",\n        border=\"#e7e7e7\",\n        hover=\"#e9ecef\",\n        accent1=\"oklch(0.5616 0.0895 251.64)\",\n        accent1_foreground=\"#ffffff\",\n        accent2=\"oklch(0.8021 0.11 92.43)\",\n        accent2_foreground=\"#000000\",\n        muted=\"#666666\",\n        error=\"#8e1b27\",\n    ),\n    ThemeDefinition(\n        name=\"dark\",\n        background=\"#1a1a1a\",\n        foreground=\"#e0e0e0\",\n        surface=\"#2d2d2d\",\n        border=\"#404040\",\n        hover=\"#343434\",\n        accent1=\"oklch(0.5059 0.0895 251.64)\",\n        accent1_foreground=\"#ffffff\",\n        accent2=\"oklch(0.5059 0.0895 93.53)\",\n        accent2_foreground=\"#ffffff\",\n        muted=\"#999999\",\n        error=\"#844d53\",\n    ),\n)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState","title":"BackendState  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>@dataclass\nclass BackendState:\n    redis_client: redis.Redis\n    http_client: httpx.AsyncClient\n    config: Config\n    loaded_plugins: dict[str, Plugin] = field(default_factory=dict)\n\n    @property\n    def base_url(self) -&gt; str:\n        host = self.config.server.host\n        port = self.config.server.port\n        if host == \"0.0.0.0\":\n            host = \"127.0.0.1\"\n        return f\"http://{host}:{port}\"\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState.redis_client","title":"redis_client  <code>instance-attribute</code>","text":"<pre><code>redis_client: Redis\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState.http_client","title":"http_client  <code>instance-attribute</code>","text":"<pre><code>http_client: AsyncClient\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: Config\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState.loaded_plugins","title":"loaded_plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loaded_plugins: dict[str, Plugin] = field(\n    default_factory=dict\n)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.BackendState.base_url","title":"base_url  <code>property</code>","text":"<pre><code>base_url: str\n</code></pre>"},{"location":"api/core/#tangram_core.backend.Runtime","title":"Runtime","text":"<p>Manages the lifecycle of the Tangram backend, including the Uvicorn server, background services, and connection pools (Redis, HTTPX).</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>class Runtime:\n    \"\"\"Manages the lifecycle of the Tangram backend, including the\n    Uvicorn server, background services, and connection pools (Redis, HTTPX).\n    \"\"\"\n\n    def __init__(self, config: IntoConfig | None = None) -&gt; None:\n        if isinstance(config, (str, Path, os.PathLike)):\n            self.config = Config.from_file(config)\n        else:\n            self.config = config or Config()\n        self._stack = AsyncExitStack()\n        self._state: BackendState | None = None\n        self._server: uvicorn.Server | None = None\n        self._server_task: asyncio.Task[None] | None = None\n        self._service_tasks: list[asyncio.Task[None]] = []\n\n    @property\n    def state(self) -&gt; BackendState:\n        if self._state is None:\n            raise RuntimeError(\"runtime is not started, call start() first\")\n        return self._state\n\n    async def start(self) -&gt; Runtime:\n        \"\"\"Starts the backend runtime.\"\"\"\n        if self._state is not None:\n            raise RuntimeError(\"runtime is already started\")\n\n        redis_client = await self._stack.enter_async_context(\n            redis.from_url(self.config.core.redis_url)  # type: ignore\n        )\n        http_client = await self._stack.enter_async_context(\n            httpx.AsyncClient(http2=True)\n        )\n        self._state = BackendState(\n            redis_client=redis_client,\n            http_client=http_client,\n            config=self.config,\n        )\n\n        loaded_plugins = load_enabled_plugins(self.config)\n        app = create_app(self._state, loaded_plugins)\n\n        server_config = uvicorn.Config(\n            app,\n            host=self.config.server.host,\n            port=self.config.server.port,\n            log_config=get_log_config_dict(self.config),\n        )\n        self._server = uvicorn.Server(server_config)\n\n        self._service_tasks.append(\n            asyncio.create_task(run_channel_service(self.config))\n        )\n        for plugin in loaded_plugins:\n            for _, service_func in sorted(\n                plugin.services, key=lambda s: (s[0], s[1].__name__)\n            ):\n                self._service_tasks.append(\n                    asyncio.create_task(service_func(self._state))\n                )\n                logger.info(f\"started service from plugin: {plugin.dist_name}\")\n\n        self._server_task = asyncio.create_task(self._server.serve())\n\n        while not self._server.started:\n            if self._server_task.done():\n                await self._server_task\n            await asyncio.sleep(0.1)\n\n        return self\n\n    async def wait(self) -&gt; None:\n        \"\"\"Waits for the server task to complete (e.g. via signal or internal error).\"\"\"\n        if self._server_task:\n            try:\n                await self._server_task\n            except asyncio.CancelledError:\n                pass\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stops the backend runtime.\"\"\"\n        if self._server and self._server.started:\n            self._server.should_exit = True\n            if self._server_task:\n                try:\n                    await self._server_task\n                except asyncio.CancelledError:\n                    pass\n\n        for task in self._service_tasks:\n            task.cancel()\n        if self._service_tasks:\n            await asyncio.gather(*self._service_tasks, return_exceptions=True)\n        self._service_tasks.clear()\n\n        await self._stack.aclose()\n        self._state = None\n        self._server = None\n        self._server_task = None\n\n    async def __aenter__(self) -&gt; Runtime:\n        return await self.start()\n\n    async def __aexit__(self, *args: Any) -&gt; None:\n        await self.stop()\n</code></pre>"},{"location":"api/core/#tangram_core.backend.Runtime.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = from_file(config)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.Runtime.state","title":"state  <code>property</code>","text":"<pre><code>state: BackendState\n</code></pre>"},{"location":"api/core/#tangram_core.backend.Runtime.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; Runtime\n</code></pre> <p>Starts the backend runtime.</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def start(self) -&gt; Runtime:\n    \"\"\"Starts the backend runtime.\"\"\"\n    if self._state is not None:\n        raise RuntimeError(\"runtime is already started\")\n\n    redis_client = await self._stack.enter_async_context(\n        redis.from_url(self.config.core.redis_url)  # type: ignore\n    )\n    http_client = await self._stack.enter_async_context(\n        httpx.AsyncClient(http2=True)\n    )\n    self._state = BackendState(\n        redis_client=redis_client,\n        http_client=http_client,\n        config=self.config,\n    )\n\n    loaded_plugins = load_enabled_plugins(self.config)\n    app = create_app(self._state, loaded_plugins)\n\n    server_config = uvicorn.Config(\n        app,\n        host=self.config.server.host,\n        port=self.config.server.port,\n        log_config=get_log_config_dict(self.config),\n    )\n    self._server = uvicorn.Server(server_config)\n\n    self._service_tasks.append(\n        asyncio.create_task(run_channel_service(self.config))\n    )\n    for plugin in loaded_plugins:\n        for _, service_func in sorted(\n            plugin.services, key=lambda s: (s[0], s[1].__name__)\n        ):\n            self._service_tasks.append(\n                asyncio.create_task(service_func(self._state))\n            )\n            logger.info(f\"started service from plugin: {plugin.dist_name}\")\n\n    self._server_task = asyncio.create_task(self._server.serve())\n\n    while not self._server.started:\n        if self._server_task.done():\n            await self._server_task\n        await asyncio.sleep(0.1)\n\n    return self\n</code></pre>"},{"location":"api/core/#tangram_core.backend.Runtime.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Waits for the server task to complete (e.g. via signal or internal error).</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Waits for the server task to complete (e.g. via signal or internal error).\"\"\"\n    if self._server_task:\n        try:\n            await self._server_task\n        except asyncio.CancelledError:\n            pass\n</code></pre>"},{"location":"api/core/#tangram_core.backend.Runtime.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stops the backend runtime.</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stops the backend runtime.\"\"\"\n    if self._server and self._server.started:\n        self._server.should_exit = True\n        if self._server_task:\n            try:\n                await self._server_task\n            except asyncio.CancelledError:\n                pass\n\n    for task in self._service_tasks:\n        task.cancel()\n    if self._service_tasks:\n        await asyncio.gather(*self._service_tasks, return_exceptions=True)\n    self._service_tasks.clear()\n\n    await self._stack.aclose()\n    self._state = None\n    self._server = None\n    self._server_task = None\n</code></pre>"},{"location":"api/core/#tangram_core.backend.get_state","title":"get_state  <code>async</code>","text":"<pre><code>get_state(request: Request) -&gt; BackendState\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def get_state(request: Request) -&gt; BackendState:\n    return request.app.state.backend_state  # type: ignore\n</code></pre>"},{"location":"api/core/#tangram_core.backend.get_distribution_path","title":"get_distribution_path","text":"<pre><code>get_distribution_path(dist_name: str) -&gt; Path\n</code></pre> <p>Get the local path of a distribution, handling both editable installs (<code>direct_url.json</code>) and standard wheel installs.</p> <p>See: https://packaging.python.org/en/latest/specifications/direct-url-data-structure/</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def get_distribution_path(dist_name: str) -&gt; Path:\n    \"\"\"Get the local path of a distribution, handling both editable installs\n    (`direct_url.json`) and standard wheel installs.\n\n    See: https://packaging.python.org/en/latest/specifications/direct-url-data-structure/\n    \"\"\"\n    # always try direct_url.json first (e.g. for the case of `uv sync --all-packages`)\n    try:\n        dist = Distribution.from_name(dist_name)\n        if direct_url_content := dist.read_text(\"direct_url.json\"):\n            direct_url_data = json.loads(direct_url_content)\n            if (\n                (url := direct_url_data.get(\"url\"))\n                # url may point to a git or zip archive, but since we only care\n                # about local paths, we only handle the file:// scheme here\n                and url.startswith(\"file://\")\n            ):\n                parsed = urllib.parse.urlparse(url)\n                if os.name == \"nt\":\n                    path_str = urllib.request.url2pathname(parsed.path)\n                    if parsed.netloc and parsed.netloc not in (\"\", \"localhost\"):\n                        path_str = f\"//{parsed.netloc}{path_str}\"\n                    path1 = Path(path_str)\n                else:\n                    path1 = Path(urllib.parse.unquote(parsed.path))\n                if path1.is_dir():\n                    return path1\n    except (PackageNotFoundError, json.JSONDecodeError, FileNotFoundError):\n        pass\n\n    # fallback in case it was installed via a wheel\n    if (trav := importlib.resources.files(dist_name)).is_dir():\n        with importlib.resources.as_file(trav) as path2:\n            return path2\n    raise FileNotFoundError(f\"could not find distribution path for {dist_name}\")\n</code></pre>"},{"location":"api/core/#tangram_core.backend.resolve_frontend","title":"resolve_frontend","text":"<pre><code>resolve_frontend(plugin: Plugin) -&gt; Path | None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def resolve_frontend(plugin: Plugin) -&gt; Path | None:\n    if not plugin.frontend_path:\n        return None\n    return get_distribution_path(plugin.dist_name) / plugin.frontend_path\n</code></pre>"},{"location":"api/core/#tangram_core.backend.load_enabled_plugins","title":"load_enabled_plugins","text":"<pre><code>load_enabled_plugins(config: Config) -&gt; list[Plugin]\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def load_enabled_plugins(\n    config: Config,\n) -&gt; list[Plugin]:\n    loaded_plugins = []\n    enabled_plugin_names = set(config.core.plugins)\n\n    for entry_point in scan_plugins():\n        # TODO: should we check entry_point.dist.name instead?\n        if entry_point.name not in enabled_plugin_names:\n            continue\n        if (plugin := load_plugin(entry_point)) is not None:\n            loaded_plugins.append(plugin)\n\n    return loaded_plugins\n</code></pre>"},{"location":"api/core/#tangram_core.backend.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(\n    app: FastAPI,\n    backend_state: BackendState,\n    loaded_plugins: Iterable[Plugin],\n) -&gt; AsyncGenerator[None, None]\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(\n    app: FastAPI, backend_state: BackendState, loaded_plugins: Iterable[Plugin]\n) -&gt; AsyncGenerator[None, None]:\n    async with AsyncExitStack() as stack:\n        for plugin in loaded_plugins:\n            if plugin.lifespan:\n                logger.info(f\"initializing lifespan for {plugin.dist_name}\")\n                await stack.enter_async_context(plugin.lifespan(backend_state))\n\n        app.state.backend_state = backend_state\n        yield\n</code></pre>"},{"location":"api/core/#tangram_core.backend.default_cache_dir","title":"default_cache_dir","text":"<pre><code>default_cache_dir() -&gt; Path\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def default_cache_dir() -&gt; Path:\n    if (xdg_cache := os.environ.get(\"XDG_CACHE_HOME\")) is not None:\n        cache_dir = Path(xdg_cache) / \"tangram\"\n    else:\n        cache_dir = Path(platformdirs.user_cache_dir(appname=\"tangram\"))\n    if not cache_dir.exists():\n        cache_dir.mkdir(parents=True, exist_ok=True)\n\n    return cache_dir\n</code></pre>"},{"location":"api/core/#tangram_core.backend.make_cache_route_handler","title":"make_cache_route_handler","text":"<pre><code>make_cache_route_handler(\n    entry: CacheEntry, state: BackendState\n) -&gt; Callable[..., Awaitable[FileResponse]]\n</code></pre> <p>Factory function that creates a route handler for caching and serving files. Dynamically handles URL parameters found in both serve_route and origin.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>CacheEntry</code> <p>Cache entry configuration</p> required <code>state</code> <code>BackendState</code> <p>Backend state with http_client for fetching remote resources</p> required <p>Returns:</p> Type Description <code>Callable[..., Awaitable[FileResponse]]</code> <p>Async function that handles the route with dynamic parameters</p> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def make_cache_route_handler(\n    entry: CacheEntry, state: BackendState\n) -&gt; Callable[..., Awaitable[FileResponse]]:\n    \"\"\"\n    Factory function that creates a route handler for caching and serving files.\n    Dynamically handles URL parameters found in both serve_route and origin.\n\n    :param entry: Cache entry configuration\n    :param state: Backend state with http_client for fetching remote resources\n    :returns: Async function that handles the route with dynamic parameters\n    \"\"\"\n    from inspect import Parameter, Signature\n\n    # Extract parameter names from the serve_route (e.g., {fontstack}, {range})\n    params = CACHE_PARAM_PATTERN.findall(entry.serve_route)\n\n    async def cache_route_handler(**kwargs: str) -&gt; FileResponse:\n        if (local_path := entry.local_path) is None:\n            local_path = default_cache_dir()\n        else:\n            local_path = local_path.expanduser()\n\n        # Build the local file path by replacing parameters\n        local_file = local_path\n        for param in params:\n            if param in kwargs:\n                local_file = local_file / kwargs[param]\n\n        logger.info(f\"Serving cached file from {local_file}\")\n\n        if not local_file.exists():\n            assert entry.origin is not None\n            # Build the remote URL by replacing parameters\n            remote_url = entry.origin\n            for param, value in kwargs.items():\n                remote_url = remote_url.replace(f\"{{{param}}}\", value)\n\n            logger.info(f\"Downloading from {remote_url} to {local_file}\")\n            c = await state.http_client.get(remote_url)\n            c.raise_for_status()\n            local_file.parent.mkdir(parents=True, exist_ok=True)\n            local_file.write_bytes(c.content)\n\n        return FileResponse(path=local_file, media_type=entry.media_type)\n\n    # Create explicit parameters for the function signature\n    sig_params = [\n        Parameter(\n            name=param,\n            kind=Parameter.POSITIONAL_OR_KEYWORD,\n            annotation=str,\n        )\n        for param in params\n    ]\n    cache_route_handler.__signature__ = Signature(  # type: ignore\n        parameters=sig_params,\n        return_annotation=FileResponse,\n    )\n\n    return cache_route_handler\n</code></pre>"},{"location":"api/core/#tangram_core.backend.core_into_frontend_config","title":"core_into_frontend_config","text":"<pre><code>core_into_frontend_config(config: Config) -&gt; FrontendConfig\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def core_into_frontend_config(config: Config) -&gt; FrontendConfig:\n    if config.channel.public_url:\n        channel_url = config.channel.public_url\n    else:\n        host = \"localhost\" if config.channel.host == \"0.0.0.0\" else config.channel.host\n        channel_url = f\"http://{host}:{config.channel.port}\"\n    frontend_channel = FrontendChannelConfig(url=channel_url)\n\n    user_theme_names = {t.name for t in config.core.themes}\n    merged_themes = [\n        t for t in DEFAULT_THEMES if t.name not in user_theme_names\n    ] + config.core.themes\n\n    frontend_core = FrontendCoreConfig(theme=config.core.theme, themes=merged_themes)\n\n    return FrontendConfig(core=frontend_core, map=config.map, channel=frontend_channel)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.create_app","title":"create_app","text":"<pre><code>create_app(\n    backend_state: BackendState,\n    loaded_plugins: Iterable[Plugin],\n) -&gt; FastAPI\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def create_app(\n    backend_state: BackendState,\n    loaded_plugins: Iterable[Plugin],\n) -&gt; FastAPI:\n    app = FastAPI(\n        lifespan=partial(\n            lifespan, backend_state=backend_state, loaded_plugins=loaded_plugins\n        ),\n        default_response_class=ORJSONResponse,\n    )\n\n    frontend_config_instance = core_into_frontend_config(backend_state.config)\n    frontend_adapter = TypeAdapter(FrontendConfig)\n    manifest_core = to_frontend_manifest(frontend_adapter, frontend_config_instance)\n\n    manifest_plugins = {}\n    for plugin in loaded_plugins:\n        backend_state.loaded_plugins[plugin.dist_name] = plugin\n        for router in plugin.routers:\n            app.include_router(router)\n\n        if (frontend_path_resolved := resolve_frontend(plugin)) is None:\n            continue\n        app.mount(\n            f\"/plugins/{plugin.dist_name}\",\n            StaticFiles(directory=str(frontend_path_resolved)),\n            name=plugin.dist_name,\n        )\n        if not (plugin_json_path := frontend_path_resolved / \"plugin.json\").exists():\n            continue\n        with plugin_json_path.open(\"rb\") as f:\n            plugin_meta = json.load(f)\n\n        manifest_plugins[plugin.dist_name] = plugin_meta\n\n        # NOTE: on the js side the `config` and `config_json_schema` keys\n        # may be missing if the plugin does not configure them properly\n        conf_dict = backend_state.config.plugins.get(plugin.dist_name, {})\n        if (backend_adapter := plugin.adapter()) is None:\n            continue\n        conf_instance = backend_adapter.validate_python(conf_dict)\n        if not plugin.frontend_config_class:\n            continue\n        if plugin.into_frontend_config_function is None:\n            logger.warning(\n                f\"expected `into_frontend_config_function` for\"\n                f\" plugin {plugin.dist_name} but it is None. \"\n                \"Frontend config will be empty!\"\n            )\n            continue\n        frontend_instance = plugin.into_frontend_config_function(conf_instance)\n        frontend_adapter_ = plugin.frontend_adapter()\n        assert frontend_adapter_ is not None\n        frontend_manifest = to_frontend_manifest(frontend_adapter_, frontend_instance)\n        manifest_plugins[plugin.dist_name] = {\n            **plugin_meta,\n            **frontend_manifest,\n        }\n\n    @app.post(\"/settings/validate/{plugin_name}\")\n    async def validate_settings(\n        plugin_name: str,\n        data: dict,\n        state: Annotated[BackendState, Depends(get_state)],\n    ) -&gt; dict:\n        SUCCESS = {\"success\": True, \"errors\": {}}\n        try:\n            if plugin_name == \"tangram_core\":\n                _ = parse_frontend_config(frontend_adapter, data)\n                return SUCCESS\n            plugin = state.loaded_plugins.get(plugin_name)\n            assert plugin is not None, f\"plugin {plugin_name} not found\"\n\n            if plugin.frontend_config_class:\n                if (frontend_adapter_ := plugin.frontend_adapter()) is not None:\n                    frontend_adapter_.validate_python(data)\n                return SUCCESS\n\n            # if no frontend config defined, validation always succeeds because\n            # nothing to validate against\n            return SUCCESS\n        except ValidationError as e:\n            errs = {\n                \".\".join(str(loc) for loc in err[\"loc\"]): err[\"msg\"]\n                for err in e.errors()\n            }\n            return {\"success\": False, \"errors\": errs}\n\n    @app.get(\"/manifest.json\")\n    async def get_manifest() -&gt; ORJSONResponse:\n        return ORJSONResponse(\n            content={\"core\": manifest_core, \"plugins\": manifest_plugins}\n        )\n\n    # Cache mechanism - MUST be registered BEFORE the catch-all frontend mount\n    for cache_entry in backend_state.config.cache.entries:\n        logger.info(\n            f\"caching {cache_entry.origin} to {cache_entry.local_path} \"\n            f\"and serving at {cache_entry.serve_route}\"\n        )\n        route_handler = make_cache_route_handler(cache_entry, backend_state)\n\n        logger.info(\n            f\"Registering route: GET {cache_entry.serve_route} with dynamic params\"\n        )\n        app.add_api_route(\n            cache_entry.serve_route,\n            route_handler,\n            methods=[\"GET\"],\n            name=f\"cache-{cache_entry.serve_route.replace('/', '_')}\",\n        )\n\n    if not (\n        frontend_path := get_distribution_path(\"tangram_core\") / \"dist-frontend\"\n    ).is_dir():\n        raise ValueError(\n            f\"error: frontend {frontend_path} was not found, \"\n            \"did you run `pnpm i &amp;&amp; pnpm run build`?\"\n        )\n    app.mount(\"/\", StaticFiles(directory=str(frontend_path), html=True), name=\"core\")\n\n    return app\n</code></pre>"},{"location":"api/core/#tangram_core.backend.run_channel_service","title":"run_channel_service  <code>async</code>","text":"<pre><code>run_channel_service(config: Config) -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>async def run_channel_service(config: Config) -&gt; None:\n    from . import _core\n\n    _core.init_tracing_stderr(config.core.log_level)\n\n    rust_config = _core.ChannelConfig(\n        host=config.channel.host,\n        port=config.channel.port,\n        redis_url=config.core.redis_url,\n        jwt_secret=config.channel.jwt_secret,\n        jwt_expiration_secs=config.channel.jwt_expiration_secs,\n        id_length=config.channel.id_length,\n    )\n    await _core.run(rust_config)\n</code></pre>"},{"location":"api/core/#tangram_core.backend.get_log_config_dict","title":"get_log_config_dict","text":"<pre><code>get_log_config_dict(config: Config) -&gt; dict[str, Any]\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/backend.py</code> <pre><code>def get_log_config_dict(config: Config) -&gt; dict[str, Any]:\n    def format_time(dt: datetime) -&gt; str:\n        return dt.astimezone(timezone.utc).strftime(\"%Y-%m-%dT%H:%M:%S.%fZ \")\n\n    return {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"handlers\": {\n            \"default\": {\n                \"class\": \"rich.logging.RichHandler\",\n                \"log_time_format\": format_time,\n                \"omit_repeated_times\": False,\n            },\n        },\n        \"root\": {\"handlers\": [\"default\"], \"level\": config.core.log_level.upper()},\n    }\n</code></pre>"},{"location":"api/core/#tangram_core.config","title":"config","text":""},{"location":"api/core/#tangram_core.config.StyleName","title":"StyleName  <code>module-attribute</code>","text":"<pre><code>StyleName: TypeAlias = str\n</code></pre>"},{"location":"api/core/#tangram_core.config.Url","title":"Url  <code>module-attribute</code>","text":"<pre><code>Url: TypeAlias = str\n</code></pre>"},{"location":"api/core/#tangram_core.config.StrOrPathLike","title":"StrOrPathLike  <code>module-attribute</code>","text":"<pre><code>StrOrPathLike = str | PathLike[str]\n</code></pre>"},{"location":"api/core/#tangram_core.config.IntoConfig","title":"IntoConfig  <code>module-attribute</code>","text":"<pre><code>IntoConfig: TypeAlias = 'Config | StrOrPathLike'\n</code></pre>"},{"location":"api/core/#tangram_core.config.HasTopbarUiConfig","title":"HasTopbarUiConfig","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@runtime_checkable\nclass HasTopbarUiConfig(Protocol):\n    topbar_order: int\n</code></pre>"},{"location":"api/core/#tangram_core.config.HasTopbarUiConfig.topbar_order","title":"topbar_order  <code>instance-attribute</code>","text":"<pre><code>topbar_order: int\n</code></pre>"},{"location":"api/core/#tangram_core.config.HasSidebarUiConfig","title":"HasSidebarUiConfig","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@runtime_checkable\nclass HasSidebarUiConfig(Protocol):\n    sidebar_order: int\n</code></pre>"},{"location":"api/core/#tangram_core.config.HasSidebarUiConfig.sidebar_order","title":"sidebar_order  <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int\n</code></pre>"},{"location":"api/core/#tangram_core.config.ServerConfig","title":"ServerConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass ServerConfig:\n    host: str = \"127.0.0.1\"\n    port: int = 2346\n</code></pre>"},{"location":"api/core/#tangram_core.config.ServerConfig.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host: str = '127.0.0.1'\n</code></pre>"},{"location":"api/core/#tangram_core.config.ServerConfig.port","title":"port  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port: int = 2346\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig","title":"ChannelConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass ChannelConfig:\n    # TODO: we should make it clear that host:port is for the *backend* to\n    # listen on, and not to be confused with the frontend.\n    host: str = \"127.0.0.1\"\n    port: int = 2347\n    public_url: str | None = None\n    jwt_secret: str = \"secret\"\n    jwt_expiration_secs: int = 315360000  # 10 years\n    id_length: int = 8\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host: str = '127.0.0.1'\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.port","title":"port  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port: int = 2347\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.public_url","title":"public_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>public_url: str | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.jwt_secret","title":"jwt_secret  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jwt_secret: str = 'secret'\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.jwt_expiration_secs","title":"jwt_expiration_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jwt_expiration_secs: int = 315360000\n</code></pre>"},{"location":"api/core/#tangram_core.config.ChannelConfig.id_length","title":"id_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id_length: int = 8\n</code></pre>"},{"location":"api/core/#tangram_core.config.UrlConfig","title":"UrlConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass UrlConfig:\n    url: str\n    type: str = \"vector\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.UrlConfig.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"api/core/#tangram_core.config.UrlConfig.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: str = 'vector'\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification","title":"StyleSpecification  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass StyleSpecification:\n    name: StyleName | None = None\n    sources: dict[str, UrlConfig] | None = None\n    glyphs: str = \"https://cdn.protomaps.com/fonts/pbf/{fontstack}/{range}.pbf\"\n    layers: list[Any] | None = None\n    version: int = 8\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: StyleName | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.sources","title":"sources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sources: dict[str, UrlConfig] | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.glyphs","title":"glyphs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>glyphs: str = \"https://cdn.protomaps.com/fonts/pbf/{fontstack}/{range}.pbf\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.layers","title":"layers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layers: list[Any] | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.StyleSpecification.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: int = 8\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig","title":"MapConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass MapConfig:\n    # users can specify local path in config file but it will be resolved in from_file\n    # and so the stored type cannot be Path\n    style: Annotated[\n        Url | StyleName | StyleSpecification, FrontendMutable(widget=\"map-settings\")\n    ] = \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\"\n    styles: Annotated[\n        list[Url | StyleSpecification], FrontendMutable(widget=\"map-settings\")\n    ] = field(default_factory=default_styles)\n    center_lat: Annotated[float, Ge(-90), Le(90), FrontendMutable()] = 48.0\n    center_lon: Annotated[float, Ge(-180), Le(180), FrontendMutable()] = 7.0\n    zoom: Annotated[float, Ge(0), Le(24), FrontendMutable()] = 4\n    pitch: Annotated[float, Ge(0), Le(85), FrontendMutable()] = 0\n    bearing: Annotated[float, Ge(-180), Le(180), FrontendMutable()] = 0\n    lang: Annotated[str, FrontendMutable()] = \"en\"\n    min_zoom: Annotated[float, Ge(0), Le(24), FrontendMutable()] = 0\n    max_zoom: Annotated[float, Ge(0), Le(24), FrontendMutable()] = 24\n    max_pitch: Annotated[float, Ge(0), Le(85), FrontendMutable()] = 70\n    allow_pitch: Annotated[bool, FrontendMutable()] = True\n    allow_bearing: Annotated[bool, FrontendMutable()] = True\n    layers_visibility: Annotated[\n        dict[str, bool] | None, FrontendMutable(widget=\"map-settings\")\n    ] = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.style","title":"style  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>style: Annotated[\n    Url | StyleName | StyleSpecification,\n    FrontendMutable(widget=\"map-settings\"),\n] = \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.styles","title":"styles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>styles: Annotated[\n    list[Url | StyleSpecification],\n    FrontendMutable(widget=\"map-settings\"),\n] = field(default_factory=default_styles)\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.center_lat","title":"center_lat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>center_lat: Annotated[\n    float, Ge(-90), Le(90), FrontendMutable()\n] = 48.0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.center_lon","title":"center_lon  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>center_lon: Annotated[\n    float, Ge(-180), Le(180), FrontendMutable()\n] = 7.0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.zoom","title":"zoom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zoom: Annotated[float, Ge(0), Le(24), FrontendMutable()] = 4\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.pitch","title":"pitch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pitch: Annotated[\n    float, Ge(0), Le(85), FrontendMutable()\n] = 0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.bearing","title":"bearing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bearing: Annotated[\n    float, Ge(-180), Le(180), FrontendMutable()\n] = 0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.lang","title":"lang  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lang: Annotated[str, FrontendMutable()] = 'en'\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.min_zoom","title":"min_zoom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_zoom: Annotated[\n    float, Ge(0), Le(24), FrontendMutable()\n] = 0\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.max_zoom","title":"max_zoom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_zoom: Annotated[\n    float, Ge(0), Le(24), FrontendMutable()\n] = 24\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.max_pitch","title":"max_pitch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_pitch: Annotated[\n    float, Ge(0), Le(85), FrontendMutable()\n] = 70\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.allow_pitch","title":"allow_pitch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_pitch: Annotated[bool, FrontendMutable()] = True\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.allow_bearing","title":"allow_bearing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_bearing: Annotated[bool, FrontendMutable()] = True\n</code></pre>"},{"location":"api/core/#tangram_core.config.MapConfig.layers_visibility","title":"layers_visibility  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layers_visibility: Annotated[\n    dict[str, bool] | None,\n    FrontendMutable(widget=\"map-settings\"),\n] = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition","title":"ThemeDefinition  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass ThemeDefinition:\n    name: str\n    background: Annotated[str, FrontendMutable(kind=\"color\")]\n    foreground: Annotated[str, FrontendMutable(kind=\"color\")]\n    surface: Annotated[str, FrontendMutable(kind=\"color\")]\n    border: Annotated[str, FrontendMutable(kind=\"color\")]\n    hover: Annotated[str, FrontendMutable(kind=\"color\")]\n    accent1: Annotated[str, FrontendMutable(kind=\"color\")]\n    accent1_foreground: Annotated[str, FrontendMutable(kind=\"color\")]\n    accent2: Annotated[str, FrontendMutable(kind=\"color\")]\n    accent2_foreground: Annotated[str, FrontendMutable(kind=\"color\")]\n    muted: Annotated[str, FrontendMutable(kind=\"color\")]\n    error: Annotated[str, FrontendMutable(kind=\"color\")]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.background","title":"background  <code>instance-attribute</code>","text":"<pre><code>background: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.foreground","title":"foreground  <code>instance-attribute</code>","text":"<pre><code>foreground: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.surface","title":"surface  <code>instance-attribute</code>","text":"<pre><code>surface: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.border","title":"border  <code>instance-attribute</code>","text":"<pre><code>border: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.hover","title":"hover  <code>instance-attribute</code>","text":"<pre><code>hover: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.accent1","title":"accent1  <code>instance-attribute</code>","text":"<pre><code>accent1: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.accent1_foreground","title":"accent1_foreground  <code>instance-attribute</code>","text":"<pre><code>accent1_foreground: Annotated[\n    str, FrontendMutable(kind=\"color\")\n]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.accent2","title":"accent2  <code>instance-attribute</code>","text":"<pre><code>accent2: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.accent2_foreground","title":"accent2_foreground  <code>instance-attribute</code>","text":"<pre><code>accent2_foreground: Annotated[\n    str, FrontendMutable(kind=\"color\")\n]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.muted","title":"muted  <code>instance-attribute</code>","text":"<pre><code>muted: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.ThemeDefinition.error","title":"error  <code>instance-attribute</code>","text":"<pre><code>error: Annotated[str, FrontendMutable(kind='color')]\n</code></pre>"},{"location":"api/core/#tangram_core.config.AdaptiveTheme","title":"AdaptiveTheme  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass AdaptiveTheme:\n    light: Annotated[str, FrontendMutable()] = \"light\"\n    dark: Annotated[str, FrontendMutable()] = \"dark\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.AdaptiveTheme.light","title":"light  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>light: Annotated[str, FrontendMutable()] = 'light'\n</code></pre>"},{"location":"api/core/#tangram_core.config.AdaptiveTheme.dark","title":"dark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dark: Annotated[str, FrontendMutable()] = 'dark'\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig","title":"CoreConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass CoreConfig:\n    redis_url: str = \"redis://127.0.0.1:6379\"\n    plugins: list[str] = field(default_factory=list)\n    log_level: str = \"INFO\"\n    theme: Annotated[str | AdaptiveTheme, FrontendMutable(widget=\"theme-settings\")] = (\n        field(default_factory=AdaptiveTheme)\n    )\n    themes: Annotated[\n        list[ThemeDefinition], FrontendMutable(widget=\"theme-settings\")\n    ] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig.redis_url","title":"redis_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis_url: str = 'redis://127.0.0.1:6379'\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plugins: list[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level: str = 'INFO'\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig.theme","title":"theme  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theme: Annotated[\n    str | AdaptiveTheme,\n    FrontendMutable(widget=\"theme-settings\"),\n] = field(default_factory=AdaptiveTheme)\n</code></pre>"},{"location":"api/core/#tangram_core.config.CoreConfig.themes","title":"themes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>themes: Annotated[\n    list[ThemeDefinition],\n    FrontendMutable(widget=\"theme-settings\"),\n] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.CacheEntry","title":"CacheEntry  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass CacheEntry:\n    origin: str | None = None\n    \"\"\"Origin URL. If None, the local file is served directly.\"\"\"\n    local_path: Path | None = None\n    \"\"\"Local path to cache the file.\"\"\"\n    serve_route: str = \"\"\n    \"\"\"Where to serve the file in FastAPI.\"\"\"\n    media_type: str = \"application/octet-stream\"\n    \"\"\"Media type for the response.\"\"\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.CacheEntry.origin","title":"origin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>origin: str | None = None\n</code></pre> <p>Origin URL. If None, the local file is served directly.</p>"},{"location":"api/core/#tangram_core.config.CacheEntry.local_path","title":"local_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_path: Path | None = None\n</code></pre> <p>Local path to cache the file.</p>"},{"location":"api/core/#tangram_core.config.CacheEntry.serve_route","title":"serve_route  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serve_route: str = ''\n</code></pre> <p>Where to serve the file in FastAPI.</p>"},{"location":"api/core/#tangram_core.config.CacheEntry.media_type","title":"media_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>media_type: str = 'application/octet-stream'\n</code></pre> <p>Media type for the response.</p>"},{"location":"api/core/#tangram_core.config.CacheConfig","title":"CacheConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass CacheConfig:\n    entries: list[CacheEntry] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.CacheConfig.entries","title":"entries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entries: list[CacheEntry] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config","title":"Config  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass Config:\n    core: CoreConfig = field(default_factory=CoreConfig)\n    server: ServerConfig = field(default_factory=ServerConfig)\n    channel: ChannelConfig = field(default_factory=ChannelConfig)\n    map: MapConfig = field(default_factory=MapConfig)\n    plugins: dict[str, Any] = field(default_factory=dict)\n    \"\"\"Mapping of plugin name to plugin-specific config.\"\"\"\n    cache: CacheConfig = field(default_factory=CacheConfig)\n\n    @classmethod\n    def from_file(cls, config_path: StrOrPathLike) -&gt; Config:\n        if sys.version_info &lt; (3, 11):\n            import tomli as tomllib\n        else:\n            import tomllib\n        from pydantic import TypeAdapter\n\n        with open(config_path, \"rb\") as f:\n            cfg_data = tomllib.load(f)\n\n        base_dir = Path(config_path).parent\n        map = cfg_data.setdefault(\"map\", {})\n        if (s := map.get(\"style\", None)) is not None:\n            map[\"style\"] = try_resolve_local_style(base_dir, s, allow_style_name=True)\n\n        map[\"styles\"] = [\n            try_resolve_local_style(base_dir, style, allow_style_name=False)\n            for style in map.get(\"styles\", []) or default_styles()\n        ]\n\n        config_adapter = TypeAdapter(cls)\n        config = config_adapter.validate_python(cfg_data)\n        return config\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.core","title":"core  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>core: CoreConfig = field(default_factory=CoreConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.server","title":"server  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>server: ServerConfig = field(default_factory=ServerConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.channel","title":"channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>channel: ChannelConfig = field(\n    default_factory=ChannelConfig\n)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.map","title":"map  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>map: MapConfig = field(default_factory=MapConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.plugins","title":"plugins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plugins: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>Mapping of plugin name to plugin-specific config.</p>"},{"location":"api/core/#tangram_core.config.Config.cache","title":"cache  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache: CacheConfig = field(default_factory=CacheConfig)\n</code></pre>"},{"location":"api/core/#tangram_core.config.Config.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(config_path: StrOrPathLike) -&gt; Config\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: StrOrPathLike) -&gt; Config:\n    if sys.version_info &lt; (3, 11):\n        import tomli as tomllib\n    else:\n        import tomllib\n    from pydantic import TypeAdapter\n\n    with open(config_path, \"rb\") as f:\n        cfg_data = tomllib.load(f)\n\n    base_dir = Path(config_path).parent\n    map = cfg_data.setdefault(\"map\", {})\n    if (s := map.get(\"style\", None)) is not None:\n        map[\"style\"] = try_resolve_local_style(base_dir, s, allow_style_name=True)\n\n    map[\"styles\"] = [\n        try_resolve_local_style(base_dir, style, allow_style_name=False)\n        for style in map.get(\"styles\", []) or default_styles()\n    ]\n\n    config_adapter = TypeAdapter(cls)\n    config = config_adapter.validate_python(cfg_data)\n    return config\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendCoreConfig","title":"FrontendCoreConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass FrontendCoreConfig:\n    theme: Annotated[str | AdaptiveTheme, FrontendMutable(widget=\"theme-settings\")] = (\n        field(default_factory=AdaptiveTheme)\n    )\n    themes: Annotated[\n        list[ThemeDefinition], FrontendMutable(widget=\"theme-settings\")\n    ] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendCoreConfig.theme","title":"theme  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theme: Annotated[\n    str | AdaptiveTheme,\n    FrontendMutable(widget=\"theme-settings\"),\n] = field(default_factory=AdaptiveTheme)\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendCoreConfig.themes","title":"themes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>themes: Annotated[\n    list[ThemeDefinition],\n    FrontendMutable(widget=\"theme-settings\"),\n] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendChannelConfig","title":"FrontendChannelConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass FrontendChannelConfig:\n    url: str\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendChannelConfig.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendConfig","title":"FrontendConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass\nclass FrontendConfig:\n    core: FrontendCoreConfig\n    map: MapConfig\n    channel: FrontendChannelConfig\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendConfig.core","title":"core  <code>instance-attribute</code>","text":"<pre><code>core: FrontendCoreConfig\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendConfig.map","title":"map  <code>instance-attribute</code>","text":"<pre><code>map: MapConfig\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendConfig.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: FrontendChannelConfig\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendMutable","title":"FrontendMutable  <code>dataclass</code>","text":"<p>Marker to allow a particular field in a frontend configuration to be mutated in the settings page.</p> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>@dataclass(frozen=True)\nclass FrontendMutable:\n    \"\"\"Marker to allow a particular field in a frontend configuration to be mutated\n    in the settings page.\"\"\"\n\n    # TODO maybe in the future we can merge the two\n    kind: Literal[\"color\"] | None = None\n    widget: str | None = None\n    \"\"\"Identifier for a custom widget to use for this field in the frontend UI.\n    If multiple fields share the same widget id, they will be grouped together.\n    \"\"\"\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        json_schema = handler(core_schema)\n        json_schema[\"tangram_mutable\"] = True\n        if self.kind:\n            json_schema[\"tangram_kind\"] = self.kind\n        if self.widget:\n            json_schema[\"tangram_widget\"] = self.widget\n        return json_schema\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendMutable.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Literal['color'] | None = None\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendMutable.widget","title":"widget  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>widget: str | None = None\n</code></pre> <p>Identifier for a custom widget to use for this field in the frontend UI. If multiple fields share the same widget id, they will be grouped together.</p>"},{"location":"api/core/#tangram_core.config.FrontendData","title":"FrontendData","text":"<p>               Bases: <code>TypedDict</code></p> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>class FrontendData(TypedDict):\n    config: dict[str, Any]\n    config_json_schema: dict[str, Any]\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendData.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: dict[str, Any]\n</code></pre>"},{"location":"api/core/#tangram_core.config.FrontendData.config_json_schema","title":"config_json_schema  <code>instance-attribute</code>","text":"<pre><code>config_json_schema: dict[str, Any]\n</code></pre>"},{"location":"api/core/#tangram_core.config.default_config_file","title":"default_config_file","text":"<pre><code>default_config_file() -&gt; Path\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>def default_config_file() -&gt; Path:\n    import platformdirs\n\n    if (xdg_config := os.environ.get(\"XDG_CONFIG_HOME\")) is not None:\n        config_dir = Path(xdg_config) / \"tangram\"\n    else:\n        config_dir = Path(platformdirs.user_config_dir(appname=\"tangram\"))\n    if not config_dir.exists():\n        config_dir.mkdir(parents=True, exist_ok=True)\n\n    return Path(config_dir) / \"tangram.toml\"\n</code></pre>"},{"location":"api/core/#tangram_core.config.default_styles","title":"default_styles","text":"<pre><code>default_styles() -&gt; list[Url | StyleSpecification]\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>def default_styles() -&gt; list[Url | StyleSpecification]:\n    return [\n        \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n        \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n        \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n    ]\n</code></pre>"},{"location":"api/core/#tangram_core.config.try_resolve_local_style","title":"try_resolve_local_style","text":"<pre><code>try_resolve_local_style(\n    base_dir: Path,\n    style: Url | StyleName | StyleSpecification,\n    *,\n    allow_style_name: bool,\n) -&gt; Url | StyleSpecification\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>def try_resolve_local_style(\n    base_dir: Path,\n    style: Url | StyleName | StyleSpecification,\n    *,\n    allow_style_name: bool,\n) -&gt; Url | StyleSpecification:\n    if isinstance(style, str):\n        scheme = urllib.parse.urlparse(style).scheme\n        if scheme in (\"http\", \"https\"):\n            return style\n        if (p := (base_dir / style).resolve()).is_file():\n            with open(p, \"rb\") as f:\n                return json.load(f)\n        if not allow_style_name:\n            pass\n    return style\n</code></pre>"},{"location":"api/core/#tangram_core.config.to_frontend_manifest","title":"to_frontend_manifest","text":"<pre><code>to_frontend_manifest(\n    adapter: TypeAdapter, frontend_cfg: Any\n) -&gt; FrontendData\n</code></pre> <p>Serialises a frontend configuration.</p> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>def to_frontend_manifest(adapter: TypeAdapter, frontend_cfg: Any) -&gt; FrontendData:\n    \"\"\"Serialises a frontend configuration.\"\"\"\n    config_dump = adapter.dump_python(frontend_cfg)\n    config_json_schema = adapter.json_schema()\n    return {\"config\": config_dump, \"config_json_schema\": config_json_schema}\n</code></pre>"},{"location":"api/core/#tangram_core.config.parse_frontend_config","title":"parse_frontend_config","text":"<pre><code>parse_frontend_config(\n    adapter: TypeAdapter, frontend_cfg: Any\n) -&gt; Any\n</code></pre> <p>Deserialises and validates frontend-submitted config data.</p> Source code in <code>packages/tangram_core/src/tangram_core/config.py</code> <pre><code>def parse_frontend_config(adapter: TypeAdapter, frontend_cfg: Any) -&gt; Any:\n    \"\"\"Deserialises and validates frontend-submitted config data.\"\"\"\n    return adapter.validate_python(frontend_cfg)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin","title":"plugin","text":""},{"location":"api/core/#tangram_core.plugin.ServiceAsyncFunc","title":"ServiceAsyncFunc  <code>module-attribute</code>","text":"<pre><code>ServiceAsyncFunc: TypeAlias = Callable[\n    [BackendState], Coroutine[Any, Any, None]\n]\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.ServiceFunc","title":"ServiceFunc  <code>module-attribute</code>","text":"<pre><code>ServiceFunc: TypeAlias = (\n    ServiceAsyncFunc | Callable[[BackendState], None]\n)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Priority","title":"Priority  <code>module-attribute</code>","text":"<pre><code>Priority: TypeAlias = int\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.IntoFrontendConfigFunction","title":"IntoFrontendConfigFunction  <code>module-attribute</code>","text":"<pre><code>IntoFrontendConfigFunction: TypeAlias = Callable[[Any], Any]\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Lifespan","title":"Lifespan  <code>module-attribute</code>","text":"<pre><code>Lifespan: TypeAlias = Callable[\n    [BackendState],\n    AbstractAsyncContextManager[None, bool | None],\n]\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin","title":"Plugin  <code>dataclass</code>","text":"<p>Stores the metadata and registered API routes, background services and frontend assets for a tangram plugin.</p> <p>Packages should declare an entry point in the <code>tangram_core.plugins</code> group in their <code>pyproject.toml</code> pointing to an instance of this class.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>@dataclass\nclass Plugin:\n    \"\"\"Stores the metadata and registered API routes, background services and\n    frontend assets for a tangram plugin.\n\n    Packages should declare an entry point in the `tangram_core.plugins` group\n    in their `pyproject.toml` pointing to an instance of this class.\n    \"\"\"\n\n    frontend_path: str | None = None\n    \"\"\"Path to the compiled frontend assets, *relative* to the distribution root\n    (editable) or package root (wheel).\n    \"\"\"\n    routers: list[APIRouter] = field(default_factory=list)\n    config_class: type | None = None\n    \"\"\"The **backend** configuration class (dataclass, TypedDict or Pydantic model)\n    for the plugin.\"\"\"\n    frontend_config_class: type | None = None\n    \"\"\"The **frontend** configuration class for the plugin. If set, it will be used to\n    generate the frontend schema and validate settings updates.\n    Fields should be annotated with [tangram_core.config.FrontendMutable][] if they\n    are allowed to be modified from the frontend settings UI.\n    \"\"\"\n    into_frontend_config_function: IntoFrontendConfigFunction | None = None\n    \"\"\"Function to transform the backend configuration into the frontend\n    configuration. It receives the validated backend configuration object and\n    should return an instance of `frontend_config_class`.\n    Useful if the user wants to hide sensitive fields (e.g. API keys) from the frontend\n    or dynamically compute certain fields.\n    Required if `frontend_config_class` is set.\n    \"\"\"\n    lifespan: Lifespan | None = None\n    \"\"\"Async context manager for plugin initialization and teardown.\"\"\"\n    services: list[tuple[Priority, ServiceAsyncFunc]] = field(\n        default_factory=list, init=False\n    )\n    get_typer: Callable[[], Typer] | None = None\n    \"\"\"A function that returns the subcommands which will later be registered.\"\"\"\n    dist_name: str = field(init=False)\n    \"\"\"Name of the distribution (package) that provided this plugin, populated\n    automatically during loading.\n    \"\"\"  # we do this so plugins can know their own package name if needed\n\n    def register_service(\n        self, priority: Priority = 0\n    ) -&gt; Callable[[ServiceFunc], ServiceFunc]:\n        \"\"\"Decorator to register a background service function.\n\n        Services are long-running async functions that receive the BackendState\n        and are started when the application launches.\n        \"\"\"\n\n        def decorator(func: ServiceFunc) -&gt; ServiceFunc:\n            @functools.wraps(func)\n            async def async_wrapper(backend_state: BackendState) -&gt; None:\n                if asyncio.iscoroutinefunction(func):\n                    await func(backend_state)\n                else:\n                    await asyncio.to_thread(func, backend_state)\n\n            self.services.append((priority, async_wrapper))\n            return func\n\n        return decorator\n\n    # HACK: so lru_cache on adapter works.\n    # since we have mutable fields (routers, register_service, dist_name on init)\n    # its difficult to make this class frozen,\n    # so maybe we should implement __eq__ and __hash__ ourselves?\n    __hash__ = object.__hash__\n\n    @functools.lru_cache\n    def adapter(self) -&gt; TypeAdapter | None:\n        \"\"\"Returns a cached Pydantic TypeAdapter for the plugin's configuration class.\n\n        Avoids expensive rebuilds on every validation request, such as those from the\n        settings UI.\n        \"\"\"\n        from pydantic import TypeAdapter\n\n        if self.config_class:\n            return TypeAdapter(self.config_class)\n        return None\n\n    @functools.lru_cache\n    def frontend_adapter(self) -&gt; TypeAdapter | None:\n        \"\"\"Returns a cached Pydantic TypeAdapter for the plugin's frontend\n        configuration class.\"\"\"\n        from pydantic import TypeAdapter\n\n        if self.frontend_config_class:\n            return TypeAdapter(self.frontend_config_class)\n        return None\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin.frontend_path","title":"frontend_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frontend_path: str | None = None\n</code></pre> <p>Path to the compiled frontend assets, relative to the distribution root (editable) or package root (wheel).</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.routers","title":"routers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routers: list[APIRouter] = field(default_factory=list)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin.config_class","title":"config_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>config_class: type | None = None\n</code></pre> <p>The backend configuration class (dataclass, TypedDict or Pydantic model) for the plugin.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.frontend_config_class","title":"frontend_config_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frontend_config_class: type | None = None\n</code></pre> <p>The frontend configuration class for the plugin. If set, it will be used to generate the frontend schema and validate settings updates. Fields should be annotated with tangram_core.config.FrontendMutable if they are allowed to be modified from the frontend settings UI.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.into_frontend_config_function","title":"into_frontend_config_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>into_frontend_config_function: (\n    IntoFrontendConfigFunction | None\n) = None\n</code></pre> <p>Function to transform the backend configuration into the frontend configuration. It receives the validated backend configuration object and should return an instance of <code>frontend_config_class</code>. Useful if the user wants to hide sensitive fields (e.g. API keys) from the frontend or dynamically compute certain fields. Required if <code>frontend_config_class</code> is set.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.lifespan","title":"lifespan  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lifespan: Lifespan | None = None\n</code></pre> <p>Async context manager for plugin initialization and teardown.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.services","title":"services  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>services: list[tuple[Priority, ServiceAsyncFunc]] = field(\n    default_factory=list, init=False\n)\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin.get_typer","title":"get_typer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_typer: Callable[[], Typer] | None = None\n</code></pre> <p>A function that returns the subcommands which will later be registered.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.dist_name","title":"dist_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dist_name: str = field(init=False)\n</code></pre> <p>Name of the distribution (package) that provided this plugin, populated automatically during loading.</p>"},{"location":"api/core/#tangram_core.plugin.Plugin.register_service","title":"register_service","text":"<pre><code>register_service(\n    priority: Priority = 0,\n) -&gt; Callable[[ServiceFunc], ServiceFunc]\n</code></pre> <p>Decorator to register a background service function.</p> <p>Services are long-running async functions that receive the BackendState and are started when the application launches.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>def register_service(\n    self, priority: Priority = 0\n) -&gt; Callable[[ServiceFunc], ServiceFunc]:\n    \"\"\"Decorator to register a background service function.\n\n    Services are long-running async functions that receive the BackendState\n    and are started when the application launches.\n    \"\"\"\n\n    def decorator(func: ServiceFunc) -&gt; ServiceFunc:\n        @functools.wraps(func)\n        async def async_wrapper(backend_state: BackendState) -&gt; None:\n            if asyncio.iscoroutinefunction(func):\n                await func(backend_state)\n            else:\n                await asyncio.to_thread(func, backend_state)\n\n        self.services.append((priority, async_wrapper))\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin.adapter","title":"adapter  <code>cached</code>","text":"<pre><code>adapter() -&gt; TypeAdapter | None\n</code></pre> <p>Returns a cached Pydantic TypeAdapter for the plugin's configuration class.</p> <p>Avoids expensive rebuilds on every validation request, such as those from the settings UI.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>@functools.lru_cache\ndef adapter(self) -&gt; TypeAdapter | None:\n    \"\"\"Returns a cached Pydantic TypeAdapter for the plugin's configuration class.\n\n    Avoids expensive rebuilds on every validation request, such as those from the\n    settings UI.\n    \"\"\"\n    from pydantic import TypeAdapter\n\n    if self.config_class:\n        return TypeAdapter(self.config_class)\n    return None\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.Plugin.frontend_adapter","title":"frontend_adapter  <code>cached</code>","text":"<pre><code>frontend_adapter() -&gt; TypeAdapter | None\n</code></pre> <p>Returns a cached Pydantic TypeAdapter for the plugin's frontend configuration class.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>@functools.lru_cache\ndef frontend_adapter(self) -&gt; TypeAdapter | None:\n    \"\"\"Returns a cached Pydantic TypeAdapter for the plugin's frontend\n    configuration class.\"\"\"\n    from pydantic import TypeAdapter\n\n    if self.frontend_config_class:\n        return TypeAdapter(self.frontend_config_class)\n    return None\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.scan_plugins","title":"scan_plugins","text":"<pre><code>scan_plugins() -&gt; EntryPoints\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>def scan_plugins() -&gt; importlib.metadata.EntryPoints:\n    return importlib.metadata.entry_points(group=\"tangram_core.plugins\")\n</code></pre>"},{"location":"api/core/#tangram_core.plugin.load_plugin","title":"load_plugin","text":"<pre><code>load_plugin(entry_point: EntryPoint) -&gt; Plugin | None\n</code></pre> <p>Instantiates the plugin object defined in the entry point and injects the name of the distribution into it.</p> Source code in <code>packages/tangram_core/src/tangram_core/plugin.py</code> <pre><code>def load_plugin(\n    entry_point: importlib.metadata.EntryPoint,\n) -&gt; Plugin | None:\n    \"\"\"Instantiates the plugin object defined in the entry point\n    and injects the name of the distribution into it.\"\"\"\n    try:\n        plugin_instance = entry_point.load()\n    except Exception as e:\n        tb = traceback.format_exc()\n        logger.error(\n            f\"failed to load plugin {entry_point.name}: {e}. {tb}\"\n            f\"\\n= help: does {entry_point.value} exist?\"\n        )\n        return None\n    if not isinstance(plugin_instance, Plugin):\n        logger.error(f\"entry point {entry_point.name} is not an instance of `Plugin`\")\n        return None\n    if entry_point.dist is None:\n        logger.error(f\"could not determine distribution for plugin {entry_point.name}\")\n        return None\n    # NOTE: we ignore `entry_point.name` for now and simply use the distribution's name\n    # should we raise an error if they differ? not for now\n\n    plugin_instance.dist_name = entry_point.dist.name\n    return plugin_instance\n</code></pre>"},{"location":"api/core/#tangram_core.redis","title":"redis","text":""},{"location":"api/core/#tangram_core.redis.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/core/#tangram_core.redis.StateT","title":"StateT  <code>module-attribute</code>","text":"<pre><code>StateT = TypeVar('StateT')\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber","title":"Subscriber","text":"<p>               Bases: <code>ABC</code>, <code>Generic[StateT]</code></p> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>class Subscriber(abc.ABC, Generic[StateT]):\n    redis: Redis\n    task: asyncio.Task[None]\n    pubsub: PubSub\n\n    def __init__(\n        self, name: str, redis_url: str, channels: List[str], initial_state: StateT\n    ):\n        self.name = name\n        self.redis_url: str = redis_url\n        self.channels: List[str] = channels\n        self.state: StateT = initial_state\n        self._running = False\n\n    async def subscribe(self) -&gt; None:\n        if self._running:\n            log.warning(\"%s already running\", self.name)\n            return\n\n        try:\n            self.redis = await Redis.from_url(self.redis_url)\n            self.pubsub = self.redis.pubsub()\n            await self.pubsub.psubscribe(*self.channels)\n        except RedisError as e:\n            log.error(\"%s failed to connect to Redis: %s\", self.name, e)\n            raise\n\n        async def listen() -&gt; None:\n            try:\n                log.info(\"%s listening ...\", self.name)\n                async for message in self.pubsub.listen():\n                    log.debug(\"message: %s\", message)\n                    if message[\"type\"] == \"pmessage\":\n                        await self.message_handler(\n                            message[\"channel\"].decode(\"utf-8\"),\n                            message[\"data\"].decode(\"utf-8\"),\n                            message[\"pattern\"].decode(\"utf-8\"),\n                            self.state,\n                        )\n            except asyncio.CancelledError:\n                log.warning(\"%s cancelled\", self.name)\n\n        self._running = True\n\n        self.task = asyncio.create_task(listen())\n        log.info(\"%s task created, running ...\", self.name)\n\n    async def cleanup(self) -&gt; None:\n        if not self._running:\n            return\n\n        if self.task:\n            log.debug(\"%s canceling task ...\", self.name)\n            self.task.cancel()\n            try:\n                log.debug(\"%s await task to finish ...\", self.name)\n                await self.task\n                log.debug(\"%s task canceled\", self.name)\n            except asyncio.CancelledError as exc:\n                log.error(\"%s task canceling error: %s\", self.name, exc)\n        if self.pubsub:\n            await self.pubsub.unsubscribe()\n        if self.redis:\n            await self.redis.close()\n        self._running = False\n\n    def is_active(self) -&gt; bool:\n        \"\"\"Return True if the subscriber is actively listening.\"\"\"\n        return self._running and self.task is not None and not self.task.done()\n\n    @abc.abstractmethod\n    async def message_handler(\n        self, event: str, payload: str, pattern: str, state: StateT\n    ) -&gt; None:\n        pass\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.redis","title":"redis  <code>instance-attribute</code>","text":"<pre><code>redis: Redis\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: Task[None]\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.pubsub","title":"pubsub  <code>instance-attribute</code>","text":"<pre><code>pubsub: PubSub\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.redis_url","title":"redis_url  <code>instance-attribute</code>","text":"<pre><code>redis_url: str = redis_url\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.channels","title":"channels  <code>instance-attribute</code>","text":"<pre><code>channels: List[str] = channels\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: StateT = initial_state\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.subscribe","title":"subscribe  <code>async</code>","text":"<pre><code>subscribe() -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>async def subscribe(self) -&gt; None:\n    if self._running:\n        log.warning(\"%s already running\", self.name)\n        return\n\n    try:\n        self.redis = await Redis.from_url(self.redis_url)\n        self.pubsub = self.redis.pubsub()\n        await self.pubsub.psubscribe(*self.channels)\n    except RedisError as e:\n        log.error(\"%s failed to connect to Redis: %s\", self.name, e)\n        raise\n\n    async def listen() -&gt; None:\n        try:\n            log.info(\"%s listening ...\", self.name)\n            async for message in self.pubsub.listen():\n                log.debug(\"message: %s\", message)\n                if message[\"type\"] == \"pmessage\":\n                    await self.message_handler(\n                        message[\"channel\"].decode(\"utf-8\"),\n                        message[\"data\"].decode(\"utf-8\"),\n                        message[\"pattern\"].decode(\"utf-8\"),\n                        self.state,\n                    )\n        except asyncio.CancelledError:\n            log.warning(\"%s cancelled\", self.name)\n\n    self._running = True\n\n    self.task = asyncio.create_task(listen())\n    log.info(\"%s task created, running ...\", self.name)\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.cleanup","title":"cleanup  <code>async</code>","text":"<pre><code>cleanup() -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>async def cleanup(self) -&gt; None:\n    if not self._running:\n        return\n\n    if self.task:\n        log.debug(\"%s canceling task ...\", self.name)\n        self.task.cancel()\n        try:\n            log.debug(\"%s await task to finish ...\", self.name)\n            await self.task\n            log.debug(\"%s task canceled\", self.name)\n        except asyncio.CancelledError as exc:\n            log.error(\"%s task canceling error: %s\", self.name, exc)\n    if self.pubsub:\n        await self.pubsub.unsubscribe()\n    if self.redis:\n        await self.redis.close()\n    self._running = False\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.is_active","title":"is_active","text":"<pre><code>is_active() -&gt; bool\n</code></pre> <p>Return True if the subscriber is actively listening.</p> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>def is_active(self) -&gt; bool:\n    \"\"\"Return True if the subscriber is actively listening.\"\"\"\n    return self._running and self.task is not None and not self.task.done()\n</code></pre>"},{"location":"api/core/#tangram_core.redis.Subscriber.message_handler","title":"message_handler  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>message_handler(\n    event: str, payload: str, pattern: str, state: StateT\n) -&gt; None\n</code></pre> Source code in <code>packages/tangram_core/src/tangram_core/redis.py</code> <pre><code>@abc.abstractmethod\nasync def message_handler(\n    self, event: str, payload: str, pattern: str, state: StateT\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/core/#tangram_core._core","title":"tangram_core._core","text":""},{"location":"api/core/#tangram_core._core.ChannelConfig","title":"ChannelConfig","text":""},{"location":"api/core/#tangram_core._core.ChannelConfig.host","title":"host  <code>property</code> <code>writable</code>","text":"<pre><code>host: str\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.port","title":"port  <code>property</code> <code>writable</code>","text":"<pre><code>port: int\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.redis_url","title":"redis_url  <code>property</code> <code>writable</code>","text":"<pre><code>redis_url: str\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.jwt_secret","title":"jwt_secret  <code>property</code> <code>writable</code>","text":"<pre><code>jwt_secret: str\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.jwt_expiration_secs","title":"jwt_expiration_secs  <code>property</code> <code>writable</code>","text":"<pre><code>jwt_expiration_secs: int\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.id_length","title":"id_length  <code>property</code> <code>writable</code>","text":"<pre><code>id_length: int\n</code></pre>"},{"location":"api/core/#tangram_core._core.ChannelConfig.__new__","title":"__new__","text":"<pre><code>__new__(\n    host: str,\n    port: int,\n    redis_url: str,\n    jwt_secret: str,\n    jwt_expiration_secs: int,\n    id_length: int,\n) -&gt; ChannelConfig\n</code></pre>"},{"location":"api/core/#tangram_core._core.init_tracing_stderr","title":"init_tracing_stderr","text":"<pre><code>init_tracing_stderr(filter_str: str) -&gt; None\n</code></pre>"},{"location":"api/core/#tangram_core._core.run","title":"run","text":"<pre><code>run(config: ChannelConfig) -&gt; Any\n</code></pre>"},{"location":"api/explore/","title":"Explore","text":""},{"location":"api/explore/#tangram_explore","title":"tangram_explore","text":""},{"location":"api/explore/#tangram_explore.EXPLORE_CHANNEL","title":"EXPLORE_CHANNEL  <code>module-attribute</code>","text":"<pre><code>EXPLORE_CHANNEL = 'explore'\n</code></pre>"},{"location":"api/explore/#tangram_explore.EXPLORE_EVENT","title":"EXPLORE_EVENT  <code>module-attribute</code>","text":"<pre><code>EXPLORE_EVENT = 'layers'\n</code></pre>"},{"location":"api/explore/#tangram_explore.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(prefix='/explore', tags=['explore'])\n</code></pre>"},{"location":"api/explore/#tangram_explore.LayerId","title":"LayerId  <code>module-attribute</code>","text":"<pre><code>LayerId: TypeAlias = str\n</code></pre> <p>Unique UUID for a layer.</p>"},{"location":"api/explore/#tangram_explore.ParquetBytes","title":"ParquetBytes  <code>module-attribute</code>","text":"<pre><code>ParquetBytes: TypeAlias = bytes\n</code></pre>"},{"location":"api/explore/#tangram_explore.LayerConfig","title":"LayerConfig  <code>module-attribute</code>","text":"<pre><code>LayerConfig: TypeAlias = dict[str, Any]\n</code></pre> <p>Serialised layer configuration without data or label.</p>"},{"location":"api/explore/#tangram_explore.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\",\n    routers=[router],\n    config_class=ExploreConfig,\n    frontend_config_class=ExploreFrontendConfig,\n    into_frontend_config_function=into_frontend,\n    lifespan=lifespan,\n)\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreState","title":"ExploreState  <code>dataclass</code>","text":"Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@dataclass\nclass ExploreState:\n    data: dict[LayerId, ParquetBytes] = field(default_factory=dict)\n    layers: dict[LayerId, LayerConfig] = field(default_factory=dict)\n    layer_order: list[LayerId] = field(default_factory=list)\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreState.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: dict[LayerId, ParquetBytes] = field(\n    default_factory=dict\n)\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreState.layers","title":"layers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layers: dict[LayerId, LayerConfig] = field(\n    default_factory=dict\n)\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreState.layer_order","title":"layer_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>layer_order: list[LayerId] = field(default_factory=list)\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreState.__init__","title":"__init__","text":"<pre><code>__init__(\n    data: dict[LayerId, ParquetBytes] = dict(),\n    layers: dict[LayerId, LayerConfig] = dict(),\n    layer_order: list[LayerId] = list(),\n) -&gt; None\n</code></pre>"},{"location":"api/explore/#tangram_explore.ArrowStreamExportable","title":"ArrowStreamExportable","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@runtime_checkable\nclass ArrowStreamExportable(Protocol):\n    def __arrow_c_stream__(self, requested_schema: Any = None) -&gt; Any: ...\n</code></pre>"},{"location":"api/explore/#tangram_explore.ArrowStreamExportable.__arrow_c_stream__","title":"__arrow_c_stream__","text":"<pre><code>__arrow_c_stream__(requested_schema: Any = None) -&gt; Any\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>def __arrow_c_stream__(self, requested_schema: Any = None) -&gt; Any: ...\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreLayer","title":"ExploreLayer","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@runtime_checkable\nclass ExploreLayer(Protocol):\n    data: ArrowStreamExportable\n    \"\"\"Any data structure that implements the\n    [Arrow C data interface](https://arrow.apache.org/docs/format/CDataInterface.html),\n    such as polars DataFrames or pyarrow Tables.\"\"\"\n    label: str | None\n    \"\"\"Unique name for the layer (optional).\n    If not provided, a random 8-character ID will be used.\"\"\"\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreLayer.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: ArrowStreamExportable\n</code></pre> <p>Any data structure that implements the Arrow C data interface, such as polars DataFrames or pyarrow Tables.</p>"},{"location":"api/explore/#tangram_explore.ExploreLayer.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str | None\n</code></pre> <p>Unique name for the layer (optional). If not provided, a random 8-character ID will be used.</p>"},{"location":"api/explore/#tangram_explore.ScatterLayer","title":"ScatterLayer  <code>dataclass</code>","text":"<p>               Bases: <code>ExploreLayer</code></p> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass ScatterLayer(ExploreLayer):\n    data: ArrowStreamExportable\n    _: KW_ONLY\n    radius_scale: float = 50.0\n    radius_min_pixels: float = 2.0\n    radius_max_pixels: float = 5.0\n    line_width_min_pixels: float = 1.0\n    fill_color: str | list[int] = \"#027ec7\"\n    line_color: str | list[int] = \"#000000\"\n    opacity: float = 0.8\n    stroked: bool = False\n    filled: bool = True\n    pickable: bool = True\n    label: str | None = None\n    kind: Literal[\"scatter\"] = field(default=\"scatter\", init=False)\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: ArrowStreamExportable\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer._","title":"_  <code>instance-attribute</code>","text":"<pre><code>_: KW_ONLY\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.radius_scale","title":"radius_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_scale: float = 50.0\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.radius_min_pixels","title":"radius_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_min_pixels: float = 2.0\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.radius_max_pixels","title":"radius_max_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>radius_max_pixels: float = 5.0\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.line_width_min_pixels","title":"line_width_min_pixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width_min_pixels: float = 1.0\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.fill_color","title":"fill_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fill_color: str | list[int] = '#027ec7'\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.line_color","title":"line_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_color: str | list[int] = '#000000'\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.opacity","title":"opacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opacity: float = 0.8\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.stroked","title":"stroked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stroked: bool = False\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.filled","title":"filled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filled: bool = True\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.pickable","title":"pickable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pickable: bool = True\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: str | None = None\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.kind","title":"kind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kind: Literal[\"scatter\"] = field(\n    default=\"scatter\", init=False\n)\n</code></pre>"},{"location":"api/explore/#tangram_explore.ScatterLayer.__init__","title":"__init__","text":"<pre><code>__init__(\n    data: ArrowStreamExportable,\n    *,\n    radius_scale: float = 50.0,\n    radius_min_pixels: float = 2.0,\n    radius_max_pixels: float = 5.0,\n    line_width_min_pixels: float = 1.0,\n    fill_color: str | list[int] = \"#027ec7\",\n    line_color: str | list[int] = \"#000000\",\n    opacity: float = 0.8,\n    stroked: bool = False,\n    filled: bool = True,\n    pickable: bool = True,\n    label: str | None = None,\n) -&gt; None\n</code></pre>"},{"location":"api/explore/#tangram_explore.Layer","title":"Layer  <code>dataclass</code>","text":"Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Layer:\n    id: str\n    _session: Session\n\n    async def remove(self) -&gt; None:\n        await self._session.remove(self.id)\n</code></pre>"},{"location":"api/explore/#tangram_explore.Layer.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/explore/#tangram_explore.Layer.__init__","title":"__init__","text":"<pre><code>__init__(id: str, _session: Session) -&gt; None\n</code></pre>"},{"location":"api/explore/#tangram_explore.Layer.remove","title":"remove  <code>async</code>","text":"<pre><code>remove() -&gt; None\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>async def remove(self) -&gt; None:\n    await self._session.remove(self.id)\n</code></pre>"},{"location":"api/explore/#tangram_explore.Session","title":"Session  <code>dataclass</code>","text":"Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Session:\n    state: BackendState\n\n    def __post_init__(self) -&gt; None:\n        if not hasattr(self.state, \"explore_state\"):\n            raise RuntimeError(\n                \"The 'tangram_explore' plugin is not active. \"\n                \"Ensure it is added to the [core.plugins] list in your config.\"\n            )\n\n    async def _broadcast(self, op: str, **kwargs: Any) -&gt; None:\n        payload = {\"op\": op, **kwargs}\n        topic = f\"to:{EXPLORE_CHANNEL}:{EXPLORE_EVENT}\"\n        await self.state.redis_client.publish(topic, orjson.dumps(payload))\n\n    async def push(self, layer: ExploreLayer) -&gt; Layer:\n        if not is_dataclass(layer):  # required for fields()\n            raise TypeError(\"layer must be a dataclass\")\n        if not isinstance(layer, ExploreLayer):\n            raise TypeError(\"layer must implement ExploreLayer protocol\")\n\n        data_id = str(uuid.uuid4())\n        parquet_bytes = _to_parquet_bytes(layer.data)\n\n        explore_state = get_explore_state(self.state)\n        explore_state.data[data_id] = parquet_bytes\n\n        style = {\n            f.name: getattr(layer, f.name)\n            for f in fields(layer)\n            if f.name not in (\"data\", \"label\")\n        }\n        label = getattr(layer, \"label\", None)\n\n        layer_def = {\n            \"id\": data_id,\n            \"label\": label or data_id[:8],\n            \"url\": f\"/explore/data/{data_id}\",\n            \"style\": style,\n        }\n        explore_state.layers[data_id] = layer_def\n        explore_state.layer_order.append(data_id)\n\n        await self._broadcast(\"add\", layer=layer_def)\n\n        return Layer(id=data_id, _session=self)\n\n    async def remove(self, data_id: str) -&gt; None:\n        explore_state = get_explore_state(self.state)\n        if data_id in explore_state.data:\n            del explore_state.data[data_id]\n        if data_id in explore_state.layers:\n            del explore_state.layers[data_id]\n        if data_id in explore_state.layer_order:\n            explore_state.layer_order.remove(data_id)\n        await self._broadcast(\"remove\", id=data_id)\n\n    async def clear(self) -&gt; None:\n        explore_state = get_explore_state(self.state)\n        explore_state.data.clear()\n        explore_state.layers.clear()\n        explore_state.layer_order.clear()\n        await self._broadcast(\"clear\")\n</code></pre>"},{"location":"api/explore/#tangram_explore.Session.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: BackendState\n</code></pre>"},{"location":"api/explore/#tangram_explore.Session.__init__","title":"__init__","text":"<pre><code>__init__(state: BackendState) -&gt; None\n</code></pre>"},{"location":"api/explore/#tangram_explore.Session.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    if not hasattr(self.state, \"explore_state\"):\n        raise RuntimeError(\n            \"The 'tangram_explore' plugin is not active. \"\n            \"Ensure it is added to the [core.plugins] list in your config.\"\n        )\n</code></pre>"},{"location":"api/explore/#tangram_explore.Session.push","title":"push  <code>async</code>","text":"<pre><code>push(layer: ExploreLayer) -&gt; Layer\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>async def push(self, layer: ExploreLayer) -&gt; Layer:\n    if not is_dataclass(layer):  # required for fields()\n        raise TypeError(\"layer must be a dataclass\")\n    if not isinstance(layer, ExploreLayer):\n        raise TypeError(\"layer must implement ExploreLayer protocol\")\n\n    data_id = str(uuid.uuid4())\n    parquet_bytes = _to_parquet_bytes(layer.data)\n\n    explore_state = get_explore_state(self.state)\n    explore_state.data[data_id] = parquet_bytes\n\n    style = {\n        f.name: getattr(layer, f.name)\n        for f in fields(layer)\n        if f.name not in (\"data\", \"label\")\n    }\n    label = getattr(layer, \"label\", None)\n\n    layer_def = {\n        \"id\": data_id,\n        \"label\": label or data_id[:8],\n        \"url\": f\"/explore/data/{data_id}\",\n        \"style\": style,\n    }\n    explore_state.layers[data_id] = layer_def\n    explore_state.layer_order.append(data_id)\n\n    await self._broadcast(\"add\", layer=layer_def)\n\n    return Layer(id=data_id, _session=self)\n</code></pre>"},{"location":"api/explore/#tangram_explore.Session.remove","title":"remove  <code>async</code>","text":"<pre><code>remove(data_id: str) -&gt; None\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>async def remove(self, data_id: str) -&gt; None:\n    explore_state = get_explore_state(self.state)\n    if data_id in explore_state.data:\n        del explore_state.data[data_id]\n    if data_id in explore_state.layers:\n        del explore_state.layers[data_id]\n    if data_id in explore_state.layer_order:\n        explore_state.layer_order.remove(data_id)\n    await self._broadcast(\"remove\", id=data_id)\n</code></pre>"},{"location":"api/explore/#tangram_explore.Session.clear","title":"clear  <code>async</code>","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>async def clear(self) -&gt; None:\n    explore_state = get_explore_state(self.state)\n    explore_state.data.clear()\n    explore_state.layers.clear()\n    explore_state.layer_order.clear()\n    await self._broadcast(\"clear\")\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreConfig","title":"ExploreConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@dataclass\nclass ExploreConfig:\n    enable_3d: bool = False\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreConfig.enable_3d","title":"enable_3d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_3d: bool = False\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreConfig.__init__","title":"__init__","text":"<pre><code>__init__(enable_3d: bool = False) -&gt; None\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreFrontendConfig","title":"ExploreFrontendConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@dataclass\nclass ExploreFrontendConfig:\n    enable_3d: Annotated[bool, FrontendMutable()]\n    \"\"\"Whether to render scatter points in 3D\"\"\"\n</code></pre>"},{"location":"api/explore/#tangram_explore.ExploreFrontendConfig.enable_3d","title":"enable_3d  <code>instance-attribute</code>","text":"<pre><code>enable_3d: Annotated[bool, FrontendMutable()]\n</code></pre> <p>Whether to render scatter points in 3D</p>"},{"location":"api/explore/#tangram_explore.ExploreFrontendConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    enable_3d: Annotated[bool, FrontendMutable()],\n) -&gt; None\n</code></pre>"},{"location":"api/explore/#tangram_explore.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(state: BackendState) -&gt; AsyncGenerator[None, None]\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(state: BackendState) -&gt; AsyncGenerator[None, None]:\n    setattr(state, \"explore_state\", ExploreState())\n    yield\n    delattr(state, \"explore_state\")\n</code></pre>"},{"location":"api/explore/#tangram_explore.get_explore_state","title":"get_explore_state","text":"<pre><code>get_explore_state(\n    state: InjectBackendState,\n) -&gt; ExploreState\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>def get_explore_state(state: tangram_core.InjectBackendState) -&gt; ExploreState:\n    return cast(ExploreState, getattr(state, \"explore_state\"))\n</code></pre>"},{"location":"api/explore/#tangram_explore.get_explore_data","title":"get_explore_data  <code>async</code>","text":"<pre><code>get_explore_data(\n    data_id: str, state: InjectBackendState\n) -&gt; Response\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@router.get(\"/data/{data_id}\")\nasync def get_explore_data(\n    data_id: str, state: tangram_core.InjectBackendState\n) -&gt; Response:\n    explore_state = get_explore_state(state)\n    data = explore_state.data.get(data_id)\n    if data is None:\n        return Response(status_code=404)  # shouldn't occur\n    return Response(content=data, media_type=\"application/vnd.apache.parquet\")\n</code></pre>"},{"location":"api/explore/#tangram_explore.get_layers","title":"get_layers  <code>async</code>","text":"<pre><code>get_layers(\n    state: InjectBackendState,\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>@router.get(\"/layers\")\nasync def get_layers(state: tangram_core.InjectBackendState) -&gt; list[dict[str, Any]]:\n    explore_state = get_explore_state(state)\n    return [explore_state.layers[uid] for uid in explore_state.layer_order]\n</code></pre>"},{"location":"api/explore/#tangram_explore.into_frontend","title":"into_frontend","text":"<pre><code>into_frontend(\n    config: ExploreConfig,\n) -&gt; ExploreFrontendConfig\n</code></pre> Source code in <code>packages/tangram_explore/src/tangram_explore/__init__.py</code> <pre><code>def into_frontend(config: ExploreConfig) -&gt; ExploreFrontendConfig:\n    return ExploreFrontendConfig(enable_3d=config.enable_3d)\n</code></pre>"},{"location":"api/history/","title":"History","text":""},{"location":"api/history/#tangram_history","title":"tangram_history","text":""},{"location":"api/history/#tangram_history.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/history/#tangram_history.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(get_typer=get_typer)\n</code></pre>"},{"location":"api/history/#tangram_history.get_typer","title":"get_typer","text":"<pre><code>get_typer() -&gt; Typer\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/__init__.py</code> <pre><code>def get_typer() -&gt; Typer:\n    from .cli import app\n\n    return app\n</code></pre>"},{"location":"api/history/#tangram_history.run_history","title":"run_history  <code>async</code>","text":"<pre><code>run_history(backend_state: BackendState) -&gt; None\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/__init__.py</code> <pre><code>@plugin.register_service()\nasync def run_history(backend_state: tangram_core.BackendState) -&gt; None:\n    from . import _history\n\n    plugin_config = backend_state.config.plugins.get(\"tangram_history\", {})\n    config_history = TypeAdapter(HistoryConfig).validate_python(plugin_config)\n\n    default_log_level = plugin_config.get(\n        \"log_level\", backend_state.config.core.log_level\n    )\n\n    _history.init_tracing_stderr(default_log_level)\n\n    config_history.base_path.mkdir(parents=True, exist_ok=True)\n    rust_config = _history.HistoryConfig(\n        redis_url=backend_state.config.core.redis_url,\n        control_channel=config_history.control_channel,\n        base_path=str(config_history.base_path),\n        redis_read_count=config_history.redis_read_count,\n        redis_read_block_ms=config_history.redis_read_block_ms,\n    )\n    await _history.run_history(rust_config)\n</code></pre>"},{"location":"api/history/#tangram_history.cli","title":"cli","text":"<p>A history management CLI that operates safely regardless of whether the <code>tangram serve</code> backend is running. Operations repsect the single-writer principle of Delta Lake when ingestion is active, or function when offline.</p> <p>When online, the CLI acts as a remote control, sending serialised commands via Redis, with the service orchestrating locks (pausing ingestion/maintenance). When offline, the CLI assumes exclusive access and operates directly on the file system via PyO3 bindings.</p>"},{"location":"api/history/#tangram_history.cli.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer(\n    name=\"history\", help=\"Manage historical data storage.\"\n)\n</code></pre>"},{"location":"api/history/#tangram_history.cli.console","title":"console  <code>module-attribute</code>","text":"<pre><code>console = Console()\n</code></pre>"},{"location":"api/history/#tangram_history.cli.PathTangramConfig","title":"PathTangramConfig  <code>module-attribute</code>","text":"<pre><code>PathTangramConfig: TypeAlias = Annotated[\n    Path,\n    Option(\n        help=\"Path to the tangram.toml config file.\",\n        envvar=\"TANGRAM_CONFIG\",\n        default_factory=default_config_file,\n        exists=True,\n        dir_okay=False,\n    ),\n]\n</code></pre>"},{"location":"api/history/#tangram_history.cli.ForceOffline","title":"ForceOffline  <code>module-attribute</code>","text":"<pre><code>ForceOffline: TypeAlias = Annotated[\n    bool,\n    Option(\n        \"--force-offline\",\n        help=\"Force offline operation, bypassing the tangram service even if online.\",\n    ),\n]\n</code></pre>"},{"location":"api/history/#tangram_history.cli.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=SupportsSerde)\n</code></pre>"},{"location":"api/history/#tangram_history.cli.yesterday","title":"yesterday  <code>module-attribute</code>","text":"<pre><code>yesterday = isoformat(timespec='seconds')\n</code></pre>"},{"location":"api/history/#tangram_history.cli.HistoryStatus","title":"HistoryStatus","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>class HistoryStatus(Enum):\n    HAS_SUBSCRIBERS = auto()\n    NO_SUBSCRIBERS = auto()\n    REDIS_OFFLINE = auto()\n\n    def to_message(self) -&gt; str:\n        if self == HistoryStatus.HAS_SUBSCRIBERS:\n            return \"service is online and has subscribers\"\n        if self == HistoryStatus.NO_SUBSCRIBERS:\n            return \"no subscribers on history control channel\"\n        if self == HistoryStatus.REDIS_OFFLINE:\n            return \"unable to connect to redis\"\n        assert_never(self)\n</code></pre>"},{"location":"api/history/#tangram_history.cli.HistoryStatus.HAS_SUBSCRIBERS","title":"HAS_SUBSCRIBERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HAS_SUBSCRIBERS = auto()\n</code></pre>"},{"location":"api/history/#tangram_history.cli.HistoryStatus.NO_SUBSCRIBERS","title":"NO_SUBSCRIBERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NO_SUBSCRIBERS = auto()\n</code></pre>"},{"location":"api/history/#tangram_history.cli.HistoryStatus.REDIS_OFFLINE","title":"REDIS_OFFLINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDIS_OFFLINE = auto()\n</code></pre>"},{"location":"api/history/#tangram_history.cli.HistoryStatus.to_message","title":"to_message","text":"<pre><code>to_message() -&gt; str\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def to_message(self) -&gt; str:\n    if self == HistoryStatus.HAS_SUBSCRIBERS:\n        return \"service is online and has subscribers\"\n    if self == HistoryStatus.NO_SUBSCRIBERS:\n        return \"no subscribers on history control channel\"\n    if self == HistoryStatus.REDIS_OFFLINE:\n        return \"unable to connect to redis\"\n    assert_never(self)\n</code></pre>"},{"location":"api/history/#tangram_history.cli.SupportsSerde","title":"SupportsSerde","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>class SupportsSerde(Protocol):\n    @staticmethod\n    def from_json_bytes(data: bytes) -&gt; Any: ...\n    def to_json_bytes(self) -&gt; bytes: ...\n</code></pre>"},{"location":"api/history/#tangram_history.cli.SupportsSerde.from_json_bytes","title":"from_json_bytes  <code>staticmethod</code>","text":"<pre><code>from_json_bytes(data: bytes) -&gt; Any\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>@staticmethod\ndef from_json_bytes(data: bytes) -&gt; Any: ...\n</code></pre>"},{"location":"api/history/#tangram_history.cli.SupportsSerde.to_json_bytes","title":"to_json_bytes","text":"<pre><code>to_json_bytes() -&gt; bytes\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def to_json_bytes(self) -&gt; bytes: ...\n</code></pre>"},{"location":"api/history/#tangram_history.cli.print_error","title":"print_error","text":"<pre><code>print_error(v: Any) -&gt; None\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def print_error(v: Any) -&gt; None:\n    console.print(f\"[bold red]error[/bold red]: {v}\")\n</code></pre>"},{"location":"api/history/#tangram_history.cli.print_note","title":"print_note","text":"<pre><code>print_note(v: Any) -&gt; None\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def print_note(v: Any) -&gt; None:\n    console.print(f\"[bold cyan]note[/bold cyan]: {v}\")\n</code></pre>"},{"location":"api/history/#tangram_history.cli.print_warning","title":"print_warning","text":"<pre><code>print_warning(v: Any) -&gt; None\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def print_warning(v: Any) -&gt; None:\n    console.print(f\"[bold yellow]warning[/bold yellow]: {v}\")\n</code></pre>"},{"location":"api/history/#tangram_history.cli.parse_config","title":"parse_config","text":"<pre><code>parse_config(config_path: Path) -&gt; _CfgResult\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def parse_config(config_path: Path) -&gt; _CfgResult:\n    from pydantic import TypeAdapter\n\n    if not config_path.exists():\n        print_error(f\"config file not found: {config_path}\")\n        raise typer.Exit(1)\n\n    config = Config.from_file(config_path)\n    plugin_config = config.plugins.get(\"tangram_history\", {})\n    return _CfgResult(\n        config=config,\n        history_config=TypeAdapter(HistoryConfig).validate_python(plugin_config),\n    )\n</code></pre>"},{"location":"api/history/#tangram_history.cli.get_service_status","title":"get_service_status","text":"<pre><code>get_service_status(\n    redis_url: str, control_channel: str\n) -&gt; HistoryStatus\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def get_service_status(redis_url: str, control_channel: str) -&gt; HistoryStatus:\n    try:\n        r = redis.from_url(redis_url)  # type: ignore\n        response: list[tuple[str, int]] = r.pubsub_numsub(control_channel)  # type: ignore\n        if not response:\n            return HistoryStatus.NO_SUBSCRIBERS\n        return (\n            HistoryStatus.HAS_SUBSCRIBERS\n            if response[0][1] &gt; 0  # type: ignore\n            else HistoryStatus.NO_SUBSCRIBERS\n        )\n    except redis.ConnectionError:\n        return HistoryStatus.REDIS_OFFLINE\n</code></pre>"},{"location":"api/history/#tangram_history.cli.send_command","title":"send_command","text":"<pre><code>send_command(\n    config_result: _CfgResult,\n    sender_id: str,\n    message_bytes: bytes,\n    response_type: type[T],\n    *,\n    timeout: int = 10,\n) -&gt; T | None\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def send_command(\n    config_result: _CfgResult,\n    sender_id: str,\n    message_bytes: bytes,\n    response_type: type[T],\n    *,\n    timeout: int = 10,\n) -&gt; T | None:\n    redis_url = config_result.config.core.redis_url\n    control_channel = config_result.history_config.control_channel\n    response_channel = f\"{control_channel}:response:{sender_id}\"\n\n    try:\n        r = redis.from_url(redis_url)  # type: ignore\n        p = r.pubsub()\n        p.subscribe(response_channel)\n        p.get_message(timeout=2.0)  # subscription confirmation\n\n        r.publish(control_channel, message_bytes)\n\n        response_message = p.get_message(timeout=timeout)\n        p.unsubscribe()\n        r.close()\n\n        if response_message and response_message.get(\"type\") == \"message\":\n            return response_type.from_json_bytes(response_message[\"data\"])\n        return None\n    except redis.ConnectionError:\n        return None\n</code></pre>"},{"location":"api/history/#tangram_history.cli.format_schema","title":"format_schema","text":"<pre><code>format_schema(schema_str: str, prefix: str = '') -&gt; str\n</code></pre> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>def format_schema(schema_str: str, prefix: str = \"\") -&gt; str:\n    schema = orjson.loads(schema_str)\n\n    lines = []\n\n    fields = schema.get(\"fields\")\n    if not fields:\n        return str(schema)\n\n    for i, field in enumerate(fields):\n        name = field.get(\"name\", \"unknown\")\n        type_info = field.get(\"type\")\n        nullable = field.get(\"nullable\", True)\n\n        is_last = i == len(fields) - 1\n        connector = \"\u2514\u2500\" if is_last else \"\u251c\u2500\"\n\n        type_str = \"\"\n        if isinstance(type_info, str):\n            type_str = type_info\n        elif isinstance(type_info, dict):\n            # TODO enhance this\n            type_str = type_info.get(\"type\", \"complex\")\n            if type_str == \"struct\":\n                type_str = \"struct&lt;...&gt;\"\n            elif type_str == \"array\":\n                type_str = \"array&lt;...&gt;\"\n            elif type_str == \"map\":\n                type_str = \"map&lt;...&gt;\"\n\n        metadata = field.get(\"metadata\", {})\n        meta_str = f\" (metadata: {metadata})\" if metadata else \"\"\n        nullable_str = \"[dim] (nullable)[/dim]\" if nullable else \"\"\n        lines.append(\n            f\"{prefix}{connector} [bold cyan]{name}[/bold cyan]: {type_str}\"\n            f\"{nullable_str}{meta_str}\"\n        )\n\n        # recursively format struct fields is tricky with JSON string passed down\n        # simpler to just show it as struct&lt;...&gt; for now or serialize subsection\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/history/#tangram_history.cli.ls","title":"ls","text":"<pre><code>ls(\n    config: PathTangramConfig,\n    show_schema: bool = True,\n    force_offline: ForceOffline = False,\n) -&gt; None\n</code></pre> <p>List all history tables found in the configured storage directory.</p> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>@app.command()\ndef ls(\n    config: PathTangramConfig,\n    show_schema: bool = True,\n    force_offline: ForceOffline = False,\n) -&gt; None:\n    \"\"\"List all history tables found in the configured storage directory.\"\"\"\n    from . import _history\n\n    cfg = parse_config(config)\n    status = get_service_status(\n        cfg.config.core.redis_url, cfg.history_config.control_channel\n    )\n\n    tables: list[_history.TableInfo] = []\n    if status == HistoryStatus.HAS_SUBSCRIBERS:\n        sender_id = str(uuid.uuid4())\n        msg = _history.ControlMessage.ListTables(sender_id).to_json_bytes()\n        if response := send_command(\n            cfg, sender_id, msg, _history.ControlResponse, timeout=2\n        ):\n            if isinstance(response, _history.ControlResponse.TableList):\n                tables = response.tables\n            elif isinstance(response, _history.ControlResponse.CommandFailed):\n                print_error(f\"list tables failed: {response.error}\")\n            else:\n                print_error(f\"unexpected response: {response}\")\n        else:\n            print_warning(\"service appeared online but did not respond, trying offline\")\n            status = HistoryStatus.REDIS_OFFLINE\n\n    if force_offline or status != HistoryStatus.HAS_SUBSCRIBERS:\n        base_path = str(cfg.history_config.base_path)\n        if not force_offline:\n            print_note(f\"{status.to_message()}, listing tables in {base_path}\")\n\n        tables = _history.list_tables_offline(base_path)\n\n    for t in tables:\n        console.print(f\"{t.name} @ {t.uri} (version {t.version})\")\n        if show_schema:\n            console.print(format_schema(t.schema))\n</code></pre>"},{"location":"api/history/#tangram_history.cli.rm","title":"rm","text":"<pre><code>rm(table_name: Annotated[str, Argument(help='Name of the history table.')], predicate: Annotated[str, Argument(help=f'DataFusion SQL condition for rows to delete. \"\nExamples: \"timestamp &lt; '{yesterday}'\", \"df == 17\", \"altitude &gt; 54000 OR altitude &lt; 0\".\nSee: &lt;https://datafusion.apache.org/user-guide/sql/index.html&gt;')], config: PathTangramConfig, dry_run: Annotated[bool, Option(--dry - run, help='Perform a dry run only (skip execution).')] = False, force_offline: ForceOffline = False) -&gt; None\n</code></pre> <p>Delete rows from a history table based on a condition.</p> <p>Queries the count and preview using datafusion <code>SessionContext</code>. If the tangram service is online, the service acquires a write lock and acquires semaphores for optimisation/vaccuming before execution.</p> Source code in <code>packages/tangram_history/src/tangram_history/cli.py</code> <pre><code>@app.command()\ndef rm(\n    table_name: Annotated[str, typer.Argument(help=\"Name of the history table.\")],\n    predicate: Annotated[\n        str,\n        typer.Argument(\n            help=f\"\"\"DataFusion SQL condition for rows to delete. \"\nExamples: \"timestamp &lt; \\'{yesterday}\\'\", \"df == 17\", \"altitude &gt; 54000 OR altitude &lt; 0\".\nSee: &lt;https://datafusion.apache.org/user-guide/sql/index.html&gt;\"\"\"\n        ),\n    ],\n    config: PathTangramConfig,\n    dry_run: Annotated[\n        bool,\n        typer.Option(\"--dry-run\", help=\"Perform a dry run only (skip execution).\"),\n    ] = False,\n    force_offline: ForceOffline = False,\n) -&gt; None:\n    \"\"\"Delete rows from a history table based on a condition.\n\n    Queries the count and preview using datafusion `SessionContext`.\n    If the tangram service is online, the service acquires a write lock and\n    acquires semaphores for optimisation/vaccuming before execution.\n    \"\"\"\n    from . import _history\n\n    cfg = parse_config(config)\n    status = get_service_status(\n        cfg.config.core.redis_url, cfg.history_config.control_channel\n    )\n\n    with console.status(\"analyzing delete impact...\"):\n        if not force_offline and status == HistoryStatus.HAS_SUBSCRIBERS:\n            sender_id = str(uuid.uuid4())\n            msg = _history.ControlMessage.DeleteRows(\n                sender_id, table_name, predicate, dry_run=True\n            ).to_json_bytes()\n            response = send_command(cfg, sender_id, msg, _history.ControlResponse)\n            if not response:\n                print_error(\"failed to get response from history service\")\n                raise typer.Exit(1)\n        else:\n            if not force_offline:\n                print_note(f\"{status.to_message()}, assuming exclusive access of table\")\n            response = _history.delete_rows_offline(\n                base_path=str(cfg.history_config.base_path),\n                table_name=table_name,\n                predicate=predicate,\n                dry_run=True,\n            )\n\n    if isinstance(response, _history.ControlResponse.CommandFailed):\n        print_error(f\"analysis failed: {response.error}\")\n        raise typer.Exit(1)\n\n    if not isinstance(response, _history.ControlResponse.DeleteOutput):\n        print_error(f\"unexpected response: {response}\")\n        raise typer.Exit(1)\n\n    count = response.affected_rows\n\n    if count == 0:\n        console.print(\"no rows matched the predicate.\")\n        return\n    print_note(f\"predicate matched [bold]{count}[/bold] rows\")\n    if preview_json := response.preview:\n        rows = orjson.loads(preview_json)\n        if rows:\n            console.print(\"preview of rows to be deleted:\")\n            table_preview = Table(show_header=True)\n            for key in rows[0].keys():\n                table_preview.add_column(key)\n            for row in rows:\n                table_preview.add_row(*[str(row.get(k)) for k in rows[0].keys()])\n            console.print(table_preview)\n\n    if dry_run:\n        return\n\n    if not typer.confirm(\"are you sure?\"):\n        raise typer.Abort()\n\n    time_start = time.perf_counter()\n    with console.status(\"deleting...\"):\n        if not force_offline and status == HistoryStatus.HAS_SUBSCRIBERS:\n            sender_id = str(uuid.uuid4())\n            msg = _history.ControlMessage.DeleteRows(\n                sender_id, table_name, predicate, dry_run=False\n            ).to_json_bytes()\n            exec_response = send_command(\n                cfg, sender_id, msg, _history.ControlResponse, timeout=300\n            )\n            if not exec_response:\n                print_error(\"timed out waiting for delete confirmation.\")\n                raise typer.Exit(1)\n        else:\n            exec_response = _history.delete_rows_offline(\n                base_path=str(cfg.history_config.base_path),\n                table_name=table_name,\n                predicate=predicate,\n                dry_run=False,\n            )\n\n    if isinstance(exec_response, _history.ControlResponse.CommandFailed):\n        print_error(f\"delete failed: {exec_response.error}\")\n        raise typer.Exit(1)\n    if not isinstance(exec_response, _history.ControlResponse.DeleteOutput):\n        print_error(f\"unexpected response: {exec_response}\")\n        raise typer.Exit(1)\n    deleted = exec_response.affected_rows\n    console.print(\n        f\"[bold green]success:[/bold green] deleted {deleted} rows from '{table_name}'\"\n        f\" in [bold]{time.perf_counter() - time_start:.2f} seconds[/bold].\"\n    )\n</code></pre>"},{"location":"api/history/#tangram_history.config","title":"config","text":""},{"location":"api/history/#tangram_history.config.HistoryConfig","title":"HistoryConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_history/src/tangram_history/config.py</code> <pre><code>@dataclass(frozen=True)\nclass HistoryConfig:\n    control_channel: str = \"history:control\"\n    base_path: Path = Path(platformdirs.user_cache_dir(\"tangram_history\"))\n    log_level: str = \"INFO\"\n    redis_read_count: int = 1000\n    redis_read_block_ms: int = 5000\n</code></pre>"},{"location":"api/history/#tangram_history.config.HistoryConfig.control_channel","title":"control_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>control_channel: str = 'history:control'\n</code></pre>"},{"location":"api/history/#tangram_history.config.HistoryConfig.base_path","title":"base_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>base_path: Path = Path(user_cache_dir('tangram_history'))\n</code></pre>"},{"location":"api/history/#tangram_history.config.HistoryConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level: str = 'INFO'\n</code></pre>"},{"location":"api/history/#tangram_history.config.HistoryConfig.redis_read_count","title":"redis_read_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis_read_count: int = 1000\n</code></pre>"},{"location":"api/history/#tangram_history.config.HistoryConfig.redis_read_block_ms","title":"redis_read_block_ms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis_read_block_ms: int = 5000\n</code></pre>"},{"location":"api/history/#tangram_history.config.HistoryConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    control_channel: str = \"history:control\",\n    base_path: Path = Path(\n        user_cache_dir(\"tangram_history\")\n    ),\n    log_level: str = \"INFO\",\n    redis_read_count: int = 1000,\n    redis_read_block_ms: int = 5000,\n) -&gt; None\n</code></pre>"},{"location":"api/history/#tangram_history._history","title":"tangram_history._history","text":""},{"location":"api/history/#tangram_history._history.ControlMessage","title":"ControlMessage","text":""},{"location":"api/history/#tangram_history._history.ControlMessage.Ping","title":"Ping","text":"<p>               Bases: <code>ControlMessage</code></p>"},{"location":"api/history/#tangram_history._history.ControlMessage.Ping.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('sender',)\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.Ping.sender","title":"sender  <code>property</code>","text":"<pre><code>sender: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.Ping.__new__","title":"__new__","text":"<pre><code>__new__(sender: str) -&gt; Ping\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.RegisterTable","title":"RegisterTable","text":"<p>               Bases: <code>ControlMessage</code></p>"},{"location":"api/history/#tangram_history._history.ControlMessage.RegisterTable.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0',)\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.RegisterTable.__new__","title":"__new__","text":"<pre><code>__new__(_0: RegisterTable) -&gt; RegisterTable\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.RegisterTable.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.RegisterTable.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: int) -&gt; Any\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.ListTables","title":"ListTables","text":"<p>               Bases: <code>ControlMessage</code></p>"},{"location":"api/history/#tangram_history._history.ControlMessage.ListTables.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('sender_id',)\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.ListTables.sender_id","title":"sender_id  <code>property</code>","text":"<pre><code>sender_id: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.ListTables.__new__","title":"__new__","text":"<pre><code>__new__(sender_id: str) -&gt; ListTables\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.DeleteRows","title":"DeleteRows","text":"<p>               Bases: <code>ControlMessage</code></p> <p>Deletes rows in a table using with a specified predicate.</p> <p>WARNING:</p> <p>The current implementation uses raw string formatting to query row counts and previews, with the following SQL operations disallowed</p> <ul> <li>DDL</li> <li>DML</li> <li>Statements</li> </ul> <p>It may be prone to SQL injection.</p>"},{"location":"api/history/#tangram_history._history.ControlMessage.DeleteRows.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = (\n    \"sender_id\",\n    \"table_name\",\n    \"predicate\",\n    \"dry_run\",\n)\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.DeleteRows.sender_id","title":"sender_id  <code>property</code>","text":"<pre><code>sender_id: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.DeleteRows.table_name","title":"table_name  <code>property</code>","text":"<pre><code>table_name: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.DeleteRows.predicate","title":"predicate  <code>property</code>","text":"<pre><code>predicate: str\n</code></pre> <p>The predicate expression, which must have Boolean type</p> <p>See: https://docs.rs/datafusion/latest/datafusion/logical_expr/enum.Expr.html</p>"},{"location":"api/history/#tangram_history._history.ControlMessage.DeleteRows.dry_run","title":"dry_run  <code>property</code>","text":"<pre><code>dry_run: bool\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.DeleteRows.__new__","title":"__new__","text":"<pre><code>__new__(\n    sender_id: str,\n    table_name: str,\n    predicate: str,\n    dry_run: bool,\n) -&gt; DeleteRows\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.from_json_bytes","title":"from_json_bytes  <code>staticmethod</code>","text":"<pre><code>from_json_bytes(data: bytes) -&gt; ControlMessage\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlMessage.to_json_bytes","title":"to_json_bytes","text":"<pre><code>to_json_bytes() -&gt; bytes\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse","title":"ControlResponse","text":""},{"location":"api/history/#tangram_history._history.ControlResponse.TableRegistered","title":"TableRegistered","text":"<p>               Bases: <code>ControlResponse</code></p>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableRegistered.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('request_id', 'table_name', 'table_uri')\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableRegistered.request_id","title":"request_id  <code>property</code>","text":"<pre><code>request_id: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableRegistered.table_name","title":"table_name  <code>property</code>","text":"<pre><code>table_name: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableRegistered.table_uri","title":"table_uri  <code>property</code>","text":"<pre><code>table_uri: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableRegistered.__new__","title":"__new__","text":"<pre><code>__new__(\n    request_id: str, table_name: str, table_uri: str\n) -&gt; TableRegistered\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.RegistrationFailed","title":"RegistrationFailed","text":"<p>               Bases: <code>ControlResponse</code></p>"},{"location":"api/history/#tangram_history._history.ControlResponse.RegistrationFailed.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('request_id', 'table_name', 'error')\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.RegistrationFailed.request_id","title":"request_id  <code>property</code>","text":"<pre><code>request_id: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.RegistrationFailed.table_name","title":"table_name  <code>property</code>","text":"<pre><code>table_name: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.RegistrationFailed.error","title":"error  <code>property</code>","text":"<pre><code>error: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.RegistrationFailed.__new__","title":"__new__","text":"<pre><code>__new__(\n    request_id: str, table_name: str, error: str\n) -&gt; RegistrationFailed\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.Pong","title":"Pong","text":"<p>               Bases: <code>ControlResponse</code></p>"},{"location":"api/history/#tangram_history._history.ControlResponse.Pong.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('sender',)\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.Pong.sender","title":"sender  <code>property</code>","text":"<pre><code>sender: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.Pong.__new__","title":"__new__","text":"<pre><code>__new__(sender: str) -&gt; Pong\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableList","title":"TableList","text":"<p>               Bases: <code>ControlResponse</code></p>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableList.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('request_id', 'tables')\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableList.request_id","title":"request_id  <code>property</code>","text":"<pre><code>request_id: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableList.tables","title":"tables  <code>property</code>","text":"<pre><code>tables: list[TableInfo]\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.TableList.__new__","title":"__new__","text":"<pre><code>__new__(\n    request_id: str, tables: Sequence[TableInfo]\n) -&gt; TableList\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.DeleteOutput","title":"DeleteOutput","text":"<p>               Bases: <code>ControlResponse</code></p> <p>Successful delete response with affected row count and optional preview.</p>"},{"location":"api/history/#tangram_history._history.ControlResponse.DeleteOutput.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = (\n    \"request_id\",\n    \"dry_run\",\n    \"affected_rows\",\n    \"preview\",\n)\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.DeleteOutput.request_id","title":"request_id  <code>property</code>","text":"<pre><code>request_id: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.DeleteOutput.dry_run","title":"dry_run  <code>property</code>","text":"<pre><code>dry_run: bool\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.DeleteOutput.affected_rows","title":"affected_rows  <code>property</code>","text":"<pre><code>affected_rows: int\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.DeleteOutput.preview","title":"preview  <code>property</code>","text":"<pre><code>preview: Optional[str]\n</code></pre> <p>JSON string of RecordBatch</p>"},{"location":"api/history/#tangram_history._history.ControlResponse.DeleteOutput.__new__","title":"__new__","text":"<pre><code>__new__(\n    request_id: str,\n    dry_run: bool,\n    affected_rows: int,\n    preview: Optional[str],\n) -&gt; DeleteOutput\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.CommandFailed","title":"CommandFailed","text":"<p>               Bases: <code>ControlResponse</code></p> <p>Returned when a control command fails; contains the error message.</p>"},{"location":"api/history/#tangram_history._history.ControlResponse.CommandFailed.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('request_id', 'error')\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.CommandFailed.request_id","title":"request_id  <code>property</code>","text":"<pre><code>request_id: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.CommandFailed.error","title":"error  <code>property</code>","text":"<pre><code>error: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.CommandFailed.__new__","title":"__new__","text":"<pre><code>__new__(request_id: str, error: str) -&gt; CommandFailed\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.from_json_bytes","title":"from_json_bytes  <code>staticmethod</code>","text":"<pre><code>from_json_bytes(data: bytes) -&gt; ControlResponse\n</code></pre>"},{"location":"api/history/#tangram_history._history.ControlResponse.to_json_bytes","title":"to_json_bytes","text":"<pre><code>to_json_bytes() -&gt; bytes\n</code></pre>"},{"location":"api/history/#tangram_history._history.HistoryConfig","title":"HistoryConfig","text":""},{"location":"api/history/#tangram_history._history.HistoryConfig.redis_url","title":"redis_url  <code>property</code> <code>writable</code>","text":"<pre><code>redis_url: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.HistoryConfig.control_channel","title":"control_channel  <code>property</code> <code>writable</code>","text":"<pre><code>control_channel: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.HistoryConfig.base_path","title":"base_path  <code>property</code> <code>writable</code>","text":"<pre><code>base_path: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.HistoryConfig.redis_read_count","title":"redis_read_count  <code>property</code> <code>writable</code>","text":"<pre><code>redis_read_count: int\n</code></pre>"},{"location":"api/history/#tangram_history._history.HistoryConfig.redis_read_block_ms","title":"redis_read_block_ms  <code>property</code> <code>writable</code>","text":"<pre><code>redis_read_block_ms: int\n</code></pre>"},{"location":"api/history/#tangram_history._history.HistoryConfig.__new__","title":"__new__","text":"<pre><code>__new__(\n    redis_url: str,\n    control_channel: str,\n    base_path: str,\n    redis_read_count: int,\n    redis_read_block_ms: int,\n) -&gt; HistoryConfig\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable","title":"RegisterTable","text":""},{"location":"api/history/#tangram_history._history.RegisterTable.sender_id","title":"sender_id  <code>property</code> <code>writable</code>","text":"<pre><code>sender_id: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.table_name","title":"table_name  <code>property</code> <code>writable</code>","text":"<pre><code>table_name: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.schema","title":"schema  <code>property</code> <code>writable</code>","text":"<pre><code>schema: str\n</code></pre> <p>Base64 encoded arrow ipc schema format</p>"},{"location":"api/history/#tangram_history._history.RegisterTable.partition_columns","title":"partition_columns  <code>property</code> <code>writable</code>","text":"<pre><code>partition_columns: list[str]\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.optimize_interval_secs","title":"optimize_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>optimize_interval_secs: int\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.optimize_target_file_size","title":"optimize_target_file_size  <code>property</code> <code>writable</code>","text":"<pre><code>optimize_target_file_size: int\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.vacuum_interval_secs","title":"vacuum_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>vacuum_interval_secs: int\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.vacuum_retention_period_secs","title":"vacuum_retention_period_secs  <code>property</code> <code>writable</code>","text":"<pre><code>vacuum_retention_period_secs: Optional[int]\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.checkpoint_interval","title":"checkpoint_interval  <code>property</code> <code>writable</code>","text":"<pre><code>checkpoint_interval: int\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.from_json_bytes","title":"from_json_bytes  <code>staticmethod</code>","text":"<pre><code>from_json_bytes(data: bytes) -&gt; RegisterTable\n</code></pre>"},{"location":"api/history/#tangram_history._history.RegisterTable.to_json_bytes","title":"to_json_bytes","text":"<pre><code>to_json_bytes() -&gt; bytes\n</code></pre>"},{"location":"api/history/#tangram_history._history.TableInfo","title":"TableInfo","text":""},{"location":"api/history/#tangram_history._history.TableInfo.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.TableInfo.uri","title":"uri  <code>property</code> <code>writable</code>","text":"<pre><code>uri: str\n</code></pre>"},{"location":"api/history/#tangram_history._history.TableInfo.version","title":"version  <code>property</code> <code>writable</code>","text":"<pre><code>version: int\n</code></pre>"},{"location":"api/history/#tangram_history._history.TableInfo.schema","title":"schema  <code>property</code> <code>writable</code>","text":"<pre><code>schema: str\n</code></pre> <p>Serialised JSON schema</p>"},{"location":"api/history/#tangram_history._history.TableInfo.from_json_bytes","title":"from_json_bytes  <code>staticmethod</code>","text":"<pre><code>from_json_bytes(data: bytes) -&gt; TableInfo\n</code></pre>"},{"location":"api/history/#tangram_history._history.TableInfo.to_json_bytes","title":"to_json_bytes","text":"<pre><code>to_json_bytes() -&gt; bytes\n</code></pre>"},{"location":"api/history/#tangram_history._history.delete_rows_offline","title":"delete_rows_offline","text":"<pre><code>delete_rows_offline(\n    base_path: str,\n    table_name: str,\n    predicate: str,\n    dry_run: bool,\n) -&gt; ControlResponse\n</code></pre> <p>Delete rows from a history table stored on disk.</p> <p>Returns:</p> Type Description <code>ControlResponse</code> <p>ControlResponse.DeleteOutput on success, ControlResponse.CommandFailed on failure.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>if the table does not exist or filesystem access fails.</p>"},{"location":"api/history/#tangram_history._history.init_tracing_stderr","title":"init_tracing_stderr","text":"<pre><code>init_tracing_stderr(filter_str: str) -&gt; None\n</code></pre>"},{"location":"api/history/#tangram_history._history.list_tables_offline","title":"list_tables_offline","text":"<pre><code>list_tables_offline(base_path: str) -&gt; list[TableInfo]\n</code></pre> <p>List history tables by inspecting the on-disk Delta Lake directory.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>if the table does not exist or filesystem access fails.</p>"},{"location":"api/history/#tangram_history._history.run_history","title":"run_history","text":"<pre><code>run_history(config: HistoryConfig) -&gt; Any\n</code></pre> <p>Start the history ingest service.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the service fails to start or crashes.</p>"},{"location":"api/jet1090/","title":"Jet1090","text":""},{"location":"api/jet1090/#tangram_jet1090","title":"tangram_jet1090","text":""},{"location":"api/jet1090/#tangram_jet1090.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix=\"/jet1090\",\n    tags=[\"jet1090\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\",\n    routers=[router],\n    config_class=PlanesConfig,\n    frontend_config_class=PlanesFrontendConfig,\n    into_frontend_config_function=into_frontend,\n)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.TrailColorOptions","title":"TrailColorOptions  <code>dataclass</code>","text":"Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass TrailColorOptions:\n    by_attribute: Annotated[\n        Literal[\"altitude\", \"groundspeed\", \"vertical_rate\", \"track\"],\n        FrontendMutable(),\n    ] = \"altitude\"\n    min: Annotated[float, FrontendMutable()] = 0.0\n    max: Annotated[float, FrontendMutable()] = 45000.0\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.TrailColorOptions.by_attribute","title":"by_attribute  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>by_attribute: Annotated[\n    Literal[\n        \"altitude\", \"groundspeed\", \"vertical_rate\", \"track\"\n    ],\n    FrontendMutable(),\n] = \"altitude\"\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.TrailColorOptions.min","title":"min  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min: Annotated[float, FrontendMutable()] = 0.0\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.TrailColorOptions.max","title":"max  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max: Annotated[float, FrontendMutable()] = 45000.0\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.TrailColorOptions.__init__","title":"__init__","text":"<pre><code>__init__(\n    by_attribute: Annotated[\n        Literal[\n            \"altitude\",\n            \"groundspeed\",\n            \"vertical_rate\",\n            \"track\",\n        ],\n        FrontendMutable(),\n    ] = \"altitude\",\n    min: Annotated[float, FrontendMutable()] = 0.0,\n    max: Annotated[float, FrontendMutable()] = 45000.0,\n) -&gt; None\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig","title":"PlanesConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass PlanesConfig:\n    jet1090_channel: str = \"jet1090\"\n    history_table_name: str = \"jet1090\"\n    history_control_channel: str = \"history:control\"\n    search_channel: str = \"jet1090:search\"\n    state_vector_expire: int = 20\n    stream_interval_secs: float = 1.0\n    aircraft_db_url: str = (\n        \"https://jetvision.de/resources/sqb_databases/basestation.zip\"\n    )\n    jet1090_url: str = \"http://localhost:8080\"\n    path_cache: Path = Path(platformdirs.user_cache_dir(\"tangram_jet1090\"))\n    log_level: str = \"INFO\"\n    show_route_lines: bool = True\n    history_buffer_size: int = 100_000\n    history_flush_interval_secs: int = 5\n    history_optimize_interval_secs: int = 120\n    history_optimize_target_file_size: int = 134217728\n    history_vacuum_interval_secs: int = 120\n    history_vacuum_retention_period_secs: int | None = 120\n    history_checkpoint_interval: int = 10\n    topbar_order: int = 50\n    sidebar_order: int = 50\n    trail_type: Literal[\"line\", \"curtain\"] = \"line\"\n    trail_color: str | TrailColorOptions = \"#600000\"\n    trail_alpha: float = 0.6\n    enable_3d: bool = False\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.jet1090_channel","title":"jet1090_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jet1090_channel: str = 'jet1090'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_table_name","title":"history_table_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_table_name: str = 'jet1090'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_control_channel","title":"history_control_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_control_channel: str = 'history:control'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.search_channel","title":"search_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>search_channel: str = 'jet1090:search'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.state_vector_expire","title":"state_vector_expire  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state_vector_expire: int = 20\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.stream_interval_secs","title":"stream_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stream_interval_secs: float = 1.0\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.aircraft_db_url","title":"aircraft_db_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aircraft_db_url: str = \"https://jetvision.de/resources/sqb_databases/basestation.zip\"\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.jet1090_url","title":"jet1090_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jet1090_url: str = 'http://localhost:8080'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.path_cache","title":"path_cache  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path_cache: Path = Path(user_cache_dir('tangram_jet1090'))\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level: str = 'INFO'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.show_route_lines","title":"show_route_lines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_route_lines: bool = True\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_buffer_size","title":"history_buffer_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_buffer_size: int = 100000\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_flush_interval_secs","title":"history_flush_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_flush_interval_secs: int = 5\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_optimize_interval_secs","title":"history_optimize_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_optimize_interval_secs: int = 120\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_optimize_target_file_size","title":"history_optimize_target_file_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_optimize_target_file_size: int = 134217728\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_vacuum_interval_secs","title":"history_vacuum_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_vacuum_interval_secs: int = 120\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_vacuum_retention_period_secs","title":"history_vacuum_retention_period_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_vacuum_retention_period_secs: int | None = 120\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.history_checkpoint_interval","title":"history_checkpoint_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_checkpoint_interval: int = 10\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.topbar_order","title":"topbar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topbar_order: int = 50\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.sidebar_order","title":"sidebar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int = 50\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.trail_type","title":"trail_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trail_type: Literal['line', 'curtain'] = 'line'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.trail_color","title":"trail_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trail_color: str | TrailColorOptions = '#600000'\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.trail_alpha","title":"trail_alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trail_alpha: float = 0.6\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.enable_3d","title":"enable_3d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_3d: bool = False\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    jet1090_channel: str = \"jet1090\",\n    history_table_name: str = \"jet1090\",\n    history_control_channel: str = \"history:control\",\n    search_channel: str = \"jet1090:search\",\n    state_vector_expire: int = 20,\n    stream_interval_secs: float = 1.0,\n    aircraft_db_url: str = \"https://jetvision.de/resources/sqb_databases/basestation.zip\",\n    jet1090_url: str = \"http://localhost:8080\",\n    path_cache: Path = Path(\n        user_cache_dir(\"tangram_jet1090\")\n    ),\n    log_level: str = \"INFO\",\n    show_route_lines: bool = True,\n    history_buffer_size: int = 100000,\n    history_flush_interval_secs: int = 5,\n    history_optimize_interval_secs: int = 120,\n    history_optimize_target_file_size: int = 134217728,\n    history_vacuum_interval_secs: int = 120,\n    history_vacuum_retention_period_secs: int | None = 120,\n    history_checkpoint_interval: int = 10,\n    topbar_order: int = 50,\n    sidebar_order: int = 50,\n    trail_type: Literal[\"line\", \"curtain\"] = \"line\",\n    trail_color: str | TrailColorOptions = \"#600000\",\n    trail_alpha: float = 0.6,\n    enable_3d: bool = False,\n) -&gt; None\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig","title":"PlanesFrontendConfig  <code>dataclass</code>","text":"<p>               Bases: <code>HasTopbarUiConfig</code>, <code>HasSidebarUiConfig</code></p> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass PlanesFrontendConfig(\n    tangram_core.config.HasTopbarUiConfig, tangram_core.config.HasSidebarUiConfig\n):\n    search_channel: str\n    show_route_lines: Annotated[bool, FrontendMutable()]\n    topbar_order: Annotated[int, FrontendMutable()]\n    sidebar_order: Annotated[int, FrontendMutable()]\n    trail_type: Annotated[Literal[\"line\", \"curtain\"], FrontendMutable()]\n    trail_color: Annotated[str, FrontendMutable(kind=\"color\")] | TrailColorOptions\n    trail_alpha: Annotated[float, Ge(0), Le(1), FrontendMutable()]\n    enable_3d: Annotated[bool, FrontendMutable()]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.search_channel","title":"search_channel  <code>instance-attribute</code>","text":"<pre><code>search_channel: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.show_route_lines","title":"show_route_lines  <code>instance-attribute</code>","text":"<pre><code>show_route_lines: Annotated[bool, FrontendMutable()]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.topbar_order","title":"topbar_order  <code>instance-attribute</code>","text":"<pre><code>topbar_order: Annotated[int, FrontendMutable()]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.sidebar_order","title":"sidebar_order  <code>instance-attribute</code>","text":"<pre><code>sidebar_order: Annotated[int, FrontendMutable()]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.trail_type","title":"trail_type  <code>instance-attribute</code>","text":"<pre><code>trail_type: Annotated[\n    Literal[\"line\", \"curtain\"], FrontendMutable()\n]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.trail_color","title":"trail_color  <code>instance-attribute</code>","text":"<pre><code>trail_color: (\n    Annotated[str, FrontendMutable(kind=\"color\")]\n    | TrailColorOptions\n)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.trail_alpha","title":"trail_alpha  <code>instance-attribute</code>","text":"<pre><code>trail_alpha: Annotated[\n    float, Ge(0), Le(1), FrontendMutable()\n]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.enable_3d","title":"enable_3d  <code>instance-attribute</code>","text":"<pre><code>enable_3d: Annotated[bool, FrontendMutable()]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.PlanesFrontendConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    search_channel: str,\n    show_route_lines: Annotated[bool, FrontendMutable()],\n    topbar_order: Annotated[int, FrontendMutable()],\n    sidebar_order: Annotated[int, FrontendMutable()],\n    trail_type: Annotated[\n        Literal[\"line\", \"curtain\"], FrontendMutable()\n    ],\n    trail_color: Annotated[\n        str, FrontendMutable(kind=\"color\")\n    ]\n    | TrailColorOptions,\n    trail_alpha: Annotated[\n        float, Ge(0), Le(1), FrontendMutable()\n    ],\n    enable_3d: Annotated[bool, FrontendMutable()],\n) -&gt; None\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_trajectory_data","title":"get_trajectory_data  <code>async</code>","text":"<pre><code>get_trajectory_data(\n    icao24: str, backend_state: InjectBackendState\n) -&gt; Response\n</code></pre> <p>Get the full trajectory for a given ICAO24 address.</p> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@router.get(\"/data/{icao24}\")\nasync def get_trajectory_data(\n    icao24: str, backend_state: tangram_core.InjectBackendState\n) -&gt; Response:\n    \"\"\"Get the full trajectory for a given ICAO24 address.\"\"\"\n    if not _HISTORY_AVAILABLE:\n        raise HTTPException(\n            status_code=501,\n            detail=\"History feature is not installed.\",\n        )\n\n    redis_key = \"tangram:history:table_uri:jet1090\"\n    table_uri_bytes = await backend_state.redis_client.get(redis_key)\n\n    if not table_uri_bytes:\n        raise HTTPException(status_code=404, detail=\"Table 'jet1090' not found.\")\n    table_uri = table_uri_bytes.decode(\"utf-8\")\n\n    try:\n        df = (\n            pl.scan_delta(table_uri)\n            .filter(pl.col(\"icao24\") == icao24)\n            .with_columns(pl.col(\"timestamp\").dt.epoch(time_unit=\"us\") / 1000000)\n            .sort(\"timestamp\")\n            .collect()\n        )\n        return Response(df.write_json(), media_type=\"application/json\")\n    except Exception as e:\n        log.error(f\"Failed to query trajectory for {icao24}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to query trajectory data.\")\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.search_flights","title":"search_flights  <code>async</code>","text":"<pre><code>search_flights(\n    q: str, backend_state: InjectBackendState\n) -&gt; Response\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@router.get(\"/search\")\nasync def search_flights(\n    q: str, backend_state: tangram_core.InjectBackendState\n) -&gt; Response:\n    if not _HISTORY_AVAILABLE:\n        return ORJSONResponse(content=[])\n\n    redis_key = \"tangram:history:table_uri:jet1090\"\n    table_uri_bytes = await backend_state.redis_client.get(redis_key)\n    if not table_uri_bytes:\n        return ORJSONResponse(content=[])\n    table_uri = table_uri_bytes.decode(\"utf-8\")\n\n    try:\n        df = pl.scan_delta(table_uri)\n        q_lower = q.lower()\n\n        candidates = (\n            df.filter(\n                pl.col(\"callsign\").str.to_lowercase().str.contains(q_lower)\n                | pl.col(\"icao24\").str.contains(q_lower)\n            )\n            .select(\"icao24\")\n            .unique()\n            .head(20)\n            .collect()\n        )\n        candidate_icaos = candidates[\"icao24\"].to_list()\n\n        if not candidate_icaos:\n            return ORJSONResponse(content=[])\n\n        intervals = (\n            df.filter(pl.col(\"icao24\").is_in(candidate_icaos))\n            .sort([\"icao24\", \"timestamp\"])\n            .with_columns(pl.col(\"callsign\").forward_fill().over(\"icao24\"))\n            .with_columns(\n                gap_minutes=(\n                    pl.col(\"timestamp\") - pl.col(\"timestamp\").shift(1)\n                ).dt.total_minutes()\n            )\n            .with_columns(\n                new_interval=(\n                    (pl.col(\"gap_minutes\") &gt;= 30)\n                    | (pl.col(\"icao24\") != pl.col(\"icao24\").shift(1))\n                    | (pl.col(\"callsign\") != pl.col(\"callsign\").shift(1))\n                ).fill_null(True)\n            )\n            .with_columns(interval_id=pl.col(\"new_interval\").cast(pl.Int64).cum_sum())\n            .group_by([\"icao24\", \"callsign\", \"interval_id\"])\n            .agg(\n                start_ts=pl.col(\"timestamp\").min(),\n                end_ts=pl.col(\"timestamp\").max(),\n                n_rows=pl.len(),\n                lat=pl.col(\"latitude\").mean(),\n                lon=pl.col(\"longitude\").mean(),\n            )\n            .filter(\n                (pl.col(\"n_rows\") &gt;= 5)\n                &amp; (\n                    pl.col(\"callsign\").str.to_lowercase().str.contains(q_lower)\n                    | pl.col(\"icao24\").str.contains(q_lower)\n                )\n            )\n            .with_columns(\n                duration=((pl.col(\"end_ts\") - pl.col(\"start_ts\")).dt.total_seconds()),\n            )\n            .sort([\"start_ts\"], descending=True)\n            .collect()\n        )\n        return Response(intervals.write_json(), media_type=\"application/json\")\n    except Exception as e:\n        log.error(f\"Search failed: {e}\")\n        return ORJSONResponse(content=[])\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_history_slice","title":"get_history_slice  <code>async</code>","text":"<pre><code>get_history_slice(\n    icao24: str,\n    start_timestamp: int,\n    end_timestamp: int,\n    backend_state: InjectBackendState,\n) -&gt; Response\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@router.get(\"/history/{icao24}/{start_timestamp}/{end_timestamp}\")\nasync def get_history_slice(\n    icao24: str,\n    start_timestamp: int,\n    end_timestamp: int,\n    backend_state: tangram_core.InjectBackendState,\n) -&gt; Response:\n    if not _HISTORY_AVAILABLE:\n        return ORJSONResponse(content=[])\n\n    redis_key = \"tangram:history:table_uri:jet1090\"\n    table_uri_bytes = await backend_state.redis_client.get(redis_key)\n    if not table_uri_bytes:\n        return ORJSONResponse(content=[])\n    table_uri = table_uri_bytes.decode(\"utf-8\")\n\n    start_dt = pl.lit(start_timestamp).cast(pl.Datetime(\"ms\"))\n    end_dt = pl.lit(end_timestamp).cast(pl.Datetime(\"ms\"))\n\n    try:\n        df = (\n            pl.scan_delta(table_uri)\n            .filter(\n                (pl.col(\"icao24\") == icao24)\n                &amp; (pl.col(\"timestamp\") &gt;= start_dt)\n                &amp; (pl.col(\"timestamp\") &lt;= end_dt)\n            )\n            .sort(\"timestamp\")\n            .collect()\n        )\n        return Response(df.write_json(), media_type=\"application/json\")\n    except Exception as e:\n        log.error(f\"History slice failed: {e}\")\n        return ORJSONResponse(content=[])\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_route_data","title":"get_route_data  <code>async</code>","text":"<pre><code>get_route_data(\n    callsign: str, backend_state: InjectBackendState\n) -&gt; ORJSONResponse\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@router.get(\"/route/{callsign}\")\nasync def get_route_data(\n    callsign: str, backend_state: tangram_core.InjectBackendState\n) -&gt; ORJSONResponse:\n    url = \"https://flightroutes.opensky-network.org/api/routeset\"\n    payload = {\"planes\": [{\"callsign\": callsign}]}\n    client = backend_state.http_client\n    try:\n        response = await client.post(url, json=payload, timeout=5.0)\n        response.raise_for_status()\n        data = response.json()\n        return ORJSONResponse(content=data)\n    except Exception as e:\n        log.error(f\"Failed to fetch route data for {callsign}: {e}\")\n        return ORJSONResponse(content=[], status_code=500)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_sensors_data","title":"get_sensors_data  <code>async</code>","text":"<pre><code>get_sensors_data(\n    backend_state: InjectBackendState,\n) -&gt; ORJSONResponse\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@router.get(\"/sensors\")\nasync def get_sensors_data(\n    backend_state: tangram_core.InjectBackendState,\n) -&gt; ORJSONResponse:\n    plugin_config = backend_state.config.plugins.get(\"tangram_jet1090\", {})\n    config = TypeAdapter(PlanesConfig).validate_python(plugin_config)\n    url = f\"{config.jet1090_url}/sensors\".replace(\"localhost\", \"127.0.0.1\")\n\n    try:\n        response = await backend_state.http_client.get(url, timeout=10.0)\n        response.raise_for_status()\n        return ORJSONResponse(content=response.json())\n    except Exception as e:\n        log.error(f\"Failed to fetch sensors data from {url}: {e}\")\n        raise HTTPException(status_code=502, detail=str(e))\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.into_frontend","title":"into_frontend","text":"<pre><code>into_frontend(config: PlanesConfig) -&gt; PlanesFrontendConfig\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>def into_frontend(config: PlanesConfig) -&gt; PlanesFrontendConfig:\n    return PlanesFrontendConfig(\n        search_channel=config.search_channel,\n        show_route_lines=config.show_route_lines,\n        topbar_order=config.topbar_order,\n        sidebar_order=config.sidebar_order,\n        trail_type=config.trail_type,\n        trail_color=config.trail_color,\n        trail_alpha=config.trail_alpha,\n        enable_3d=config.enable_3d,\n    )\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.get_aircraft_db","title":"get_aircraft_db  <code>async</code>","text":"<pre><code>get_aircraft_db(\n    client: AsyncClient, url: str, path_cache: Path\n) -&gt; dict[str, Aircraft]\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>async def get_aircraft_db(\n    client: httpx.AsyncClient, url: str, path_cache: Path\n) -&gt; dict[str, _planes.Aircraft]:\n    from . import _planes\n\n    path_cache.mkdir(parents=True, exist_ok=True)\n    zip_path = path_cache / \"basestation.zip\"\n    db_path = path_cache / \"basestation.sqb\"\n\n    if not zip_path.exists():\n        log.info(f\"downloading aircraft database from {url} to {zip_path}\")\n        async with client.stream(\"GET\", url, follow_redirects=True) as response:\n            response.raise_for_status()\n            with zip_path.open(\"wb\") as f:\n                async for chunk in response.aiter_bytes():\n                    f.write(chunk)\n\n    if not db_path.exists():\n        log.info(f\"extracting {zip_path} to {db_path}\")\n        with zipfile.ZipFile(zip_path, \"r\") as zip_ref:\n            db_filename = zip_ref.namelist()[0]\n            zip_ref.extract(db_filename, path=path_cache)\n            (path_cache / db_filename).rename(db_path)\n\n    db = {}\n    try:\n        con = sqlite3.connect(f\"file:{db_path}?mode=ro\", uri=True)\n        cur = con.cursor()\n        res = cur.execute(\"SELECT ModeS, Registration, ICAOTypeCode FROM Aircraft\")\n        for modes, registration, icaotypecode in res.fetchall():\n            if modes:\n                db[modes.lower()] = _planes.Aircraft(\n                    registration=registration,\n                    typecode=icaotypecode,\n                )\n        con.close()\n    except sqlite3.Error as e:\n        log.error(f\"error reading aircraft database {db_path}: {e}\")\n        db_path.unlink(missing_ok=True)\n\n    return db\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090.run_planes","title":"run_planes  <code>async</code>","text":"<pre><code>run_planes(backend_state: BackendState) -&gt; None\n</code></pre> Source code in <code>packages/tangram_jet1090/src/tangram_jet1090/__init__.py</code> <pre><code>@plugin.register_service()\nasync def run_planes(backend_state: tangram_core.BackendState) -&gt; None:\n    from . import _planes\n\n    plugin_config = backend_state.config.plugins.get(\"tangram_jet1090\", {})\n    config_planes = TypeAdapter(PlanesConfig).validate_python(plugin_config)\n    if not config_planes.enable_3d and config_planes.trail_type == \"curtain\":\n        log.warning(\n            \"expected 'enable_3d' to be true when using 'curtain' trail type\"\n            \", switching to 'line'\"\n        )\n        config_planes = replace(config_planes, trail_type=\"line\")\n\n    default_log_level = plugin_config.get(\n        \"log_level\", backend_state.config.core.log_level\n    )\n\n    _planes.init_tracing_stderr(default_log_level)\n\n    aircraft_db = await get_aircraft_db(\n        backend_state.http_client,\n        config_planes.aircraft_db_url,\n        config_planes.path_cache,\n    )\n\n    rust_config = _planes.PlanesConfig(\n        redis_url=backend_state.config.core.redis_url,\n        jet1090_channel=config_planes.jet1090_channel,\n        history_table_name=config_planes.history_table_name,\n        state_vector_expire=config_planes.state_vector_expire,\n        stream_interval_secs=config_planes.stream_interval_secs,\n        aircraft_db=aircraft_db,\n        history_buffer_size=config_planes.history_buffer_size,\n        history_flush_interval_secs=config_planes.history_flush_interval_secs,\n        history_control_channel=config_planes.history_control_channel,\n        history_optimize_interval_secs=config_planes.history_optimize_interval_secs,\n        history_optimize_target_file_size=config_planes.history_optimize_target_file_size,\n        history_vacuum_interval_secs=config_planes.history_vacuum_interval_secs,\n        history_vacuum_retention_period_secs=config_planes.history_vacuum_retention_period_secs,\n        history_checkpoint_interval=config_planes.history_checkpoint_interval,\n        search_channel=config_planes.search_channel,\n    )\n    await _planes.run_planes(rust_config)\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes","title":"tangram_jet1090._planes","text":""},{"location":"api/jet1090/#tangram_jet1090._planes.Aircraft","title":"Aircraft","text":""},{"location":"api/jet1090/#tangram_jet1090._planes.Aircraft.typecode","title":"typecode  <code>property</code> <code>writable</code>","text":"<pre><code>typecode: Optional[str]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.Aircraft.registration","title":"registration  <code>property</code> <code>writable</code>","text":"<pre><code>registration: Optional[str]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.Aircraft.__new__","title":"__new__","text":"<pre><code>__new__(\n    typecode: Optional[str], registration: Optional[str]\n) -&gt; Aircraft\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig","title":"PlanesConfig","text":""},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.redis_url","title":"redis_url  <code>property</code> <code>writable</code>","text":"<pre><code>redis_url: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.jet1090_channel","title":"jet1090_channel  <code>property</code> <code>writable</code>","text":"<pre><code>jet1090_channel: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_table_name","title":"history_table_name  <code>property</code> <code>writable</code>","text":"<pre><code>history_table_name: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_control_channel","title":"history_control_channel  <code>property</code> <code>writable</code>","text":"<pre><code>history_control_channel: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.state_vector_expire","title":"state_vector_expire  <code>property</code> <code>writable</code>","text":"<pre><code>state_vector_expire: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.stream_interval_secs","title":"stream_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>stream_interval_secs: float\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.aircraft_db","title":"aircraft_db  <code>property</code> <code>writable</code>","text":"<pre><code>aircraft_db: dict[str, Aircraft]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_buffer_size","title":"history_buffer_size  <code>property</code> <code>writable</code>","text":"<pre><code>history_buffer_size: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_flush_interval_secs","title":"history_flush_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_flush_interval_secs: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_optimize_interval_secs","title":"history_optimize_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_optimize_interval_secs: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_optimize_target_file_size","title":"history_optimize_target_file_size  <code>property</code> <code>writable</code>","text":"<pre><code>history_optimize_target_file_size: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_vacuum_interval_secs","title":"history_vacuum_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_vacuum_interval_secs: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_vacuum_retention_period_secs","title":"history_vacuum_retention_period_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_vacuum_retention_period_secs: Optional[int]\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.history_checkpoint_interval","title":"history_checkpoint_interval  <code>property</code> <code>writable</code>","text":"<pre><code>history_checkpoint_interval: int\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.search_channel","title":"search_channel  <code>property</code> <code>writable</code>","text":"<pre><code>search_channel: str\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.PlanesConfig.__new__","title":"__new__","text":"<pre><code>__new__(\n    redis_url: str,\n    jet1090_channel: str,\n    history_table_name: str,\n    history_control_channel: str,\n    state_vector_expire: int,\n    stream_interval_secs: float,\n    aircraft_db: Mapping[str, Aircraft],\n    history_buffer_size: int,\n    history_flush_interval_secs: int,\n    history_optimize_interval_secs: int,\n    history_optimize_target_file_size: int,\n    history_vacuum_interval_secs: int,\n    history_vacuum_retention_period_secs: Optional[int],\n    history_checkpoint_interval: int,\n    search_channel: str,\n) -&gt; PlanesConfig\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.init_tracing_stderr","title":"init_tracing_stderr","text":"<pre><code>init_tracing_stderr(filter_str: str) -&gt; None\n</code></pre>"},{"location":"api/jet1090/#tangram_jet1090._planes.run_planes","title":"run_planes","text":"<pre><code>run_planes(config: PlanesConfig) -&gt; Any\n</code></pre>"},{"location":"api/ship162/","title":"Ship162","text":""},{"location":"api/ship162/#tangram_ship162","title":"tangram_ship162","text":""},{"location":"api/ship162/#tangram_ship162.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix=\"/ship162\",\n    tags=[\"ship162\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\",\n    routers=[router],\n    config_class=ShipsConfig,\n    frontend_config_class=ShipsFrontendConfig,\n    into_frontend_config_function=into_frontend,\n)\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig","title":"ShipsConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass ShipsConfig:\n    ship162_channel: str = \"ship162\"\n    history_table_name: str = \"ship162\"\n    history_control_channel: str = \"history:control\"\n    search_channel: str = \"ship162:search\"\n    state_vector_expire: int = 600  # 10 minutes\n    stream_interval_secs: float = 1.0\n    log_level: str = \"INFO\"\n    history_buffer_size: int = 100_000\n    history_flush_interval_secs: int = 5\n    history_optimize_interval_secs: int = 120\n    history_optimize_target_file_size: int = 134217728\n    history_vacuum_interval_secs: int = 120\n    history_vacuum_retention_period_secs: int | None = 120\n    history_checkpoint_interval: int = 10\n    topbar_order: int = 100\n    sidebar_order: int = 100\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.ship162_channel","title":"ship162_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ship162_channel: str = 'ship162'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_table_name","title":"history_table_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_table_name: str = 'ship162'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_control_channel","title":"history_control_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_control_channel: str = 'history:control'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.search_channel","title":"search_channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>search_channel: str = 'ship162:search'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.state_vector_expire","title":"state_vector_expire  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state_vector_expire: int = 600\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.stream_interval_secs","title":"stream_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stream_interval_secs: float = 1.0\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.log_level","title":"log_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_level: str = 'INFO'\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_buffer_size","title":"history_buffer_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_buffer_size: int = 100000\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_flush_interval_secs","title":"history_flush_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_flush_interval_secs: int = 5\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_optimize_interval_secs","title":"history_optimize_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_optimize_interval_secs: int = 120\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_optimize_target_file_size","title":"history_optimize_target_file_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_optimize_target_file_size: int = 134217728\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_vacuum_interval_secs","title":"history_vacuum_interval_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_vacuum_interval_secs: int = 120\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_vacuum_retention_period_secs","title":"history_vacuum_retention_period_secs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_vacuum_retention_period_secs: int | None = 120\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.history_checkpoint_interval","title":"history_checkpoint_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>history_checkpoint_interval: int = 10\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.topbar_order","title":"topbar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topbar_order: int = 100\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.sidebar_order","title":"sidebar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sidebar_order: int = 100\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    ship162_channel: str = \"ship162\",\n    history_table_name: str = \"ship162\",\n    history_control_channel: str = \"history:control\",\n    search_channel: str = \"ship162:search\",\n    state_vector_expire: int = 600,\n    stream_interval_secs: float = 1.0,\n    log_level: str = \"INFO\",\n    history_buffer_size: int = 100000,\n    history_flush_interval_secs: int = 5,\n    history_optimize_interval_secs: int = 120,\n    history_optimize_target_file_size: int = 134217728,\n    history_vacuum_interval_secs: int = 120,\n    history_vacuum_retention_period_secs: int | None = 120,\n    history_checkpoint_interval: int = 10,\n    topbar_order: int = 100,\n    sidebar_order: int = 100,\n) -&gt; None\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsFrontendConfig","title":"ShipsFrontendConfig  <code>dataclass</code>","text":"<p>               Bases: <code>HasTopbarUiConfig</code>, <code>HasSidebarUiConfig</code></p> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass ShipsFrontendConfig(\n    tangram_core.config.HasTopbarUiConfig, tangram_core.config.HasSidebarUiConfig\n):\n    search_channel: str\n    topbar_order: Annotated[int, FrontendMutable()]\n    sidebar_order: Annotated[int, FrontendMutable()]\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsFrontendConfig.search_channel","title":"search_channel  <code>instance-attribute</code>","text":"<pre><code>search_channel: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsFrontendConfig.topbar_order","title":"topbar_order  <code>instance-attribute</code>","text":"<pre><code>topbar_order: Annotated[int, FrontendMutable()]\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsFrontendConfig.sidebar_order","title":"sidebar_order  <code>instance-attribute</code>","text":"<pre><code>sidebar_order: Annotated[int, FrontendMutable()]\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.ShipsFrontendConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    search_channel: str,\n    topbar_order: Annotated[int, FrontendMutable()],\n    sidebar_order: Annotated[int, FrontendMutable()],\n) -&gt; None\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.get_trajectory_data","title":"get_trajectory_data  <code>async</code>","text":"<pre><code>get_trajectory_data(\n    mmsi: int, backend_state: InjectBackendState\n) -&gt; Response\n</code></pre> <p>Get the full trajectory for a given ship MMSI.</p> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@router.get(\"/data/{mmsi}\")\nasync def get_trajectory_data(\n    mmsi: int, backend_state: tangram_core.InjectBackendState\n) -&gt; Response:\n    \"\"\"Get the full trajectory for a given ship MMSI.\"\"\"\n    if not _HISTORY_AVAILABLE:\n        raise HTTPException(\n            status_code=501,\n            detail=\"History feature is not installed.\",\n        )\n\n    redis_key = \"tangram:history:table_uri:ship162\"\n    table_uri_bytes = await backend_state.redis_client.get(redis_key)\n\n    if not table_uri_bytes:\n        raise HTTPException(status_code=404, detail=\"Table 'ship162' not found.\")\n    table_uri = table_uri_bytes.decode(\"utf-8\")\n\n    try:\n        df = (\n            pl.scan_delta(table_uri)\n            .filter(pl.col(\"mmsi\") == mmsi)\n            .with_columns(pl.col(\"timestamp\").dt.epoch(time_unit=\"s\"))\n            .sort(\"timestamp\")\n            .collect()\n        )\n        return Response(df.write_json(), media_type=\"application/json\")\n    except Exception as e:\n        raise HTTPException(\n            status_code=500, detail=f\"Failed to query trajectory data: {e}\"\n        )\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.search_ships","title":"search_ships  <code>async</code>","text":"<pre><code>search_ships(\n    q: str, backend_state: InjectBackendState\n) -&gt; Response\n</code></pre> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@router.get(\"/search\")\nasync def search_ships(\n    q: str, backend_state: tangram_core.InjectBackendState\n) -&gt; Response:\n    if not _HISTORY_AVAILABLE:\n        return ORJSONResponse(content=[])\n\n    redis_key = \"tangram:history:table_uri:ship162\"\n    table_uri_bytes = await backend_state.redis_client.get(redis_key)\n    if not table_uri_bytes:\n        return ORJSONResponse(content=[])\n    table_uri = table_uri_bytes.decode(\"utf-8\")\n\n    try:\n        df = pl.scan_delta(table_uri)\n        q_lower = q.lower()\n\n        candidates = (\n            df.filter(\n                pl.col(\"ship_name\").str.to_lowercase().str.contains(q_lower)\n                | pl.col(\"mmsi\").cast(pl.String).str.contains(q_lower)\n                | pl.col(\"callsign\").str.to_lowercase().str.contains(q_lower)\n            )\n            .select(\"mmsi\")\n            .unique()\n            .head(20)\n            .collect()\n        )\n        candidate_mmsis = candidates[\"mmsi\"].to_list()\n\n        if not candidate_mmsis:\n            return ORJSONResponse(content=[])\n\n        intervals = (\n            df.filter(pl.col(\"mmsi\").is_in(candidate_mmsis))\n            .sort([\"mmsi\", \"timestamp\"])\n            .with_columns(pl.col(\"ship_name\").forward_fill().over(\"mmsi\"))\n            .with_columns(\n                gap_minutes=(\n                    pl.col(\"timestamp\") - pl.col(\"timestamp\").shift(1)\n                ).dt.total_minutes()\n            )\n            .with_columns(\n                new_interval=(\n                    (pl.col(\"gap_minutes\") &gt;= 60)\n                    | (pl.col(\"mmsi\") != pl.col(\"mmsi\").shift(1))\n                ).fill_null(True)\n            )\n            .with_columns(interval_id=pl.col(\"new_interval\").cast(pl.Int64).cum_sum())\n            .group_by([\"mmsi\", \"ship_name\", \"interval_id\"])\n            .agg(\n                start_ts=pl.col(\"timestamp\").min(),\n                end_ts=pl.col(\"timestamp\").max(),\n                n_rows=pl.len(),\n                lat=pl.col(\"latitude\").mean(),\n                lon=pl.col(\"longitude\").mean(),\n            )\n            .filter((pl.col(\"n_rows\") &gt;= 5))\n            .with_columns(\n                duration=((pl.col(\"end_ts\") - pl.col(\"start_ts\")).dt.total_seconds()),\n            )\n            .sort([\"start_ts\"], descending=True)\n            .collect()\n        )\n        return Response(intervals.write_json(), media_type=\"application/json\")\n    except Exception as e:\n        log.error(f\"Search failed: {e}\")\n        return ORJSONResponse(content=[])\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.get_history_slice","title":"get_history_slice  <code>async</code>","text":"<pre><code>get_history_slice(\n    mmsi: int,\n    start_timestamp: int,\n    end_timestamp: int,\n    backend_state: InjectBackendState,\n) -&gt; Response\n</code></pre> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@router.get(\"/history/{mmsi}/{start_timestamp}/{end_timestamp}\")\nasync def get_history_slice(\n    mmsi: int,\n    start_timestamp: int,\n    end_timestamp: int,\n    backend_state: tangram_core.InjectBackendState,\n) -&gt; Response:\n    if not _HISTORY_AVAILABLE:\n        return ORJSONResponse(content=[])\n\n    redis_key = \"tangram:history:table_uri:ship162\"\n    table_uri_bytes = await backend_state.redis_client.get(redis_key)\n    if not table_uri_bytes:\n        return ORJSONResponse(content=[])\n    table_uri = table_uri_bytes.decode(\"utf-8\")\n\n    start_dt = pl.lit(start_timestamp).cast(pl.Datetime(\"ms\"))\n    end_dt = pl.lit(end_timestamp).cast(pl.Datetime(\"ms\"))\n\n    try:\n        df = (\n            pl.scan_delta(table_uri)\n            .filter(\n                (pl.col(\"mmsi\") == mmsi)\n                &amp; (pl.col(\"timestamp\") &gt;= start_dt)\n                &amp; (pl.col(\"timestamp\") &lt;= end_dt)\n            )\n            .sort(\"timestamp\")\n            .collect()\n        )\n        return Response(df.write_json(), media_type=\"application/json\")\n    except Exception as e:\n        log.error(f\"History slice failed: {e}\")\n        return ORJSONResponse(content=[])\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.into_frontend","title":"into_frontend","text":"<pre><code>into_frontend(config: ShipsConfig) -&gt; ShipsFrontendConfig\n</code></pre> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>def into_frontend(config: ShipsConfig) -&gt; ShipsFrontendConfig:\n    return ShipsFrontendConfig(\n        search_channel=config.search_channel,\n        topbar_order=config.topbar_order,\n        sidebar_order=config.sidebar_order,\n    )\n</code></pre>"},{"location":"api/ship162/#tangram_ship162.run_ships","title":"run_ships  <code>async</code>","text":"<pre><code>run_ships(backend_state: BackendState) -&gt; None\n</code></pre> Source code in <code>packages/tangram_ship162/src/tangram_ship162/__init__.py</code> <pre><code>@plugin.register_service()\nasync def run_ships(backend_state: tangram_core.BackendState) -&gt; None:\n    from . import _ships\n\n    plugin_config = backend_state.config.plugins.get(\"tangram_ship162\", {})\n    config_ships = TypeAdapter(ShipsConfig).validate_python(plugin_config)\n\n    default_log_level = plugin_config.get(\n        \"log_level\", backend_state.config.core.log_level\n    )\n\n    _ships.init_tracing_stderr(default_log_level)\n\n    rust_config = _ships.ShipsConfig(\n        redis_url=backend_state.config.core.redis_url,\n        ship162_channel=config_ships.ship162_channel,\n        history_control_channel=config_ships.history_control_channel,\n        state_vector_expire=config_ships.state_vector_expire,\n        stream_interval_secs=config_ships.stream_interval_secs,\n        history_table_name=config_ships.history_table_name,\n        history_buffer_size=config_ships.history_buffer_size,\n        history_flush_interval_secs=config_ships.history_flush_interval_secs,\n        history_optimize_interval_secs=config_ships.history_optimize_interval_secs,\n        history_optimize_target_file_size=config_ships.history_optimize_target_file_size,\n        history_vacuum_interval_secs=config_ships.history_vacuum_interval_secs,\n        history_vacuum_retention_period_secs=config_ships.history_vacuum_retention_period_secs,\n        history_checkpoint_interval=config_ships.history_checkpoint_interval,\n        search_channel=config_ships.search_channel,\n    )\n    await _ships.run_ships(rust_config)\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships","title":"tangram_ship162._ships","text":""},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig","title":"ShipsConfig","text":""},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.redis_url","title":"redis_url  <code>property</code> <code>writable</code>","text":"<pre><code>redis_url: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.ship162_channel","title":"ship162_channel  <code>property</code> <code>writable</code>","text":"<pre><code>ship162_channel: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_control_channel","title":"history_control_channel  <code>property</code> <code>writable</code>","text":"<pre><code>history_control_channel: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.state_vector_expire","title":"state_vector_expire  <code>property</code> <code>writable</code>","text":"<pre><code>state_vector_expire: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.stream_interval_secs","title":"stream_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>stream_interval_secs: float\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_table_name","title":"history_table_name  <code>property</code> <code>writable</code>","text":"<pre><code>history_table_name: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_buffer_size","title":"history_buffer_size  <code>property</code> <code>writable</code>","text":"<pre><code>history_buffer_size: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_flush_interval_secs","title":"history_flush_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_flush_interval_secs: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_optimize_interval_secs","title":"history_optimize_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_optimize_interval_secs: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_optimize_target_file_size","title":"history_optimize_target_file_size  <code>property</code> <code>writable</code>","text":"<pre><code>history_optimize_target_file_size: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_vacuum_interval_secs","title":"history_vacuum_interval_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_vacuum_interval_secs: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_vacuum_retention_period_secs","title":"history_vacuum_retention_period_secs  <code>property</code> <code>writable</code>","text":"<pre><code>history_vacuum_retention_period_secs: Optional[int]\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.history_checkpoint_interval","title":"history_checkpoint_interval  <code>property</code> <code>writable</code>","text":"<pre><code>history_checkpoint_interval: int\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.search_channel","title":"search_channel  <code>property</code> <code>writable</code>","text":"<pre><code>search_channel: str\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.ShipsConfig.__new__","title":"__new__","text":"<pre><code>__new__(\n    redis_url: str,\n    ship162_channel: str,\n    history_control_channel: str,\n    state_vector_expire: int,\n    stream_interval_secs: float,\n    history_table_name: str,\n    history_buffer_size: int,\n    history_flush_interval_secs: int,\n    history_optimize_interval_secs: int,\n    history_optimize_target_file_size: int,\n    history_vacuum_interval_secs: int,\n    history_vacuum_retention_period_secs: Optional[int],\n    history_checkpoint_interval: int,\n    search_channel: str,\n) -&gt; ShipsConfig\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.init_tracing_stderr","title":"init_tracing_stderr","text":"<pre><code>init_tracing_stderr(filter_str: str) -&gt; None\n</code></pre>"},{"location":"api/ship162/#tangram_ship162._ships.run_ships","title":"run_ships","text":"<pre><code>run_ships(config: ShipsConfig) -&gt; Any\n</code></pre>"},{"location":"api/system/","title":"System","text":""},{"location":"api/system/#tangram_system","title":"tangram_system","text":""},{"location":"api/system/#tangram_system.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/system/#tangram_system.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\",\n    config_class=SystemConfig,\n    frontend_config_class=SystemFrontendConfig,\n    into_frontend_config_function=into_frontend,\n)\n</code></pre>"},{"location":"api/system/#tangram_system.SystemConfig","title":"SystemConfig  <code>dataclass</code>","text":"Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>@dataclass\nclass SystemConfig:\n    topbar_order: int = 0\n</code></pre>"},{"location":"api/system/#tangram_system.SystemConfig.topbar_order","title":"topbar_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topbar_order: int = 0\n</code></pre>"},{"location":"api/system/#tangram_system.SystemConfig.__init__","title":"__init__","text":"<pre><code>__init__(topbar_order: int = 0) -&gt; None\n</code></pre>"},{"location":"api/system/#tangram_system.SystemFrontendConfig","title":"SystemFrontendConfig  <code>dataclass</code>","text":"<p>               Bases: <code>HasTopbarUiConfig</code></p> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>@dataclass\nclass SystemFrontendConfig(tangram_core.config.HasTopbarUiConfig):\n    topbar_order: Annotated[int, FrontendMutable()]\n</code></pre>"},{"location":"api/system/#tangram_system.SystemFrontendConfig.topbar_order","title":"topbar_order  <code>instance-attribute</code>","text":"<pre><code>topbar_order: Annotated[int, FrontendMutable()]\n</code></pre>"},{"location":"api/system/#tangram_system.SystemFrontendConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    topbar_order: Annotated[int, FrontendMutable()],\n) -&gt; None\n</code></pre>"},{"location":"api/system/#tangram_system.into_frontend","title":"into_frontend","text":"<pre><code>into_frontend(config: SystemConfig) -&gt; SystemFrontendConfig\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def into_frontend(config: SystemConfig) -&gt; SystemFrontendConfig:\n    return SystemFrontendConfig(topbar_order=config.topbar_order)\n</code></pre>"},{"location":"api/system/#tangram_system.uptime","title":"uptime","text":"<pre><code>uptime(counter: int) -&gt; dict[str, str]\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def uptime(counter: int) -&gt; dict[str, str]:\n    return {\n        \"el\": \"uptime\",\n        \"value\": f\"{timedelta(seconds=counter)}\",\n    }\n</code></pre>"},{"location":"api/system/#tangram_system.info_utc","title":"info_utc","text":"<pre><code>info_utc() -&gt; dict[str, str | int]\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def info_utc() -&gt; dict[str, str | int]:\n    return {\n        \"el\": \"info_utc\",\n        \"value\": 1000 * int(datetime.now(timezone.utc).timestamp()),\n    }\n</code></pre>"},{"location":"api/system/#tangram_system.cpu_load","title":"cpu_load","text":"<pre><code>cpu_load() -&gt; dict[str, str]\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def cpu_load() -&gt; dict[str, str]:\n    try:\n        load1, _load5, _load15 = psutil.getloadavg()\n        cpu_count = psutil.cpu_count(logical=True) or 1\n        load_percent = (load1 / cpu_count) * 100\n        return {\"el\": \"cpu_load\", \"value\": f\"{load_percent:.2f}%\"}\n    except Exception:\n        return {\"el\": \"cpu_load\", \"value\": \"Unavailable\"}\n</code></pre>"},{"location":"api/system/#tangram_system.ram_usage","title":"ram_usage","text":"<pre><code>ram_usage() -&gt; dict[str, str]\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>def ram_usage() -&gt; dict[str, str]:\n    try:\n        mem = psutil.virtual_memory()\n        return {\"el\": \"ram_usage\", \"value\": f\"{mem.percent:.2f}%\"}\n    except Exception:\n        return {\"el\": \"ram_usage\", \"value\": \"Unavailable\"}\n</code></pre>"},{"location":"api/system/#tangram_system.server_events","title":"server_events  <code>async</code>","text":"<pre><code>server_events(redis_client: Redis) -&gt; NoReturn\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>async def server_events(redis_client: redis.Redis) -&gt; NoReturn:\n    counter = 0\n    log.info(\"serving system events...\")\n\n    while True:\n        await redis_client.publish(\n            \"to:system:update-node\", orjson.dumps(uptime(counter))\n        )\n        await redis_client.publish(\"to:system:update-node\", orjson.dumps(info_utc()))\n        await redis_client.publish(\"to:system:update-node\", orjson.dumps(cpu_load()))\n        await redis_client.publish(\"to:system:update-node\", orjson.dumps(ram_usage()))\n        counter += 1\n\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"api/system/#tangram_system.run_system","title":"run_system  <code>async</code>","text":"<pre><code>run_system(backend_state: BackendState) -&gt; None\n</code></pre> Source code in <code>packages/tangram_system/src/tangram_system/__init__.py</code> <pre><code>@plugin.register_service()\nasync def run_system(backend_state: tangram_core.BackendState) -&gt; None:\n    await server_events(backend_state.redis_client)\n</code></pre>"},{"location":"api/weather/","title":"Weather","text":""},{"location":"api/weather/#tangram_weather","title":"tangram_weather","text":""},{"location":"api/weather/#tangram_weather.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/weather/#tangram_weather.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix=\"/weather\",\n    tags=[\"weather\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n</code></pre>"},{"location":"api/weather/#tangram_weather.plugin","title":"plugin  <code>module-attribute</code>","text":"<pre><code>plugin = Plugin(\n    frontend_path=\"dist-frontend\", routers=[router]\n)\n</code></pre>"},{"location":"api/weather/#tangram_weather.get_weather","title":"get_weather  <code>async</code>","text":"<pre><code>get_weather() -&gt; dict[str, str]\n</code></pre> Source code in <code>packages/tangram_weather/src/tangram_weather/__init__.py</code> <pre><code>@router.get(\"/\")\nasync def get_weather() -&gt; dict[str, str]:\n    return {\"message\": \"This is the weather plugin response\"}\n</code></pre>"},{"location":"api/weather/#tangram_weather.wind","title":"wind  <code>async</code>","text":"<pre><code>wind(\n    isobaric: int, backend_state: InjectBackendState\n) -&gt; ORJSONResponse\n</code></pre> Source code in <code>packages/tangram_weather/src/tangram_weather/__init__.py</code> <pre><code>@router.get(\"/wind\")\nasync def wind(\n    isobaric: int, backend_state: tangram_core.InjectBackendState\n) -&gt; ORJSONResponse:\n    logger.info(\"fetching wind data for %s\", isobaric)\n\n    now = pd.Timestamp.now(tz=\"UTC\").floor(\"1h\")\n    ds = await latest_arpege_data(backend_state.http_client, now)\n    res = ds.sel(isobaricInhPa=isobaric, time=now.tz_convert(None))[[\"u\", \"v\"]]\n\n    u_attrs = res.data_vars[\"u\"].attrs\n\n    bounds = [\n        u_attrs[\"GRIB_longitudeOfFirstGridPointInDegrees\"],\n        u_attrs[\"GRIB_latitudeOfLastGridPointInDegrees\"],\n        u_attrs[\"GRIB_longitudeOfLastGridPointInDegrees\"],\n        u_attrs[\"GRIB_latitudeOfFirstGridPointInDegrees\"],\n    ]\n\n    u_data = res[\"u\"].values\n    v_data = res[\"v\"].values\n\n    valid_data_mask = ~np.isnan(u_data)\n\n    min_val, max_val = -70.0, 70.0\n    image_unscale = [min_val, max_val]\n    value_range = max_val - min_val\n\n    u_scaled = (np.nan_to_num(u_data, nan=0.0) - min_val) / value_range * 255\n    v_scaled = (np.nan_to_num(v_data, nan=0.0) - min_val) / value_range * 255\n\n    rgba_data = np.zeros((*u_data.shape, 4), dtype=np.uint8)\n    rgba_data[..., 0] = u_scaled.astype(np.uint8)\n    rgba_data[..., 1] = v_scaled.astype(np.uint8)\n    rgba_data[..., 3] = np.where(valid_data_mask, 255, 0)\n\n    image = Image.fromarray(rgba_data, \"RGBA\")\n    buffer = io.BytesIO()\n    image.save(buffer, format=\"PNG\")\n    img_str = base64.b64encode(buffer.getvalue()).decode(\"utf-8\")\n    image_data_uri = f\"data:image/png;base64,{img_str}\"\n\n    response_content = {\n        \"imageDataUri\": image_data_uri,\n        \"bounds\": bounds,\n        \"imageUnscale\": image_unscale,\n    }\n\n    return ORJSONResponse(content=response_content)\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege","title":"arpege","text":""},{"location":"api/weather/#tangram_weather.arpege.bare_url","title":"bare_url  <code>module-attribute</code>","text":"<pre><code>bare_url = (\n    \"https://object.data.gouv.fr/meteofrance-pnt/pnt/\"\n)\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.DEFAULT_LEVELS_37","title":"DEFAULT_LEVELS_37  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LEVELS_37 = [\n    100,\n    125,\n    150,\n    175,\n    200,\n    225,\n    250,\n    300,\n    350,\n    400,\n    450,\n    500,\n    550,\n    600,\n    650,\n    700,\n    750,\n    800,\n    850,\n    900,\n    950,\n    1000,\n]\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.DEFAULT_IP1_FEATURES","title":"DEFAULT_IP1_FEATURES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_IP1_FEATURES = ['u', 'v', 't', 'r']\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.tempdir","title":"tempdir  <code>module-attribute</code>","text":"<pre><code>tempdir = Path(gettempdir())\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.download_with_progress","title":"download_with_progress  <code>async</code>","text":"<pre><code>download_with_progress(\n    client: AsyncClient, url: str, file: Path\n) -&gt; None\n</code></pre> Source code in <code>packages/tangram_weather/src/tangram_weather/arpege.py</code> <pre><code>async def download_with_progress(\n    client: httpx.AsyncClient, url: str, file: Path\n) -&gt; None:\n    try:\n        async with client.stream(\"GET\", url) as r:\n            if r.status_code != 200:\n                raise httpx.HTTPStatusError(\n                    f\"Error downloading data from {url}\", request=r.request, response=r\n                )\n\n            total_size = int(r.headers.get(\"Content-Length\", 0))\n            with file.open(\"wb\") as buffer:\n                with tqdm(\n                    total=total_size,\n                    unit=\"B\",\n                    unit_scale=True,\n                    desc=url.split(\"/\")[-1],\n                ) as progress_bar:\n                    first_chunk = True\n                    async for chunk in r.aiter_bytes():\n                        if first_chunk and chunk.startswith(b\"&lt;?xml\"):\n                            raise RuntimeError(\n                                f\"Error downloading data from {url}. \"\n                                \"Check if the requested data is available.\"\n                            )\n                        first_chunk = False\n                        await asyncio.to_thread(buffer.write, chunk)\n                        progress_bar.update(len(chunk))\n    except (httpx.RequestError, RuntimeError) as e:\n        if file.exists():\n            file.unlink()\n        raise e\n</code></pre>"},{"location":"api/weather/#tangram_weather.arpege.latest_data","title":"latest_data  <code>async</code>","text":"<pre><code>latest_data(\n    client: AsyncClient,\n    hour: Timestamp,\n    model: str = \"ARPEGE\",\n    resolution: Literal[\"025\", \"01\"] = \"025\",\n    package: Literal[\n        \"SP1\", \"SP2\", \"IP1\", \"IP2\", \"IP3\", \"IP4\", \"HP1\"\n    ] = \"IP1\",\n    time_range: Literal[\n        \"000H024H\",\n        \"025H048H\",\n        \"049H072H\",\n        \"073H102H\",\n        \"000H012H\",\n        \"013H024H\",\n        \"025H036H\",\n        \"037H048H\",\n        \"049H060H\",\n        \"061H072H\",\n        \"073H084H\",\n        \"085H096H\",\n        \"097H102H\",\n    ] = \"000H024H\",\n    recursion: int = 0,\n) -&gt; Dataset\n</code></pre> <p>Fetch the latest ARPEGE data for a given hour.</p> Source code in <code>packages/tangram_weather/src/tangram_weather/arpege.py</code> <pre><code>async def latest_data(\n    client: httpx.AsyncClient,\n    hour: pd.Timestamp,\n    model: str = \"ARPEGE\",\n    resolution: Literal[\"025\", \"01\"] = \"025\",\n    package: Literal[\"SP1\", \"SP2\", \"IP1\", \"IP2\", \"IP3\", \"IP4\", \"HP1\"] = \"IP1\",\n    time_range: Literal[\n        \"000H024H\",  # on the 0.25 degree grid\n        \"025H048H\",  # on the 0.25 degree grid\n        \"049H072H\",  # on the 0.25 degree grid\n        \"073H102H\",  # on the 0.25 degree grid\n        \"000H012H\",  # on the 0.1 degree grid\n        \"013H024H\",  # on the 0.1 degree grid\n        \"025H036H\",  # on the 0.1 degree grid\n        \"037H048H\",  # on the 0.1 degree grid\n        \"049H060H\",  # on the 0.1 degree grid\n        \"061H072H\",  # on the 0.1 degree grid\n        \"073H084H\",  # on the 0.1 degree grid\n        \"085H096H\",  # on the 0.1 degree grid\n        \"097H102H\",  # on the 0.1 degree grid\n    ] = \"000H024H\",\n    recursion: int = 0,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Fetch the latest ARPEGE data for a given hour.\n    \"\"\"\n    # let's give them time to upload data to the repo\n    runtime = (hour - pd.Timedelta(\"2h\")).floor(\"6h\")\n\n    url = f\"{bare_url}{runtime.isoformat()}/\"\n    url += f\"{model.lower()}/{resolution}/{package}/\"\n    filename = f\"{model.lower()}__{resolution}__{package}__\"\n    filename += f\"{time_range}__{runtime.isoformat()}.grib2\"\n    filename = filename.replace(\"+00:00\", \"Z\")\n    url += filename\n    url = url.replace(\"+00:00\", \"Z\")\n\n    if not (tempdir / filename).exists():\n        # If the file does not exist, we try to download it.\n        try:\n            await download_with_progress(client, url, tempdir / filename)\n        except Exception:\n            (tempdir / filename).unlink(missing_ok=True)  # remove the file if it exists\n            # If the download fails, we try to fetch the latest data\n            # (or survive with older data we may have in the /tmp directory)\n            if recursion &gt;= 3:\n                raise  # do not insist too much in history\n            return await latest_data(\n                client,\n                hour - pd.Timedelta(\"6h\"),\n                model,\n                resolution,\n                package,\n                time_range,\n                recursion + 1,\n            )\n\n    def _load_and_process_dataset() -&gt; xr.Dataset:\n        log.info(f\"Loading dataset from {tempdir / filename}\")\n        ds = xr.open_dataset(\n            tempdir / filename,\n            engine=\"cfgrib\",\n            backend_kwargs={\n                \"filter_by_keys\": {\n                    \"typeOfLevel\": \"isobaricInhPa\",\n                    \"level\": DEFAULT_LEVELS_37,\n                }\n            },\n        )\n        ds = ds.assign(step=ds.time + ds.step).drop_vars(\"time\")\n        ds = ds.rename(step=\"time\")\n        return ds  # type: ignore\n\n    return await asyncio.to_thread(_load_and_process_dataset)\n</code></pre>"},{"location":"architecture/channel/","title":"Channel: WebSocket Bridge","text":"<p>The Channel service is a high-performance Rust component that bridges the gap between the frontend (WebSocket) and backend (Redis). It implements a subset of the Phoenix Channels protocol, allowing the frontend to subscribe to data streams without needing a direct Redis connection.</p>"},{"location":"architecture/channel/#overview","title":"Overview","text":"<p>Channel acts as a translation layer:</p> <ul> <li>Downstream: Subscribes to Redis <code>to:&lt;topic&gt;:*</code> patterns and pushes data to browser WebSockets.</li> <li>Upstream: Re-publishes browser commands to Redis <code>from:&lt;topic&gt;:&lt;event&gt;</code>.</li> <li>Supports multiple named channels that clients can join and leave</li> <li>Secures channel access with JSON Web Tokens</li> <li>Tracks and broadcasts client presence information</li> </ul>"},{"location":"architecture/channel/#communication-flow","title":"Communication Flow","text":""},{"location":"architecture/channel/#backend-to-frontend","title":"Backend to Frontend","text":"<ol> <li>Backend plugins publish messages to Redis topics in the format <code>to:&lt;topic&gt;:&lt;event&gt;</code>.</li> <li>Channel subscribes to Redis using <code>PSUBSCRIBE to:&lt;topic&gt;:*</code>.</li> <li>When a message arrives, Channel forwards it to all WebSocket clients joined to that topic.</li> </ol> <pre><code>sequenceDiagram\n    participant P as Backend Plugin\n    participant R as Redis\n    participant C as Channel Service\n    participant F as Frontend Client\n\n    P-&gt;&gt;R: PUBLISH to:system:update, \"data\"\n    R--&gt;&gt;C: Receives message\n    C-&gt;&gt;F: PUSH system:update, \"data\"</code></pre>"},{"location":"architecture/channel/#frontend-to-backend","title":"Frontend to Backend","text":"<ol> <li>WebSocket clients send messages to a specific channel with an event name</li> <li>Channel receives these messages and publishes them to Redis topics in the format <code>from:&lt;channel&gt;:&lt;event&gt;</code></li> <li>Backend plugins subscribe to these Redis topics to receive client messages</li> <li>Plugins process the messages and can respond by publishing back to <code>to:&lt;channel&gt;:&lt;event&gt;</code></li> </ol> <pre><code>sequenceDiagram\n    participant F as Frontend Client\n    participant C as Channel Service\n    participant R as Redis\n    participant P as Backend Plugin\n\n    F-&gt;&gt;C: PUSH system:command, \"payload\"\n    C-&gt;&gt;R: PUBLISH from:system:command, \"payload\"\n    R--&gt;&gt;P: Receives message</code></pre>"},{"location":"architecture/channel/#channel-protocol","title":"Channel Protocol","text":"<p>The WebSocket protocol follows the Phoenix Channels message format, which uses JSON arrays with the following structure:</p> <pre><code>[join_ref, ref, topic, event, payload]\n</code></pre> <p>Where:</p> <ul> <li><code>join_ref</code>: Reference to the channel join request (null for system messages)</li> <li><code>ref</code>: Message reference for tracking responses</li> <li><code>topic</code>: Channel name</li> <li><code>event</code>: Event name</li> <li><code>payload</code>: Message data</li> </ul>"},{"location":"architecture/channel/#events","title":"Events","text":"<ul> <li><code>phx_join</code>: Join a channel (requires JWT token)</li> <li><code>phx_leave</code>: Leave a channel</li> <li><code>phx_reply</code>: Acknowledgment of a message</li> <li><code>presence_state</code>: Current state of all clients in a channel</li> <li><code>presence_diff</code>: Changes in channel presence</li> <li>Custom events: Any custom event name can be used for application-specific messages</li> </ul>"},{"location":"architecture/channel/#usage-in-tangram","title":"Usage in Tangram","text":""},{"location":"architecture/channel/#predefined-channels","title":"Predefined Channels","text":"<ul> <li><code>phoenix</code>: System channel for heartbeats and connection management</li> <li><code>admin</code>: Administrative channel for monitoring and control</li> <li><code>system</code>: General system information (includes regular datetime broadcasts)</li> <li>Custom channels: Application-specific channels can be created dynamically</li> </ul>"},{"location":"architecture/channel/#client-connection","title":"Client Connection","text":"<p>Clients connect to the WebSocket endpoint and can join multiple channels:</p> <pre><code>// Connect to the WebSocket\nconst socket = new Phoenix.Socket(\"/websocket\", {\n  params: { userToken: token },\n});\nsocket.connect();\n\n// Join a channel\nconst channel = socket.channel(\"system\", { token: systemToken });\nchannel\n  .join()\n  .receive(\"ok\", (response) =&gt; console.log(\"Joined successfully\", response))\n  .receive(\"error\", (response) =&gt; console.log(\"Join failed\", response));\n\n// Listen for events\nchannel.on(\"datetime\", (payload) =&gt; {\n  console.log(\"Current time:\", payload.response.datetime);\n});\n\n// Send events\nchannel.push(\"custom_event\", { message: \"Hello from client\" });\n</code></pre>"},{"location":"architecture/channel/#backend-integration","title":"Backend Integration","text":"<p>Backend plugins can communicate with the frontend by using Redis pub/sub:</p> <pre><code>import redis\nimport json\n\nr = redis.Redis()\n\n# Send message to frontend clients\nawait r.publish('to:system:update', json.dumps({\n    'type': 'message',\n    'message': 'Update from backend'\n}))\n\n# Listen for messages from frontend\np = r.pubsub()\nawait p.psubscribe('from:system:*')\nasync for message in p.listen():\n    if message['type'] == 'pmessage':\n        print(f\"Received: {message['data']}\")\n</code></pre>"},{"location":"architecture/channel/#running-the-channel-service","title":"Running the Channel Service","text":"<p>The Channel service is an integrated part of the core <code>tangram</code> application. It is automatically started as a background service when you run the <code>tangram serve</code> command. You do not need to run it separately.</p> <p>Its behavior is configured in the <code>[channel]</code> section of your <code>tangram.toml</code> file.</p> tangram.toml<pre><code>[channel]\nhost = \"127.0.0.1\"\nport = 2347\n# The public-facing URL for the channel service.\n# Required when running behind a reverse proxy.\n# public_url = \"http://localhost:2347\"\njwt_secret = \"a-better-secret-than-this\"\n</code></pre>"},{"location":"architecture/channel/#token-authentication","title":"Token Authentication","text":"<p>Channels require JWT tokens for authentication. Tokens can be requested from the <code>/token</code> endpoint, which is exposed on the port defined in your configuration.</p> <pre><code>curl -X POST http://localhost:2347/token \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"channel\": \"system\", \"id\": \"client1\"}'\n</code></pre> <p>The response includes a JWT token that can be used for channel authentication:</p> <pre><code>{\n  \"id\": \"client1\",\n  \"channel\": \"system\",\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n</code></pre>"},{"location":"architecture/channel/#redis-commands-for-debugging","title":"Redis Commands for Debugging","text":"<pre><code># Subscribe to all outgoing messages from clients\nredis-cli psubscribe \"from:*\"\n\n# Subscribe to all incoming messages to clients\nredis-cli psubscribe \"to:*\"\n\n# Publish a test message to clients\nredis-cli publish \"to:system:test\" '{\"type\":\"message\",\"message\":\"Test from Redis\"}'\n</code></pre>"},{"location":"architecture/overview/","title":"Architecture of the tangram framework","text":"<p>The <code>tangram</code> framework consists of a lightweight core and a suite of independent, installable plugins that can be combined to create a powerful and flexible aviation data processing and visualization system.</p> <p>The system consists of a web-based frontend (in Javascript  based on Vite), a backend service (in Python ), and performance-critical components in Rust .</p> <p>Communication between the frontend and backend is done through a REST API, while real-time data streaming is handled via WebSockets. A Redis  pub/sub system is used for efficient data distribution between backend components.</p>"},{"location":"architecture/overview/#a-plugin-first-architecture","title":"A Plugin-First Architecture","text":"<p>The core <code>tangram</code> package provides the essential scaffolding: a web server, a plugin loader, and a frontend API. All domain-specific functionality, including data decoding and processing, is implemented in separate, <code>pip</code>-installable plugins.</p> <p>This design allows you to:</p> <ul> <li>install only the functionality you need.</li> <li>develop, version, and distribute your own extensions (e.g., <code>my-simulation-plugin</code>) without modifying the core <code>tangram</code> codebase.</li> </ul> Component Technology Frontend  JavaScript (Vue.js, Vite) Backend  Python for most applications (FastAPI for the REST API)  Rust for performance critical components Data communication  Redis (pub/sub messaging system)"},{"location":"architecture/overview/#system-overview","title":"System Overview","text":"<p>When you run <code>tangram serve</code>, it starts a single Python process that manages multiple asynchronous tasks for the application's core components and enabled plugins.</p> <pre><code>graph LR\n    subgraph User\n        B[Browser/Frontend]\n    end\n\n    subgraph \"Tangram Process (Python)\"\n        direction TB\n        FAS[FastAPI Server]\n        CS[Channel Service]\n        PS[Plugin Services e.g., planes]\n    end\n\n    subgraph \"External Services\"\n        J[jet1090 Container]\n    end\n\n    R[Redis Pub/Sub]\n\n    B -- HTTP API Requests --&gt; FAS\n    B &lt;-- WebSocket --&gt; CS\n    FAS -- Serves Frontend Assets --&gt; B\n    FAS &lt;-- Reads/Writes --&gt; R\n    CS &lt;-- Relays Messages --&gt; R\n    PS -- \u25c0 Subscribes to --&gt; R\n    J -- Publishes \u25b6 --&gt; R</code></pre> Component Provided By Description <code>tangram</code> (Core) <code>tangram_core</code> package REST API server, CLI, and frontend shell. <code>channel</code> (Bundled with <code>tangram</code>) WebSocket bridge between the frontend and Redis pub/sub. <code>jet1090</code> integration <code>tangram_jet1090</code> plugin Decodes Mode S/ADS-B messages and provides data streams. State Vectors &amp; History <code>tangram_jet1090</code> plugin Maintains real-time state and stores historical aircraft data. System Info <code>tangram_system</code> plugin Provides backend server metrics like CPU and memory usage. Weather Layers <code>tangram_weather</code> plugin Provides API endpoints for meteorological data."},{"location":"architecture/overview/#backend-plugin-system","title":"Backend Plugin System","text":"<p>The backend discovers plugins using Python's standard entry point mechanism. When you <code>pip install tangram_jet1090</code>, it registers itself under the <code>tangram_core.plugins</code> group in its <code>pyproject.toml</code>. The core <code>tangram</code> application queries these groups at startup to find and load all available plugins, allowing them to add their own API routes and background tasks.</p> <p>For a detailed guide on creating your own backend extensions, see the Backend Plugin Guide.</p>"},{"location":"architecture/overview/#frontend-plugin-system","title":"Frontend Plugin System","text":"<p>The frontend loads plugins dynamically. The backend serves a <code>/manifest.json</code> file listing all enabled frontend plugins. The core <code>tangram</code> web application fetches this manifest and dynamically imports the JavaScript entry point for each plugin. The plugin's entry point then calls the <code>tangramApi.registerWidget()</code> function to add its Vue components to the main application.</p> <p>For more details, see the Frontend Plugin Guide.</p>"},{"location":"plugins/airports/","title":"Airports Plugin","text":"<p>The <code>tangram_airports</code> plugin adds an airport search widget as an overlay on the top-right corner of the map. This allows users to quickly find and center the map on any airport by name, IATA code, or ICAO code.</p>"},{"location":"plugins/airports/#how-it-works","title":"How It Works","text":"<p>This is a frontend-only plugin that requires no additional backend configuration.</p> <ol> <li>It registers a Vue component, <code>AirportSearchWidget.vue</code>, in the <code>MapOverlay</code> location of the UI.</li> <li>The component uses the <code>rs1090-wasm</code> library, which is bundled with the core <code>tangram</code> application, to perform a fast, client-side search of a comprehensive airport database.</li> <li>When a user selects an airport from the search results, the plugin uses the <code>MapApi</code> to pan and zoom the map to the airport's location.</li> </ol>"},{"location":"plugins/airports/#configuration","title":"Configuration","text":"<p>To enable this plugin, add <code>\"tangram_airports\"</code> to the <code>plugins</code> list in your <code>tangram.toml</code> file:</p> tangram.toml<pre><code>[core]\nplugins = [\n    # ... other plugins\n    \"tangram_airports\"\n]\n</code></pre>"},{"location":"plugins/backend/","title":"Backend","text":"<p>Backend plugins are the standard way to add new server-side capabilities to <code>tangram</code>. They are self-contained Python packages that <code>tangram</code> discovers and loads at runtime, allowing for clean separation from the core framework.</p> <p>This guide covers the key concepts for building a backend plugin.</p>"},{"location":"plugins/backend/#plugin-anatomy","title":"Plugin Anatomy","text":"<p>A <code>tangram</code> plugin is a standard Python package that exposes its functionality through two key mechanisms: an entry point and a <code>Plugin</code> object.</p> <p>Assuming you have the following project structure:</p> <pre><code>my-tangram-plugin/\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 my_plugin/\n        \u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"plugins/backend/#1-the-pyprojecttoml-entry-point","title":"1. The <code>pyproject.toml</code> Entry Point","text":"<p>Your <code>pyproject.toml</code> must declare an entry point under the <code>tangram_core.plugins</code> group. This makes your package discoverable by the core application.</p> pyproject.toml<pre><code>[project]\nname = \"my-tangram-plugin\"\nversion = \"0.1.0\"\ndependencies = [\"tangram_core&gt;=0.2.1\"]\n\n[project.entry-points.\"tangram_core.plugins\"]\nmy_plugin = \"my_plugin:plugin\"\n</code></pre>"},{"location":"plugins/backend/#2-the-plugin-object","title":"2. The <code>Plugin</code> Object","text":"<p>The entry point must point to an instance of the <code>tangram_core.Plugin</code> class. This object is the central hub for registering your plugin's components.</p> src/my_plugin/__init__.py<pre><code>import tangram_core\n\nplugin = tangram_core.Plugin(\n    # ... component registrations go here ...\n)\n</code></pre>"},{"location":"plugins/backend/#adding-api-endpoints","title":"Adding API Endpoints","text":"<p>To add REST API endpoints, define a standard FastAPI <code>APIRouter</code> and pass a list of routers to the <code>Plugin</code> constructor. <code>tangram</code> will automatically mount them into the main application.</p> src/my_plugin/__init__.py<pre><code>import tangram_core\nfrom fastapi import APIRouter\n\nrouter = APIRouter(prefix=\"/my-plugin\")\n\n@router.get(\"/\")\nasync def my_endpoint():\n    return {\"message\": \"Hello from my custom plugin!\"}\n\nplugin = tangram_core.Plugin(\n    routers=[router]\n)\n</code></pre>"},{"location":"plugins/backend/#creating-background-services","title":"Creating Background Services","text":"<p>To run persistent background tasks, use the <code>@plugin.register_service</code> decorator. The decorated function will be started as a background task when <code>tangram serve</code> runs.</p> <p>The service function receives a <code>tangram_core.BackendState</code> object, which provides access to core components like the Redis client.</p> src/my_plugin/__init__.py<pre><code>import asyncio\nimport orjson\nimport tangram_core\n\nplugin = tangram_core.Plugin()\n\n@plugin.register_service()\nasync def run_periodic_task(backend_state: tangram_core.BackendState):\n    \"\"\"A background service that publishes a message every 10 seconds.\"\"\"\n    redis_client = backend_state.redis_client\n    while True:\n        # messages for the frontend MUST be JSON-encoded and \n        # prefixed with 'to:&lt;topic&gt;:&lt;event&gt;'\n        payload = orjson.dumps({\"status\": \"alive\", \"timestamp\": 123456789})\n        await redis_client.publish(\"to:my-plugin:update\", payload)\n        await asyncio.sleep(10)\n</code></pre>"},{"location":"plugins/backend/#inter-component-communication-with-redis","title":"Inter-Component Communication with Redis","text":"<p>Redis pub/sub is the backbone for real-time communication between all <code>tangram</code> components, including backend services, the frontend, and performance-critical Rust modules.</p>"},{"location":"plugins/backend/#communicating-with-the-frontend-via-websockets","title":"Communicating with the Frontend via WebSockets","text":"<p>The <code>channel</code> service acts as a transparent bridge between Redis and frontend WebSockets. A simple convention is used for routing messages:</p> <pre><code>graph TB\n    subgraph Frontend\n        direction TB\n        FC[Client]\n    end\n\n    subgraph Backend\n        direction TB\n        BP[Plugin]\n    end\n\n    WS[WebSocket Channel]\n    R[Redis Pub/Sub]\n\n    FC -- \"push('event', payload)\" --&gt; WS\n    WS -- \"PUBLISH from:channel:event\" --&gt; R\n    R -- \"LISTEN from:*\" --&gt; BP\n\n    BP -- \"PUBLISH to:channel:event\" --&gt; R\n    R -- \"LISTEN to:*\" --&gt; WS\n    WS -- \"on('event', payload)\" --&gt; FC</code></pre> <ul> <li>Backend to Frontend: To send a message to the frontend, publish it to a Redis channel prefixed with <code>to:&lt;channel_name&gt;:&lt;event_name&gt;</code>. The <code>channel</code> service relays this to the browser.</li> <li>Frontend to Backend: When the frontend sends a message, the <code>channel</code> service relays it to a Redis channel prefixed with <code>from:&lt;channel_name&gt;:&lt;event_name&gt;</code>.</li> </ul>"},{"location":"plugins/backend/#publishing-messages","title":"Publishing Messages","text":"<p>You can publish messages from any backend service using the Redis client available in <code>tangram_core.BackendState</code>.</p> PythonRust <pre><code># from within a service function\nredis_client = backend_state.redis_client\nawait redis_client.publish(\"to:system:update\", \"Hello from plugin\")\n</code></pre> <pre><code>let redis_client = redis::Client::open(\"redis://localhost:6379\").unwrap()?;\nlet mut con = redis_client.get_multiplexed_async_connection().await?;\ncon.publish(\"to:system:update\", \"Hello from plugin\").await?;\n</code></pre>"},{"location":"plugins/backend/#subscribing-to-messages","title":"Subscribing to Messages","text":"<p>To handle incoming messages, <code>tangram</code> provides a <code>Subscriber</code> base class. This is the recommended pattern for creating robust, long-running listeners within a service.</p> src/my_plugin/__init__.py<pre><code>import asyncio\nfrom dataclasses import dataclass\nimport tangram_core\nfrom tangram_core.redis import Subscriber\n\nplugin = tangram_core.Plugin()\n\n@dataclass\nclass CommandSubscriberState:\n    command_count: int = 0\n\nclass CommandSubscriber(Subscriber[CommandSubscriberState]):\n    \"\"\"A subscriber that listens for commands on a Redis channel.\"\"\"\n    async def message_handler(\n        self, event: str, payload: str, pattern: str, state: CommandSubscriberState\n    ) -&gt; None:\n        state.command_count += 1\n        print(f\"Command #{state.command_count} received on `{event}`: {payload}\")\n\n@plugin.register_service()\nasync def run_command_listener(backend_state: tangram_core.BackendState) -&gt; None:\n    \"\"\"This service listens for commands from the frontend.\"\"\"\n    subscriber = CommandSubscriber(\n        name=\"CommandListener\",\n        redis_url=backend_state.config.core.redis_url,\n        channels=[\"from:system:my-plugin-command\"],\n        initial_state=CommandSubscriberState(),\n    )\n    await subscriber.subscribe()\n    try:\n        await asyncio.Future()  # run forever\n    finally:\n        await subscriber.cleanup()\n</code></pre>"},{"location":"plugins/backend/#using-your-plugin","title":"Using Your Plugin","text":"<p>Install your package in the same environment as <code>tangram</code> and enable it in your <code>tangram.toml</code>:</p> <pre><code>[core]\nplugins = [\"my_tangram_plugin\"]\n</code></pre> <p>Run <code>tangram serve</code>. The core application will load your plugin, making its API endpoints available and starting its background services. The full API documentation, including your new endpoint, is available at http://localhost:2346/docs.</p>"},{"location":"plugins/explore/","title":"Explore Plugin","text":"<p>The <code>tangram_explore</code> plugin provides a quick way to spawn visualise arbitrary dataframes (polars/pandas) on the map.</p> <p>It is strongly inspired lonboard.</p>"},{"location":"plugins/explore/#overview","title":"Overview","text":"<ul> <li>Since the plugin sends the entire Parquet dataset to the browser for decoding and rendering, it is best suited for \"small\" data. Very large dataframes will lag the browser.</li> <li>Uses <code>arro3</code> to convert any dataframe supporting the Arrow C Stream Interface into Parquet bytes.</li> <li>Data is stored on the Python side and metadata is broadcasted to all connected clients.</li> <li>Browser fetches the Parquet data via HTTP, decodes it using <code>parquet-wasm</code>, and renders it using <code>deck.gl</code>.</li> </ul>"},{"location":"plugins/explore/#configuration","title":"Configuration","text":"<p>To enable this plugin, add <code>\"tangram_explore\"</code> to the <code>plugins</code> list in your <code>tangram.toml</code>.</p> tangram.toml<pre><code>[core]\nplugins = [\"tangram_explore\"]\n\n[plugins.tangram_explore]\nenable_3d = true\n</code></pre> <p>See <code>tangram_explore.ExploreConfig</code> for more information.</p>"},{"location":"plugins/explore/#future-work","title":"Future Work","text":"<ul> <li>Support for LineString and Polygon layers (requires GeoArrow processing).</li> <li>Drag-and-drop file upload in the sidebar.</li> <li>Synchronization</li> </ul>"},{"location":"plugins/explore/#examples","title":"Examples","text":""},{"location":"plugins/explore/#basic","title":"Basic","text":"<p>Spawn two intersecting diagonal lines as 100 scatter points, centred at (0, 0).</p> <p></p> Interactive (Jupytext)Script <pre><code># ruff: noqa: F704, E402\n# %%\nimport numpy as np\nimport polars as pl\nimport tangram_core\nfrom tangram_core.config import CoreConfig\n\nruntime = tangram_core.Runtime(\n    config=tangram_core.Config(core=CoreConfig(plugins=[\"tangram_explore\"]))\n)\nawait runtime.start()\n# %%\nfrom tangram_explore import ScatterLayer, Session\n\nsession = Session(runtime.state)\n\nx = np.linspace(-13, 13, 100)\n# %%\nawait session.push(\n    ScatterLayer(\n        pl.DataFrame({\"longitude\": x, \"latitude\": x}),\n        fill_color=\"#027ec7\",\n        label=\"NE-SW\",\n    )\n)\n# %%\nawait session.push(\n    ScatterLayer(\n        pl.DataFrame({\"longitude\": x, \"latitude\": -x}),\n        fill_color=\"#be4d5e\",\n        label=\"NW-SE\",\n    )\n)\n# %%\nawait runtime.stop()\n# %%\n</code></pre> <pre><code>import asyncio\n\nimport numpy as np\nimport polars as pl\nimport tangram_core\nfrom tangram_core.config import CoreConfig\nfrom tangram_explore import ScatterLayer, Session\n\n\nasync def main() -&gt; None:\n    async with tangram_core.Runtime(\n        config=tangram_core.Config(core=CoreConfig(plugins=[\"tangram_explore\"]))\n    ) as runtime:\n        session = Session(runtime.state)\n\n        x = np.linspace(-13, 13, 100)\n        await session.push(\n            ScatterLayer(\n                pl.DataFrame({\"longitude\": x, \"latitude\": x}),\n                fill_color=\"#027ec7\",\n                label=\"NE-SW\",\n            ),\n        )\n        await session.push(\n            ScatterLayer(\n                pl.DataFrame({\"longitude\": x, \"latitude\": -x}),\n                fill_color=\"#be4d5e\",\n                label=\"NW-SE\",\n            )\n        )\n        await runtime.wait()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"plugins/frontend/","title":"Frontend","text":"<p>Frontend plugins are standalone NPM packages that add new widgets and functionality to the <code>tangram</code> web interface. This system is designed for modularity, allowing you to build and share custom UI components.</p>"},{"location":"plugins/frontend/#1-project-structure","title":"1. Project Structure","text":"<p>A frontend plugin is a standard TypeScript/Vue project that produces a library build.</p> <pre><code>my-tangram-frontend-plugin/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 vite.config.ts\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 MyWidget.vue\n    \u2514\u2500\u2500 index.ts\n</code></pre>"},{"location":"plugins/frontend/#2-plugin-entry-point-indexts","title":"2. Plugin Entry Point (<code>index.ts</code>)","text":"<p>The <code>main</code> file specified in your <code>package.json</code> must export an <code>install</code> function. This function is the plugin's entry point and receives the <code>TangramApi</code> object, which provides methods for interacting with the core application.</p> src/index.ts<pre><code>import type { TangramApi } from \"@open-aviation/tangram-core/api\";\nimport MyWidget from \"./MyWidget.vue\";\n\nexport function install(api: TangramApi) {\n  // use the API to register a new widget component.\n  // the first argument is a unique ID for your widget.\n  // the second is the Vue component itself.\n  api.registerWidget(\"my-widget\", MyWidget);\n}\n</code></pre> <p>The <code>TangramApi</code> provides two main functions:</p> <ul> <li><code>registerWidget(id: string, component: Component)</code>: Makes your component available to the core UI.</li> <li><code>getVueApp(): App</code>: Provides access to the core Vue application instance for advanced use cases.</li> </ul>"},{"location":"plugins/frontend/#3-vite-configuration","title":"3. <code>vite</code> configuration","text":"<p>To simplify the build process, <code>tangram</code> provides a shared Vite plugin. This handles the complex configuration needed to build your plugin as a library and generate a <code>plugin.json</code> manifest file.</p> vite.config.ts<pre><code>import { defineConfig } from \"vite\";\nimport { tangramPlugin } from \"@open-aviation/tangram-core/vite-plugin\";\n\nexport default defineConfig({\n  plugins: [tangramPlugin()],\n});\n</code></pre> <p>This standardized build produces a <code>dist-frontend</code> directory containing your compiled JavaScript and the manifest file. <code>tangram</code> uses this manifest to discover and load your plugin.</p>"},{"location":"plugins/frontend/#4-building-and-using-your-plugin","title":"4. Building and using your plugin","text":"<p>First, build your frontend assets. If you are in the monorepo, <code>pnpm build</code> will handle this.</p> <p>Next, ensure the generated <code>dist-frontend</code> directory is included in your Python package's wheel. This is typically done in <code>pyproject.toml</code>.</p> hatchlingmaturin <pre><code>[tool.hatch.build.targets.wheel.force-include]\n\"dist-frontend\" = \"my_plugin/dist-frontend\"\n</code></pre> <p>Configuring <code>vite</code> to output to a subdirectory of your python source (e.g. <code>src/my_plugin/dist-frontend</code>) ensures <code>maturin</code> includes it automatically.</p> vite.config.ts<pre><code>build: {\n    outDir: path.resolve(__dirname, \"./src/my_plugin/dist-frontend\"),\n}\n</code></pre> <p>Finally, install your Python package and enable it in your <code>tangram.toml</code>:</p> <pre><code>[core]\nplugins = [\"my_tangram_plugin\"]\n</code></pre> <p>When <code>tangram serve</code> runs, it will:</p> <ol> <li>Read the <code>plugin.json</code> manifest from every enabled plugin at startup.</li> <li>Amalgamate these into a single cached response for <code>/manifest.json</code>.</li> <li>The core web app fetches this single manifest and dynamically loads resources.</li> </ol> <pre><code>sequenceDiagram\n    participant P as Plugin Module\n    participant B as Browser\n    participant S as Tangram Server\n\n    B-&gt;&gt;S: GET /manifest.json\n    S--&gt;&gt;B: Respond with {\"plugins\": {\"my_plugin\": {\"main\": \"index.js\"}}}\n    B-&gt;&gt;S: GET /plugins/my_plugin/index.js\n    S--&gt;&gt;B: Serve plugin's JS entry point\n    Note over B, P: Browser executes plugin code\n    P-&gt;&gt;B: install(tangramApi)\n    Note over B: Plugin registers its widgets</code></pre>"},{"location":"plugins/history/","title":"History Plugin","text":"<p>The <code>tangram_history</code> plugin provides a centralized, durable persistence layer for tangram. It ingests high-frequency, append-only time-series data from producer plugins (like <code>tangram_jet1090</code> or <code>tangram_ship162</code>) and stores it efficiently in Delta Lake tables.</p> <ul> <li>buffers incoming records in memory and flushes them periodically as larger, optimized parquet files.</li> <li>uses Delta Lake for transactional writes, schema enforcement, and compatibility with query engines (datafusion, polars, duckdb...).</li> <li>makes no assumptions about data content: producers register their own schemas and data retention policies.</li> </ul> <pre><code>sequenceDiagram\n    participant P as Producer (e.g., planes)\n    participant R as Redis\n    participant H as history service\n    participant C as Consumer (e.g., API endpoint)\n    participant D as Delta Lake (Filesystem)\n\n    note over P,H: startup\n    P-&gt;&gt;R: PUBLISH history:control, {type: \"register_table\", ...}\n    H--&gt;&gt;P: PUBLISH history:control:response:..., {type: \"table_registered\", ...}\n\n    loop real-time data\n        P-&gt;&gt;R: XADD history:ingest:&lt;table&gt;, *, \"data\", \"base64(arrow_ipc)\"\n    end\n\n    H--&gt;&gt;H: buffer batches in memory\n    H-&gt;&gt;D: periodically flush buffer to delta table\n\n    note over C,D: on-demand query\n    C-&gt;&gt;D: read delta table directly</code></pre>"},{"location":"plugins/history/#protocol","title":"Protocol","text":""},{"location":"plugins/history/#control-channel-historycontrol","title":"Control channel (<code>history:control</code>)","text":"<p>Used for managing tables. Producers must register a table and its schema before sending data.</p> <ul> <li>message: <code>register_table</code></li> <li>payload fields:<ul> <li><code>sender_id</code>: a unique id for the producer instance.</li> <li><code>table_name</code>: a unique name for the table (e.g., <code>\"aircraft_states\"</code>).</li> <li><code>schema</code>: base64-encoded arrow ipc schema bytes.</li> <li><code>partition_columns</code>: list of column names to partition by.</li> <li><code>optimize_interval_secs</code>: how often to run <code>optimize</code>.</li> <li><code>vacuum_interval_secs</code>: how often to run <code>vacuum</code>.</li> <li><code>vacuum_retention_period_secs</code>: retention for <code>vacuum</code>.</li> </ul> </li> </ul>"},{"location":"plugins/history/#ingest-stream-historyingesttable_name","title":"Ingest stream (<code>history:ingest:&lt;table_name&gt;</code>)","text":"<p>A fire-and-forget redis stream for producers to send data.</p> <ul> <li>command: <code>XADD</code></li> <li>payload: a key-value pair <code>data</code> and a base64-encoded arrow ipc recordbatch in stream format.</li> </ul>"},{"location":"plugins/history/#configuration","title":"Configuration","text":"<p>The history service itself has minimal configuration. All per-table settings are provided by the producer plugins that use it.</p> tangram.toml<pre><code>[core]\nplugins = [\"tangram_history\", \"tangram_jet1090\"]\n\n# global settings for the history service\n[plugins.tangram_history]\n# base path on the local filesystem for storing delta tables.\nbase_path = \"/tmp/tangram_history\"\n# redis channel for control messages.\ncontrol_channel = \"history:control\"\n\n# producer-specific settings\n[plugins.tangram_jet1090]\nhistory_table_name = \"jet1090\"\nhistory_flush_interval_secs = 5\n# ... other history settings for this table\n</code></pre> <p>See <code>tangram_history.HistoryConfig</code> for all available options.</p> <p>Warning</p> <p>Note that the Delta Lake protocol only supports a subset of Parquet primitive types.</p> <p>Notably, unsigned integers are not supported. To avoid data loss or unexpected wrap-around, ensure your producers use signed integer types (e.g., <code>i32</code>, <code>i64</code>) when defining schemas and generating Arrow record batches.</p>"},{"location":"plugins/jet1090/","title":"Jet1090 Plugin","text":"<p>The <code>tangram_jet1090</code> plugin is the primary tool for integrating Mode S and ADS-B data into the <code>tangram</code> framework. It processes raw aviation surveillance data from a <code>jet1090</code> instance and makes it available for both real-time visualization and historical analysis.</p>"},{"location":"plugins/jet1090/#overview","title":"Overview","text":"<p>This plugin consists of:</p> <ul> <li>A background service (planes) to maintain a real-time state of all visible aircraft and persist their data for historical queries.</li> <li>A REST API endpoint (<code>/data/{icao24}</code>) to fetch the full, time-ordered trajectory for a specific aircraft.</li> <li>A frontend widget to display a placeholder in the UI.</li> </ul>"},{"location":"plugins/jet1090/#planes-service","title":"<code>planes</code> Service","text":"<p>The <code>planes</code> service is the core of the real-time functionality. It is a Rust-based component, wrapped with PyO3 for integration into the Python ecosystem.</p> <pre><code>sequenceDiagram\n    participant J as jet1090\n    participant R as Redis\n    participant P as planes service\n    participant C as channel service\n    participant F as Frontend\n\n    J-&gt;&gt;R: PUBLISH jet1090 (raw message)\n    P-&gt;&gt;R: SUBSCRIBE jet1090\n    Note over P: Process message, update state vector\n    P-&gt;&gt;R: XADD history:ingest:jet1090, *, ...\n\n    F-&gt;&gt;C: PUSH system:bound-box\n    C-&gt;&gt;R: PUBLISH from:system:bound-box\n    P-&gt;&gt;R: SUBSCRIBE from:system:bound-box\n    Note over P: Update client's visible area\n\n    loop Every second\n        Note over P: Filter aircraft by each client's bbox\n        P-&gt;&gt;R: PUBLISH to:streaming-client1:new-jet1090-data\n    end\n\n    C-&gt;&gt;R: SUBSCRIBE to:streaming-client1:*\n    C-&gt;&gt;F: PUSH new-jet1090-data</code></pre> <ul> <li>Continuous Tracking: It subscribes to the <code>jet1090</code> Redis channel to receive decoded aircraft messages.</li> <li>State Vector Maintenance: It maintains a comprehensive in-memory view of the current air traffic situation by collecting and processing state vectors for all active aircraft.</li> <li>History Persistence: It acts as a producer for the <code>tangram_history</code> plugin. It batches raw messages into arrow Recordbatches and sends them to a redis stream. The history service consumes this stream and persists the data into a delta lake table. (Optional: requires <code>tangram_history</code> to be installed).</li> <li>Client-Specific Filtering: The service listens for bounding box updates from each connected frontend client. It filters the aircraft data for each client, sending only the aircraft visible within their map view.</li> <li>Data Publishing: Once per second, it publishes the filtered state vectors to a dedicated Redis channel for each client (e.g., <code>to:streaming-&lt;client_id&gt;:new-jet1090-data</code>), which are then relayed to the browser via the WebSocket <code>channel</code> service.</li> </ul>"},{"location":"plugins/jet1090/#redis-events","title":"Redis Events","text":"Direction Channel Event/Command Payload Input <code>jet1090</code> <code>PUBLISH</code> Raw JSON message from <code>jet1090</code>. Output <code>to:streaming-{id}:new-jet1090-data</code> <code>PUBLISH</code> <code>{ \"count\": 123, \"aircraft\": [...] }</code> containing visible aircraft. Output <code>history:ingest:jet1090</code> <code>XADD</code> Apache Arrow record batch (binary)."},{"location":"plugins/jet1090/#trajectory-api","title":"Trajectory API","text":"<p>The plugin provides an API for querying the historical data persisted by the <code>planes</code> service.</p> <p>Endpoint: <code>GET /jet1090/data/{icao24}</code></p> <p>Retrieves all historical data points for the given aircraft <code>icao24</code> by querying the delta lake table managed by the history service.</p> <p>This endpoint is used by the frontend to draw historical flight paths and populate data charts when an aircraft is selected.</p>"},{"location":"plugins/jet1090/#configuration","title":"Configuration","text":"<p>To use this plugin, you must have a running <code>jet1090</code> instance publishing data to Redis. You can also configure the plugin in your tangram.toml::</p> <pre><code>[core]\nplugins = [\"tangram_jet1090\", \"tangram_history\"]\n\n[plugins.tangram_jet1090]\n# the redis channel that jet1090 is publishing to.\njet1090_channel = \"jet1090\"\n# how long (in seconds) to keep an aircraft in the state vector table\n# after its last message.\nstate_vector_expire = 20\n\n# history persistence settings (requires `tangram_history` plugin)\nhistory_table_name = \"jet1090\"\nhistory_flush_interval_secs = 5\nhistory_buffer_size = 100000\n</code></pre> <p>See <code>tangram_jet1090.PlanesConfig</code> for all available options.</p>"},{"location":"plugins/overview/","title":"Plugins","text":"<p><code>tangram</code> is designed to be extended with plugins. This modular approach allows you to tailor the system to your specific needs, whether you are working with real-world ADS-B data, simulation outputs, or other data sources.</p> <p>Plugins are developed as standalone packages, enabling them to be versioned, tested, and distributed independently.</p> <ul> <li>Backend Plugins are installable Python packages that extend the server's functionality, typically by adding new API endpoints or background data processing services.</li> <li>Frontend Plugins are installable NPM packages that add new Vue.js components and widgets to the web interface.</li> </ul> <p>A single Python package can provide both backend and frontend components by bundling the pre-built frontend assets within its wheel distribution. This is the recommended approach for creating a cohesive feature.</p>"},{"location":"plugins/overview/#official-plugins-as-examples","title":"Official Plugins as Examples","text":"<p>The best way to learn how to build plugins is to study the official ones:</p> <ul> <li><code>tangram_example</code>: A minimal template demonstrating both backend and frontend plugin structure.</li> <li><code>tangram_system</code>: A simple plugin that adds a background service.</li> <li><code>tangram_jet1090</code>: A complex plugin that adds API routes, a background service for real-time data, and a historical trajectory API.</li> <li><code>tangram_weather</code>: A plugin that adds a new API endpoint for external data.</li> </ul>"},{"location":"plugins/ship162/","title":"Ship162 Plugin","text":"<p>The <code>tangram_ship162</code> plugin integrates AIS data from a <code>ship162</code> instance, enabling real-time visualization and historical analysis of maritime traffic.</p>"},{"location":"plugins/ship162/#overview","title":"Overview","text":"<ul> <li>a background service to maintain a real-time state of all visible ships and persist their data.</li> <li>a rest api endpoint (<code>/data/ship/{mmsi}</code>) to fetch the full, time-ordered trajectory for a specific ship.</li> <li>frontend components to render ships on the map and display detailed information.</li> </ul> <pre><code>sequenceDiagram\n    participant S as ship162\n    participant R as Redis\n    participant P as ships service\n    participant C as channel service\n    participant F as Frontend\n\n    S-&gt;&gt;R: PUBLISH ship162 (raw message)\n    P-&gt;&gt;R: SUBSCRIBE ship162\n    Note over P: Process message, update state vector\n    P-&gt;&gt;R: XADD history:ingest:ship162, *, ...\n\n    loop every second\n        Note over P: Filter ships by client's bbox\n        P-&gt;&gt;R: PUBLISH to:streaming-client1:new-ship162-data\n    end\n\n    C-&gt;&gt;R: SUBSCRIBE to:streaming-client1:*\n    C-&gt;&gt;F: PUSH new-ship162-data</code></pre>"},{"location":"plugins/ship162/#redis-events","title":"Redis Events","text":"Direction Channel Event/Command Payload Input <code>ship162</code> <code>PUBLISH</code> Raw JSON message from <code>ship162</code>. Output <code>to:streaming-{id}:new-ship162-data</code> <code>PUBLISH</code> <code>{ \"count\": 123, \"ship\": [...] }</code> containing visible ships. Output <code>history:ingest:ship162</code> <code>XADD</code> Apache Arrow record batch (binary)."},{"location":"plugins/ship162/#configuration","title":"Configuration","text":"<p>To use this plugin, you must have a running <code>ship162</code> instance publishing data to redis.</p> tangram.toml<pre><code>[core]\nplugins = [\"tangram_ship162\", \"tangram_history\"]\n\n[plugins.tangram_ship162]\n# redis channel that ship162 is publishing to.\nship162_channel = \"ship162\"\n\n# how long (in seconds) to keep a ship in the state vector table\n# after its last message.\nstate_vector_expire = 600\n\n# history persistence settings\nhistory_table_name = \"ship162\"\nhistory_flush_interval_secs = 5\nhistory_buffer_size = 100000\n</code></pre> <p>See <code>tangram_ship162.ShipsConfig</code> for all available options.</p>"},{"location":"plugins/system/","title":"System Plugin","text":"<p>The <code>tangram_system</code> plugin provides a background service that monitors and broadcasts server metrics like CPU load, RAM usage, and uptime. These metrics are displayed in the frontend UI.</p>"},{"location":"plugins/system/#how-it-works","title":"How It Works","text":"<ol> <li>The plugin's <code>pyproject.toml</code> registers its <code>plugin</code> object via the <code>tangram_core.plugins</code> entry point.</li> <li>This <code>plugin</code> object uses the <code>@plugin.register_service()</code> decorator to mark the <code>run_system</code> function as a background service.</li> <li>When <code>tangram serve</code> starts, the core framework discovers and runs the <code>run_system</code> service.</li> <li>It publishes these metrics as JSON payloads to the <code>to:system:update-node</code> Redis channel.</li> <li>The core <code>tangram</code> frontend is subscribed to the <code>system</code> WebSocket channel. The <code>channel</code> service forwards these Redis messages to the UI, where components like <code>SystemInfo.vue</code> update to display the live data.</li> </ol>"},{"location":"plugins/system/#redis-events","title":"Redis Events","text":"Direction Channel Event/Command Payload Output <code>to:system:update-node</code> <code>PUBLISH</code> <code>{\"el\": \"uptime\" \\| \"cpu_load\" \\| ..., \"value\": \"...\"}</code>"},{"location":"plugins/system/#configuration","title":"Configuration","text":"<p>To enable this plugin, add <code>\"tangram_system\"</code> to the <code>plugins</code> list in your <code>tangram.toml</code>.</p> tangram.toml<pre><code>[core]\nplugins = [\"tangram_system\"]\n\n[plugins.tangram_system]\n# UI positioning\ntopbar_order = 0\n</code></pre> <p>See <code>tangram_system.SystemConfig</code> for more information.</p>"},{"location":"plugins/weather/","title":"Weather Plugin","text":"<p>The <code>tangram_weather</code> plugin provides API endpoints to serve meteorological data, enabling features like wind field visualization on the map.</p>"},{"location":"plugins/weather/#overview","title":"Overview","text":"<p>This plugin fetches weather prediction data from Meteo-France's ARPEGE model, processes it, and exposes it via a REST API. The data is provided as GRIB files, which are downloaded and parsed on the backend.</p>"},{"location":"plugins/weather/#how-it-works","title":"How It Works","text":"<ol> <li> <p>The plugin downloads GRIB files containing ARPEGE weather model predictions from the public data.gouv.fr repository. These files are cached locally in a temporary directory.</p> </li> <li> <p>It registers a <code>/weather</code> router with the main FastAPI application. The key endpoint is <code>/weather/wind</code>.</p> </li> <li> <p>When a request is made to <code>/weather/wind?isobaric=&lt;level&gt;</code>, the plugin:</p> <ul> <li>Determines the latest available GRIB file for the current time.</li> <li>Uses <code>xarray</code> and <code>cfgrib</code> to open the GRIB file.</li> <li>Selects the U and V wind components for the specified isobaric pressure level (e.g., 300 hPa).</li> <li>Returns the data as a JSON response.</li> </ul> </li> <li> <p>The frontend <code>WindField.vue</code> component calls this endpoint.</p> </li> </ol>"},{"location":"plugins/examples/citypair/","title":"Origin and Destination","text":""},{"location":"plugins/examples/citypair/#statement-of-need","title":"Statement of need","text":"<p>The <code>tangram_jet1090</code> plugin includes a widget that displays the origin and destination information for a selected aircraft, showing both the airport ICAO codes and the city names. This makes it easy to quickly understand the flight's route without leaving the main map interface.</p>"},{"location":"plugins/examples/citypair/#implementation","title":"Implementation","text":"<p>The city pair widget is part of the <code>AircraftInfoWidget.vue</code> component, which appears in the sidebar when an aircraft is selected.</p> <p>It works as follows:</p> <ol> <li>When an aircraft is selected, the widget uses the aircraft's callsign to make a request to the <code>/route/{callsign}</code> API endpoint.</li> <li>This endpoint, provided by the <code>tangram_jet1090</code> backend plugin, proxies the request to the OpenSky Network's route database.</li> <li>If a route is found, the widget displays the origin and destination airport ICAO codes.</li> <li>It then uses the <code>rs1090-wasm</code> library (bundled with <code>tangram</code> core) to look up and display the corresponding city names for each airport.</li> </ol> <p>This functionality is self-contained within the <code>tangram_jet1090</code> plugin and requires no extra configuration beyond enabling the plugin itself.</p> <p></p> <p>Warning</p> <p>The OpenSky Network's route service is not guaranteed to be available for all aircraft. If no route information is found, the widget will display an appropriate message.</p>"},{"location":"plugins/examples/sensors/","title":"Data Receiver Map Layer","text":""},{"location":"plugins/examples/sensors/#statement-of-need","title":"Statement of need","text":"<p>Mode S data is provided by one or more <code>jet1090</code> processes, which decode data from various sources like software-defined radios or network streams. Each source corresponds to a receiver at a specific location.</p> <p>The <code>tangram_jet1090</code> plugin provides a map layer to visualize the positions of these receivers, allowing users to see where their data is coming from.</p>"},{"location":"plugins/examples/sensors/#implementation","title":"Implementation","text":"<p>The implementation is a Vue component, <code>SensorsLayer.vue</code>, which is registered as a map overlay by the <code>tangram_jet1090</code> frontend plugin. It uses Deck.gl to render the sensor locations.</p> <ol> <li>When the map is initialized, the component fetches a list of sensors from the <code>/sensors</code> API endpoint.</li> <li>This endpoint, provided by the <code>tangram_jet1090</code> backend, proxies the request to the configured <code>jet1090</code> service. The sensor information must be configured within the <code>jet1090</code> instance itself. See the jet1090 configuration guide for details.</li> <li>The component then maps the sensor data into an array of objects suitable for Deck.gl, with each object containing a <code>position</code> array (<code>[longitude, latitude]</code>), <code>name</code>, and <code>aircraft_count</code>.</li> <li>Finally, it creates a Deck.gl <code>ScatterplotLayer</code> to render the sensor locations as points on the map. The layer's <code>onHover</code> property is used to display a tooltip with the sensor's name and the number of aircraft it is currently tracking.</li> </ol>"},{"location":"plugins/examples/windfield/","title":"Add a wind field layer","text":""},{"location":"plugins/examples/windfield/#statement-of-need","title":"Statement of need","text":"<p>Meteorological data is essential for understanding the impact of weather on aviation operations. Meteo France provides weather prediction data from their ARPEGE model. The most basic features include zonal and meridional wind components, but also temperature, pressure, and humidity. More advanced features are also available but we will not cover them here.</p> <p>A web API is available after registration, but we will prefer here the GRIB files that can also be downloaded directly from the data.gouv.fr initiative, also provided by Meteo France under an Open License.</p> <p>New predictions are published every 6 hours, and the data is available for 3 days in advance. The data is provided in GRIB format, which is a standard format for meteorological data. In each file, each grid point represents spatio-temporal coordinates, and the data is provided for each hour of the day. The data is available at a resolution of 0.1 degrees, which is approximately 11 km at the equator. Altitude is provided in isobars, which is a standard unit for atmospheric pressure.</p>"},{"location":"plugins/examples/windfield/#implementation","title":"Implementation","text":"<p>The <code>tangram_weather</code> plugin displays a wind field on the map at a user-specified isobaric level. It consists of a backend service to provide the data and a frontend widget to control and display it.</p>"},{"location":"plugins/examples/windfield/#1-backend-wind-information-api","title":"1. Backend: Wind Information API","text":"<p>The <code>tangram_weather</code> plugin is a self-contained, installable Python package. Its <code>pyproject.toml</code> registers it as a <code>tangram</code> plugin via an entry point:</p> <pre><code>[project.entry-points.\"tangram_core.plugins\"]\ntangram_weather = \"tangram_weather:plugin\"\n</code></pre> <p>The plugin's <code>src/tangram_weather/__init__.py</code> file defines a FastAPI <code>APIRouter</code> and registers it with the <code>tangram_core</code> application.</p> <pre><code>import tangram_core\nfrom fastapi import APIRouter\n# ...\n\nrouter = APIRouter(...)\n\n@router.get(\"/wind\")\nasync def wind(isobaric: int = 300) -&gt; ORJSONResponse:\n    # ... implementation ...\n\nplugin = tangram_core.Plugin(routers=[router])\n</code></pre> <p>The plugin, associated with the <code>/weather</code> router will provide an API endpoint to fetch the wind field data for a specific isobar.</p> <p>The logic for downloading the data is implemented in the <code>arpege.py</code> file.</p> <p>The code is self-explanatory, but the following points are worth noting:</p> <ul> <li>in <code>__init__.py</code>, the <code>wind(isobaric: int)</code> function returns a <code>ORJSONResponse</code> (from <code>fastapi.responses</code>) rather than a <code>JSONResponse</code>. This is because the data is large and we want to avoid the overhead of converting it to JSON. The <code>ORJSONResponse</code> is a faster alternative, based on <code>orjson</code> that can handle large data efficiently. It also automatically deals with datetime objects, which are used in the GRIB data.</li> </ul> <p>Tip</p> <p>Extra Python libraries can be included with the <code>uv add</code> command.</p> <p>The command edits both the <code>pyproject.toml</code> and the <code>uv.lock</code> files:</p> <pre><code>uv add xarray cfgrib orjson\n</code></pre> <ul> <li> <p>in <code>arpege.py</code>, the download of the GRIB file is wrapped in a try/except block. If the file is not found (or Internet is momentarily unavailable), the function will try to get the previous file (6 hours before) and return it. It can be useful to fallback to older files when the newer versions are not yet available.</p> </li> <li> <p>the <code>xarray</code> library offers a <code>load_dataset</code> and an <code>open_dataset</code> function to read GRIB files. The <code>open_dataset</code> function is used here, as it allows to read the file without loading it entirely into memory, which is useful for large files.</p> </li> </ul> <p>Warning</p> <p>There is an issue with the packaging of the <code>ecCodes</code> library that is used by <code>xarray</code> to read GRIB files. The specific version of the <code>ecCodes</code> library for Linux/arm64 is not yet available at the time of writing this documentation.</p> <p>You are most likely to be impacted by this issue if you run this plugin on Apple Silicon Mac computers. In that case, you may want to run <code>just c-build eccodes_strategy='fromsource'</code> to create a new Docker image with the latest version of the <code>ecCodes</code> library. The <code>just c-run</code> command will then use this image to run the application.</p>"},{"location":"plugins/examples/windfield/#2-frontend-the-windfieldlayer","title":"2. Frontend: The <code>WindFieldLayer</code>","text":"<p>The frontend component, <code>WindFieldLayer.vue</code>, provides the user interface for the wind layer. It is rendered using Deck.gl and the <code>weatherlayers-gl</code> library for high-performance visualization.</p>"},{"location":"plugins/examples/windfield/#user-interface","title":"User Interface","text":"<p>The component renders a slider as a map overlay. This slider allows the user to select an isobaric level (in hPa) and displays the corresponding approximate flight level (FL). When the user changes the slider's value, the component calls the <code>/weather/wind</code> backend endpoint.</p>"},{"location":"plugins/examples/windfield/#wind-field-rendering-with-deckgl","title":"Wind Field Rendering with Deck.gl","text":"<p>The rendering process leverages WebGL for smooth particle animation:</p> <ol> <li>The backend API (<code>/weather/wind</code>) processes the GRIB file and returns the U and V wind components encoded as an RGBA PNG image (in a Base64 data URI), along with geographic bounds.</li> <li>The frontend decodes this image data into a texture.</li> <li>A <code>ParticleLayer</code> from <code>weatherlayers-gl</code> is created using this texture to visualize the wind flow with animated particles.</li> <li>This Deck.gl layer is added to the map via the <code>tangramApi</code>.</li> </ol>"},{"location":"plugins/examples/windfield/#3-enabling-the-plugin","title":"3. Enabling the Plugin","text":"<p>To use the wind field layer, install the <code>tangram_weather</code> package and add it to the <code>plugins</code> list in your <code>tangram.toml</code>:</p> <pre><code>[core]\nplugins = [\"tangram_weather\"]\n</code></pre> <p>After restarting <code>tangram</code>, the wind field widget will appear on the map. It may take a few moments to download the GRIB file the first time.</p> <p></p> <p>Tip</p> <p>Note that the wind field that is displayed for <code>TRA6424</code> is consistent with the groundspeed and true airspeed measured by the aircraft: 30 m/s (displayed on the lower right corner of the map) roughly corresponds to 60 kts, which is compatible with the delta in the speed values in the plot. Also a higher ground speed value is observed when the aircraft is flying with a strong tail wind.</p>"}]}