{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"An open platform for modular, real-time air traffic management research","text":"<p>tangram is an open research framework for ADS-B and Mode S flight surveillance data designed for various real-time aviation research topics such as GNSS jamming detection, aviation weather monitoring, emission analysis, and airport performance monitoring.</p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p>The system consists of a JavaScript-based web application and a backend based on Python or Rust when performance is crucial. The web application is designed to be modular, allowing users to implement their own plugins for data processing and analysis. The backend is responsible for data collection, storage, and processing, while the frontend provides a user-friendly interface for visualizing and interacting with the data.</p> <p>The whole framework is designed to be extensible, allowing researchers to develop and integrate their own plugins for specific research needs. This modularity enables the community to contribute to the platform, encouraging collaboration and knowledge sharing.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Quickstart: A step-by-step guide to get started with tangram</li> <li>Configuration: Information on how to configure the system for your needs</li> <li>Architecture: An overview of the system architecture and components</li> <li>Plugins: Extend the system with custom functionalities</li> <li>Contribute to tangram: Guidelines for contributing to the project</li> </ul>"},{"location":"#funding","title":"Funding","text":"<p>This project is currently funded by the Dutch Research Council (NWO)'s Open Science Fund, OSF23.1.051: https://www.nwo.nl/en/projects/osf231051.</p>"},{"location":"#history","title":"History","text":"<p>In 2020, @junzis and @xoolive published a paper Detecting and Measuring Turbulence from Mode S Surveillance Downlink Data on how real-time Mode S data can be used to detect turbulence.</p> <p>Based on this method, @MichelKhalaf started developing this tool as part of his training with @xoolive in 2021, which was completed in Summer 2022. After that, the project was then lightly maintained by @xoolive and @junzis, while we have been applying for funding to continue this tool.</p> <p>And in 2023, we received funding from NWO to continue the development of this tool. With this funding, @emctoo from Shinetech was hired to work alongside us on this open-source project.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Most of the configuration for the tangram platform will be done through environment variables and configuration files.</p> <p>These include:</p> <ul> <li>the <code>.env</code> file for environment variables;</li> <li>the <code>web/vite.config.js</code> file for the web application build configuration;</li> <li>the <code>config_jet1090.toml</code> file for the <code>jet1090</code> configuration relative to data sources.</li> </ul>"},{"location":"configuration/#environment-variables","title":"Environment variables","text":"<p>The <code>.env</code> file contains environment variables that configure the behaviour of the tangram platform. The file will be parsed by all the tools of the tangram suite.</p> <p>You can create this file from the template provided in the repository (<code>.env.example</code>)</p> <ul> <li><code>LOG_DIR</code> is the directory where logs will be stored. It defaults to <code>/tmp/tangram</code>, but you can change it to any directory you prefer.</li> <li> <p>The installation scripts should be aware of the <code>HTTP_PROXY</code> and <code>HTTPS_PROXY</code> environment variables, which are used to configure the proxy settings for the tools that require internet access.</p> </li> <li> <p><code>JET1090_CONFIG</code> is the path to the <code>jet1090</code> configuration file. It defaults to <code>config_jet1090.toml</code>, but you can change it to any file you prefer.</p> </li> <li><code>JET1090_URL</code> is the URL where the <code>jet1090</code> service will be available. It defaults to <code>http://jet1090:8080</code>, but you can change it to any URL you prefer.</li> <li><code>REDIS_URL</code> is the URL where the Redis service will be available. It defaults to <code>redis://redis:6379</code>, but you can change it to any URL you prefer.</li> </ul> <p>Warning</p> <ul> <li><code>localhost</code> refers to the current machine. When running containers, this will refer to the container itself;</li> <li><code>redis</code> and <code>jet1090</code> are the names of containers and should be automatically translated into the proper IP addresses;</li> <li>if you want to access the host machine from within a container, you can use <code>host.containers.internal</code> to refer to the host machine's IP address.</li> </ul> <p>The following services are run by default inside the tangram container:</p> <ul> <li><code>TANGRAM_SERVICE</code> is the URL where the tangram service will be available. It defaults to <code>http://127.0.0.1:2346</code> (inside the container), but you can change it to any URL you prefer.</li> <li><code>CHANNEL_SERVICE</code> is the URL where the channel service will be available. It defaults to <code>http://127.0.0.1:2347</code> (inside the container), but you can change it to any URL you prefer.</li> </ul>"},{"location":"configuration/#web-interface-configuration","title":"Web interface configuration","text":"<p>All the environment variables starting with <code>VITE_</code> are used to configure the web application build process. These variables are used by Vite, the build tool used for the web application.</p> <p>They must be prefixed with <code>VITE_</code> to be accessible in the web application code.</p> <ul> <li><code>VITE_TANGRAM_MAP_URL</code> is the URL of the map tile server.   It defaults to <code>https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png</code>, but you can change it to any tile server URL you prefer.</li> <li><code>VITE_LEAFLET_CENTER_LAT</code> is the latitude of the center of the Leaflet map. It defaults to <code>48</code>, but you can change it to any latitude you prefer.</li> <li><code>VITE_LEAFLET_CENTER_LON</code> is the longitude of the center of the Leaflet map. It defaults to <code>7</code>, but you can change it to any latitude you prefer.</li> <li><code>VITE_LEAFLET_ZOOM</code> is the default zoom level for the Leaflet map. It defaults to <code>6</code>, but you can change it to any zoom level you prefer.</li> </ul>"},{"location":"configuration/#plugin-configuration","title":"Plugin configuration","text":"<p>The paths for Vue files corresponding to plugins are also set in the <code>.env</code> file: they must follow the pattern <code>TANGRAM_WEB_&lt;component&gt;_PATH</code>, e.g. <code>TANGRAM_WEB_AWESOMEPLUGIN_PATH</code>. These paths can be customized as needed and edited in real time without rebuilding the web application. The web application will automatically pick up changes to these paths.</p> <p>The plugin components are expected to be in the <code>web/src/components/</code> directory (defined as <code>fallbackDir</code>), but you can override this path to point to any other directory containing Vue components.</p> <p>The plugins must be declared in the <code>vite.config.js</code> file, which is used to build the web application. You must also list <code>availablePlugins</code> that will be used to build the web application. The plugin component names must be the same as the names of the Vue files, without the <code>.vue</code> extension. Capitalization should be consistent with the file name.</p> <pre><code>plugins: [\n    // (abridged)\n    dynamicComponentsPlugin({\n      envPath: \"../.env\",\n      fallbackDir: \"/src/components/\",\n      availablePlugins: [\"awesomePlugin\", \"&lt;component&gt;\"],\n    }),\n  ],\n</code></pre>"},{"location":"configuration/#proxy-new-web-services","title":"Proxy new web services","text":"<p>Vite can also be configured to proxy requests to new web services. This is useful for integrating additional services into the tangram platform without modifying the existing codebase. To add a new service, you can modify the <code>vite.config.js</code> file to include a new proxy configuration. For example, to proxy requests to a service running on <code>http://localhost:3000</code>, you can add the following configuration:</p> <pre><code>proxy: {\n  '/newservice': {\n    target: 'http://localhost:3000',\n    changeOrigin: true,\n    secure: false,\n    rewrite: (path) =&gt; path.replace(/^\\/new-service/, ''),\n  },\n},\n</code></pre>"},{"location":"contribute/","title":"Contribute to tangram","text":"<p>We aim to provide a quality codebase with documentation, but expect that you will find bugs and issues, and hope you will also imagine very creative plugins.</p> <p>We welcome contributions to the project, whether it is code, documentation, or bug reports.</p>"},{"location":"contribute/#bug-reports","title":"Bug reports","text":"<p>Please file bug reports on the GitHub issue tracker.</p> <p>When filing a bug report, please include the following information:</p> <ul> <li>A clear description of the issue</li> <li>Steps to reproduce the issue</li> <li>Expected and actual behaviour</li> <li>Any relevant logs or error messages</li> <li>Your environment (OS, browser, etc.)</li> </ul>"},{"location":"contribute/#bug-fixes-and-contributions","title":"Bug fixes and contributions","text":"<p>If you want to contribute code, please follow these steps:</p> <ol> <li>Fork the repository on GitHub</li> <li>Create a new branch for your feature or bug fix</li> <li>Make your changes and commit them with a clear message</li> <li>Push your changes to your forked repository</li> <li>Create a pull request against the <code>main</code> branch of the original repository</li> <li>Include a clear description of your changes and why they are needed</li> <li>Ensure your code follows the project's coding standards and passes all tests</li> <li>If your changes are related to a specific issue, reference that issue in your pull request description</li> </ol>"},{"location":"contribute/#plugins","title":"Plugins","text":"<p>If you want to share a plugin you have developed, please start by sharing a preview in the Discussions</p>"},{"location":"contribute/#style-guide","title":"Style guide","text":"<p>We do not want to be too strict about the coding standards, but we expect that you will follow the general style guides of the rest of the codebase. Ensure your contribution doesn't reformat existing code unnecessarily, as this can make it harder to review changes.</p> <p>Please take into account the <code>.editorconfig</code> file in the root of the repository, which defines the coding style for the project. You can find more information about EditorConfig here and install plugins for your favourite editor.</p>"},{"location":"quickstart/","title":"Quickstart Guide for tangram","text":"<p>How to quickly set up and run tangram with basic visualizations of aviation data</p> <p>Warning</p> <p>The framework has only been tested on Linux and macOS.</p> <p>It may not work on Windows without additional configuration, but contributions to improve Windows compatibility are welcome!</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following tools installed:</p> <ol> <li> <p>just is a command runner, similar to <code>make</code>, that simplifies running commands in your project.</p> </li> <li> <p>podman is a container engine for developing, managing, and running containers, similar to Docker.</p> </li> </ol> <p>Tip</p> <p>You can have a running tangram instance in less than 5 minutes with these tools.</p> <p>It will also be possible to run some of the components outside of containers, but for the quickstart, we use containers to simplify the setup.</p>"},{"location":"quickstart/#1-environment-configuration","title":"1. Environment Configuration","text":"<p>Create an environment file from the template:</p> <pre><code>cp .env.example .env\n</code></pre> <p>The file contains default configurations for a basic demo setup. You can modify it later to suit your needs.</p>"},{"location":"quickstart/#2-build-containers","title":"2. Build Containers","text":"<p>Build the <code>tangram</code> and <code>jet1090</code> containers:</p> <pre><code>just build-tangram\njust build-jet1090\n</code></pre> <p>Note</p> <p>The <code>jet1090</code> executable can also be easily installed directly on your system if you prefer not to use a container. Check the jet1090 documentation for installation instructions. However, the default configuration works with a containerized version for simplicity.</p>"},{"location":"quickstart/#3-launch-redis","title":"3. Launch Redis","text":"<p>Start a Redis container for message passing and caching between different services:</p> <pre><code>just redis\n</code></pre> <p>This command will pull the Redis image if not already available and start the container.</p> <p>Note</p> <p>The redis container will keep running in the background, allowing other services to connect to it.</p> <p>You can check if Redis is running with:</p> <pre><code>podman container ls\n</code></pre> <p>You can stop the container with:</p> <pre><code>podman container stop redis\n</code></pre>"},{"location":"quickstart/#4-run-the-data-receiver","title":"4. Run the data receiver","text":"<p>Set up the data source parameters and run the <code>jet1090</code> container:</p> <pre><code>just jet1090\n</code></pre> <p>You should now see the <code>jet1090</code> console displaying data received from the source:</p> <p></p>"},{"location":"quickstart/#5-launch-tangram","title":"5. Launch tangram","text":"<p>In a new terminal, run the tangram container:</p> <pre><code>just tangram\n</code></pre> <p>The container is orchestrated using <code>process_compose</code>, which manages the various background processes required for tangram to function.</p> <p></p> <p>You may click on each process to see its logs in real-time. The <code>web</code> process is the web server that serves the tangram interface.</p>"},{"location":"quickstart/#6-access-the-web-interface","title":"6. Access the web interface","text":"<p>Open your browser and navigate to http://localhost:2345 to access the tangram web interface.</p> <p></p>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":"Issue Command Check the logs for errors <code>just tangram-log</code> Open a shell in the tangram container <code>just tangram-shell</code> Ensure all containers are running <code>podman container ls</code> Verify Redis connection <code>podman container exec -it redis redis-cli ping</code>"},{"location":"architecture/","title":"Architecture of the tangram framework","text":"<p>The tangram framework consists of a suite of independent components that can be combined to create a powerful and flexible aviation data processing and visualization system.</p> <p>The system consists of a web-based frontend (in Javascript  based on Vite), a backend service (in Python , and Rust  when performance is key).</p> <p>Communication between the frontend and backend is done through a REST API, while real-time data streaming is handled via WebSockets. The backend service aggregates data from multiple sources, processes it, and exposes it for visualization in the frontend.</p> <p>A Redis  pub/sub system is used for efficient data distribution between backend components.</p>"},{"location":"architecture/#overview-of-the-technologies-used","title":"Overview of the technologies used","text":"<p>It is not necessary to know all the technologies used in the tangram framework to use it effectively, and to implement your own plugins. However, it is useful to understand the architecture and how the components interact with each other.</p> Component Technology Frontend  JavaScript (Vue.js, Vite) Backend  Python for most applications (FastAPI for the REST API)  Rust for performance critical components Data communication  Redis (pub/sub messaging system) <p>Processes on the backend side communicate with each other using a pub/sub mechanism provided by Redis. The frontend communicates with the backend service through a REST API for simple requests and a WebSocket connection for real-time data streaming.</p>"},{"location":"architecture/#system-overview","title":"System overview","text":"Backend component Description <code>jet1090</code> decode Mode S and ADS-B messages <code>planes</code> maintain a state vector table of aircraft <code>trajectory</code> get the history of data for a given aircraft <code>tangram</code> REST API for data retrieval and management <code>channel</code> WebSocket connection for real-time updates"},{"location":"architecture/#backend-components","title":"Backend components","text":""},{"location":"architecture/#jet1090","title":"jet1090","text":"<p>Documentation: https://mode-s.org/jet1090</p> <p><code>jet1090</code> is a Rust-based ADS-B decoder that can be used to decode ADS-B messages from a variety of sources, including software-defined radio devices and network streams such as those provided by commercial ADS-B receivers. It is designed to be fast and efficient, making it suitable for real-time applications.</p>"},{"location":"architecture/#planes","title":"planes","text":"<p>Documentation: planes</p> <p><code>planes</code> is a Python-based component that maintains a state vector table of aircraft. It is responsible for tracking the position and other parameters of aircraft in real-time. The component uses the data provided by <code>jet1090</code> to update the state vector table and provide real-time information about the aircraft.</p> <p>A state vector table is a data structure that contains the latest information about all the parameters of the aircraft. This is necessary because all ADS-B messages do not provide all the parameters of the aircraft at once. In particular the position, the speed, the track angle and the identification all come in different messages. Having the most recent information along all the possible features is usually enough to display the aircraft on a map.</p>"},{"location":"architecture/#trajectory","title":"trajectory","text":"<p>Documentation: trajectory</p> <p><code>trajectory</code> is a Python-based component that provides a history of data for a given aircraft. It is responsible for storing and retrieving historical data about the aircraft's position and other parameters. The component uses the data stored by the Redis system and reformat it to be used by the frontend in a more standard JSON-like format. This is useful to be able to display the trajectory of an aircraft on a map, as well as to provide historical data for plotting, e.g. altitude, speed, vertical rate, etc.</p>"},{"location":"architecture/#tangram-rest-api","title":"tangram REST API","text":"<p>Documentation: available when you run the service at http://localhost:2345/tangram/docs</p> <p>The <code>tangram</code> component is a Python-based REST API that provides data retrieval and management capabilities. It is responsible for handling requests from the frontend and providing the necessary data for visualization and analysis. The API is designed to be modular and extensible, allowing researchers to add their own endpoints and functionality as needed.</p> <p>Basic endpoints provided by the API include the data from <code>trajectory</code> and <code>planes</code>. Other endpoints are provided to facilitate the use of other data such as meteorological data through <code>fastmeteo</code> (https://github.com/open-aviation/fastmeteo). Since the component is based on FastAPI, it also possible to dynamically add new endpoints to the API at the plugin level. This allows researchers to create their own endpoints for specific research needs, such as custom data processing or analysis.</p>"},{"location":"architecture/#channel","title":"channel","text":"<p>Documentation: channel</p> <p>The <code>channel</code> (https://github.com/emctoo/channel) component is a Rust-based WebSocket connection that makes the bridge between the frontend and the Redis pub/sub system. It is responsible for providing real-time updates from and to the frontend.</p> <p>For instance, state vectors updates from the <code>planes</code> component are sent on the Redis pub/sub and the <code>channel</code> tool listens to the channel before sending the data to the frontend through a WebSocket. Conversely, the bounding box of the map is sent from the frontend to the <code>channel</code> component, which then sends it on the Redis pub/sub system. For example, the <code>planes</code> component listens to this channel and updates the state vector table accordingly.</p>"},{"location":"architecture/#frontend-architecture","title":"Frontend architecture","text":"<p>The frontend is based on Vue.js and provides a dynamic, real-time visualization interface for aviation data. It is designed to be modular, allowing users to implement their own plugins for data visualization and analysis.</p> <p>The entry point is the <code>App.vue</code> file, which initializes the application and sets up the main component. At this point, the webpage is divided into:</p> <ul> <li>a main content area in the center, which displays the map with the visible aircraft;</li> <li>a navigation bar at the top, described in <code>components/TopNavBar.vue</code>;</li> <li>a sidebar on the left, described in <code>components/LeftSideBar.vue</code>, which pops up when the user clicks on an aircraft on the map.</li> </ul> <p>Most other components (located in the <code>components/</code> directory) are referred to from the main <code>App.vue</code> file or from other components.</p> <p>Extensions of the web application are described in the Plugins section.</p>"},{"location":"architecture/#containers-and-process-management","title":"Containers and process management","text":"<p>By default, most components run within a single container managed by <code>process-compose</code>. The tool handles process startup and shutdown; manages dependencies between processes; provides process monitoring and logging. This architecture is defined in <code>container/process-compose.yaml</code> and can be extended to include additional services.</p> <p>The description of the tangram container is defined in <code>container/tangram.Containerfile</code>.</p> <p>The two components which are not running in the <code>tangram</code> container are the services that are the most natural to run on a different node:</p> <ul> <li>the Redis service, which runs in its own default container;</li> <li>the <code>jet1090</code> component, which also runs in its own container to allow for easier updates.</li> </ul> <p>Tip</p> <p>If you want to use <code>jet1090</code> with a RTL-SDR dongle, it could be easier to configure it outside of the container as it requires access to the USB device.</p>"},{"location":"architecture/channel/","title":"Channel: WebSocket Communication Service","text":"<p>The Channel component is a Rust implementation that provides real-time bidirectional communication for Tangram using WebSockets. It implements a subset of the Phoenix Channels protocol, enabling seamless integration with both the frontend and backend components through Redis pub/sub messaging.</p>"},{"location":"architecture/channel/#overview","title":"Overview","text":"<p>Channel serves as the central communication hub in Tangram, connecting the frontend visualization with the backend processing plugins. It manages WebSocket connections, handles client authentication, and facilitates the bidirectional flow of data through Redis.</p>"},{"location":"architecture/channel/#key-features","title":"Key Features","text":"<ul> <li>Phoenix Channels Protocol: Implements a subset of the Phoenix Channels protocol for WebSocket communication</li> <li>Channel-based Communication: Supports multiple named channels that clients can join and leave</li> <li>Redis Integration: Uses Redis pub/sub for message distribution between components</li> <li>JWT Authentication: Secures channel access with JSON Web Tokens</li> <li>Presence Tracking: Tracks and broadcasts client presence information</li> </ul>"},{"location":"architecture/channel/#communication-flow","title":"Communication Flow","text":""},{"location":"architecture/channel/#backend-to-frontend","title":"Backend to Frontend","text":"<ol> <li>Backend plugins publish messages to Redis topics in the format <code>to:&lt;channel&gt;:&lt;event&gt;</code></li> <li>Channel subscribes to these Redis topics and listens for messages</li> <li>When a message is received, Channel forwards it to all WebSocket clients connected to the specified channel</li> <li>Clients receive the message and can update their visualizations in real-time</li> </ol>"},{"location":"architecture/channel/#frontend-to-backend","title":"Frontend to Backend","text":"<ol> <li>WebSocket clients send messages to a specific channel with an event name</li> <li>Channel receives these messages and publishes them to Redis topics in the format <code>from:&lt;channel&gt;:&lt;event&gt;</code></li> <li>Backend plugins subscribe to these Redis topics to receive client messages</li> <li>Plugins process the messages and can respond by publishing back to <code>to:&lt;channel&gt;:&lt;event&gt;</code></li> </ol>"},{"location":"architecture/channel/#channel-protocol","title":"Channel Protocol","text":"<p>The WebSocket protocol follows the Phoenix Channels message format, which uses JSON arrays with the following structure:</p> <pre><code>[join_ref, ref, topic, event, payload]\n</code></pre> <p>Where:</p> <ul> <li><code>join_ref</code>: Reference to the channel join request (null for system messages)</li> <li><code>ref</code>: Message reference for tracking responses</li> <li><code>topic</code>: Channel name</li> <li><code>event</code>: Event name</li> <li><code>payload</code>: Message data</li> </ul>"},{"location":"architecture/channel/#events","title":"Events","text":"<ul> <li><code>phx_join</code>: Join a channel (requires JWT token)</li> <li><code>phx_leave</code>: Leave a channel</li> <li><code>phx_reply</code>: Acknowledgment of a message</li> <li><code>presence_state</code>: Current state of all clients in a channel</li> <li><code>presence_diff</code>: Changes in channel presence</li> <li>Custom events: Any custom event name can be used for application-specific messages</li> </ul>"},{"location":"architecture/channel/#usage-in-tangram","title":"Usage in Tangram","text":""},{"location":"architecture/channel/#predefined-channels","title":"Predefined Channels","text":"<ul> <li><code>phoenix</code>: System channel for heartbeats and connection management</li> <li><code>admin</code>: Administrative channel for monitoring and control</li> <li><code>system</code>: General system information (includes regular datetime broadcasts)</li> <li>Custom channels: Application-specific channels can be created dynamically</li> </ul>"},{"location":"architecture/channel/#client-connection","title":"Client Connection","text":"<p>Clients connect to the WebSocket endpoint and can join multiple channels:</p> <pre><code>// Connect to the WebSocket\nconst socket = new Phoenix.Socket(\"/websocket\", {\n  params: { userToken: token },\n});\nsocket.connect();\n\n// Join a channel\nconst channel = socket.channel(\"system\", { token: systemToken });\nchannel\n  .join()\n  .receive(\"ok\", (response) =&gt; console.log(\"Joined successfully\", response))\n  .receive(\"error\", (response) =&gt; console.log(\"Join failed\", response));\n\n// Listen for events\nchannel.on(\"datetime\", (payload) =&gt; {\n  console.log(\"Current time:\", payload.response.datetime);\n});\n\n// Send events\nchannel.push(\"custom_event\", { message: \"Hello from client\" });\n</code></pre>"},{"location":"architecture/channel/#backend-integration","title":"Backend Integration","text":"<p>Backend plugins can communicate with the frontend by using Redis pub/sub:</p> <pre><code>import redis\nimport json\n\nr = redis.Redis()\n\n# Send message to frontend clients\nr.publish('to:system:update', json.dumps({\n    'type': 'message',\n    'message': 'Update from backend'\n}))\n\n# Listen for messages from frontend\np = r.pubsub()\np.psubscribe('from:system:*')\nfor message in p.listen():\n    if message['type'] == 'pmessage':\n        print(f\"Received: {message['data']}\")\n</code></pre>"},{"location":"architecture/channel/#running-the-channel-service","title":"Running the Channel Service","text":"<p>The Channel service is containerized for easy deployment:</p> <pre><code># Pull the Channel image\npodman pull ghcr.io/emctoo/channel:latest\n\n# Run the Channel service\npodman run -it --rm --name channel --network host \\\n  ghcr.io/emctoo/channel:latest \\\n  channel --redis-url redis://localhost:6379 --jwt-secret your-secret-key\n</code></pre>"},{"location":"architecture/channel/#configuration-options","title":"Configuration Options","text":"<ul> <li><code>--host</code>: Host address to bind to (default: 127.0.0.1)</li> <li><code>--port</code>: Port to listen on (default: 2025)</li> <li><code>--redis-url</code>: Redis connection URL</li> <li><code>--jwt-secret</code>: Secret key for JWT authentication</li> <li><code>--static-path</code>: Path to static assets directory (default: assets)</li> </ul>"},{"location":"architecture/channel/#token-authentication","title":"Token Authentication","text":"<p>Channels require JWT tokens for authentication. Tokens can be requested from the <code>/token</code> endpoint:</p> <pre><code>curl -X POST http://localhost:2025/token \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"channel\": \"system\", \"id\": \"client1\"}'\n</code></pre> <p>The response includes a JWT token that can be used for channel authentication:</p> <pre><code>{\n  \"id\": \"client1\",\n  \"channel\": \"system\",\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n</code></pre>"},{"location":"architecture/channel/#deployment-testing-and-debugging","title":"Deployment, Testing and Debugging","text":"<p>During development, the channel service operates within the container through process-manager (defined in <code>../container/process-compose.yaml</code>). To enable browser communication with this service, a WebSocket proxy is configured in <code>../web/vite.config.js</code>. This proxy prioritizes the endpoint specified in the <code>CHANNEL_SERVICE</code> environment variable, defaulting to <code>localhost:2025</code> within the container if no value is provided. For more flexible deployment options, you can run the service on a separate node and specify its location in the <code>.env</code> file.</p> <p>The Channel service includes an admin interface for monitoring connections and messages:</p> <ul> <li>Admin Interface: Available at <code>http://localhost:2025/admin.html</code></li> <li>Client Test Page: Available at <code>http://localhost:2025?name=testuser</code></li> </ul> <p>(FIXME: <code>rust-embed</code> for assets embedding)</p>"},{"location":"architecture/channel/#redis-commands-for-debugging","title":"Redis Commands for Debugging","text":"<pre><code># Subscribe to all outgoing messages from clients\nredis-cli psubscribe \"from:*\"\n\n# Subscribe to all incoming messages to clients\nredis-cli psubscribe \"to:*\"\n\n# Publish a test message to clients\nredis-cli publish \"to:system:test\" '{\"type\":\"message\",\"message\":\"Test from Redis\"}'\n</code></pre>"},{"location":"architecture/channel/#progressive-integration-in-tangram","title":"Progressive Integration in Tangram","text":"<p>The Channel component enables the progressive development approach in Tangram:</p> <ol> <li>Basic API Integration: Start with conventional REST API calls</li> <li>Enhanced Processing: Add WebSocket capabilities for specific real-time features</li> <li>Real-time Streaming: Fully leverage the WebSocket infrastructure for comprehensive real-time visualization</li> </ol> <p>By separating the communication layer from both the frontend and backend, Channel allows teams to adopt real-time capabilities at their own pace while maintaining backward compatibility with existing systems.</p>"},{"location":"architecture/channel/#channel-streaming-service","title":"Channel (Streaming Service)","text":"<p>The Channel component is a high-performance Rust implementation that handles real-time data streaming:</p> <ul> <li>WebSocket server for frontend connections</li> <li>Integration with Redis for pub/sub messaging</li> <li>Efficient data serialization and transmission</li> <li>Connection management and error handling</li> </ul> <p>This component enables the real-time nature of Tangram, allowing for immediate visualization of incoming aviation data.</p>"},{"location":"architecture/planes/","title":"planes","text":""},{"location":"architecture/trajectory/","title":"trajectory","text":""},{"location":"plugins/","title":"Plugins","text":"<p>The tangram platform can be extended with plugins to enhance its functionality. Plugins can be developed for both the frontend and the backend.</p> <ul> <li> <p>Frontend plugins are Vue.js components that can be dynamically loaded into the web application</p> </li> <li> <p>Backend plugins are processes (e.g. in Python) that extend the backend functionality, and include data processing, analysis, and API endpoints</p> </li> </ul> <p>Examples of plugins:</p> <ul> <li>Map data receivers: display the sensors' positions on the map</li> <li>Wind fields: display the wind field on the map using weather prediction data</li> <li>Origin and destination city pair: display the origin and destination airports of flights</li> <li>Contrails: display the contrails on the map using weather prediction data</li> </ul>"},{"location":"plugins/backend/","title":"Implement a backend plugin","text":"<p>Implementing a backend plugin for tangram involves creating a standalone application (in Python or any other language) than can communicate with other components of the tangram system. This process should be able to:</p> <ul> <li>provide additional REST API endpoints;</li> <li>process real-time data through the Redis pub/sub</li> </ul>"},{"location":"plugins/backend/#rest-api-endpoint","title":"REST API endpoint","text":"<p>Queries to the tangram endpoint is a very easy task. Any HTTP client can do the job, e.g. <code>httpx</code> in Python or <code>reqwest</code> in Rust. The REST API is provided by the tangram service, which is a FastAPI application.</p> <p>The API documentation is available at http://localhost:2345/tangram/docs when the service is running.</p> <p>Implementing a new endpoint requires a bit more work. Here, you have two possibilities:</p> <ul> <li> <p>create a new endpoint on a different port, and use the <code>vite.config.js</code> configuration file to proxy requests to this endpoint.</p> </li> <li> <p>integrate your plugin with the main FastAPI application with the FastAPI router system. This allows you to add new endpoints to the main API while maintaining separation of concerns.</p> </li> </ul>"},{"location":"plugins/backend/#proxy-to-external-resources","title":"Proxy to external resources","text":"<p>This is the simplest way to implement a new endpoint, as you can use any programming language, any web framework you like (Flask, FastAPI, etc.) and run the process on any node. The frontend will be able to access this endpoint through the proxy configuration.</p> <p>In the <code>vite.config.js</code> file, you can add a proxy configuration to redirect requests to your plugin:</p> <pre><code>server: {\n  proxy: {\n    \"/api/my-plugin\": `${host_address}:8001`, // where you serve your new process\n    changeOrigin: true,\n    rewrite: (path) =&gt; path.replace(/^\\/api\\/my-plugin/, ''),\n  },\n},\n</code></pre>"},{"location":"plugins/backend/#extend-the-fastapi-application","title":"Extend the FastAPI application","text":"<p>Warning</p> <p>This approach is only possible in Python as the base backend is also implemented in Python using FastAPI. If you want to implement a plugin in another language, you should use the proxy approach described above.</p> <p>For more complex plugins that need to integrate directly with the main FastAPI application, you can use FastAPI's router system. This approach allows your plugin to add endpoints to the main API while maintaining separation of concerns.</p> <p>Tip</p> <p>The upside of this approach is that you can reuse all instances of the FastAPI application.</p> <p>The <code>docs/</code> endpoint will also automatically include your new endpoints in the API documentation.</p> <p>In order to implement a FastAPI plugin, you need to create a Python package with a <code>__init__.py</code> file that defines the plugin's endpoints. Plugins can be located in the <code>src/tangram/plugins/</code> directory, and they should be structured as Python packages.</p> <p>The main FastAPI application will automatically discover and register these plugins if they follow the naming convention and include an <code>__init__.py</code> file.</p> <pre><code>from fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\n# Create a router for your plugin\nrouter = APIRouter(\n    prefix=\"/example\",  # All routes will be prefixed with /example\n    tags=[\"example\"],  # For API documentation organization\n    responses={404: {\"description\": \"Not found\"}},\n)\n\n\nclass ExampleResponse(BaseModel):\n    data: str\n\n\n# Define endpoints on your router\n@router.get(\"/\", response_model=ExampleResponse)\nasync def get_example() -&gt; ExampleResponse:\n    \"An example endpoint that returns some data.\"\n    return ExampleResponse(data=\"This is an example plugin response\")\n\n\n# This function will be called by the main FastAPI application\n# Place it in __init__.py to register the plugin\ndef register_plugin(app: FastAPI) -&gt; None:\n    \"\"\"Register this plugin with the main FastAPI application.\"\"\"\n    app.include_router(router)\n</code></pre> <p>Warning</p> <p>Note that there is no activate/deactivate mechanism for backend plugins. If they are found in the <code>src/tangram/plugins/</code> directory, they will be automatically registered when the main FastAPI application starts.</p> <p>This is insignificant for most plugins creating new endpoints as they are usually stateless. However, if your plugin has a state (e.g. it subscribes to Redis channels, consume heavy resources at load time, etc.), then you may want to deactivate it. In that case, we recommend that you read an environment variable and conditionally execute commands in the <code>register_plugin</code> function. This way, you can control whether the plugin is active or not based on the environment variable.</p>"},{"location":"plugins/backend/#communicate-with-redis","title":"Communicate with Redis","text":"<p>Receiving and sending data from Redis is a common task for backend plugins. The process is based on a pub/sub system, where the plugin subscribes to specific channels to receive messages and can publish messages to other channels.</p>"},{"location":"plugins/backend/#send-messages-to-redis","title":"Send messages to Redis","text":"<p>This is a straightforward task, regardless the programming language you use.</p> PythonRust <p>Use the <code>redis</code> Python package to publish messages to Redis channels:</p> <pre><code>import redis\n\nredis_client = redis.Redis.from_url(\"redis://localhost:6379\")\nredis_client.publish(\"to:system:update\", \"Hello from plugin\")\n</code></pre> <p>Use the <code>redis</code> crate to publish messages to Redis channels:</p> <pre><code>let redis_client = redis::Client::open(\"redis://localhost:6379\").unwrap()?;\nlet mut con = redis_client.get_multiplexed_async_connection().await?;\ncon.publish(\"to:system:update\", \"Hello from plugin\").await?;\n</code></pre>"},{"location":"plugins/backend/#receiving-messages-from-redis","title":"Receiving messages from Redis","text":"<p>The main difference between Redis messages and HTTP requests is that Redis messages are sent in real-time, while HTTP requests are stateless and can be processed at any time. This means that your plugin should be able to handle incoming messages asynchronously.</p> <p>In Python, the <code>tangram</code> package provides a convenient way to interact with Redis based on the <code>redis-py</code> library. We provide a helper class to manage the connection, subscriptions, and message processing.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import NoReturn\n\nfrom tangram.common.redis import Subscriber\n\n@dataclass\nclass CurrentState:\n    \"\"\"A class to hold the current state of the plugin.\"\"\"\n    icao24: set[str]\n\nclass AircraftSubscriber(Subscriber[CurrentState]):\n    \"\"\"A subscriber that listens to aircraft updates.\"\"\"\n\n    async def message_handler(self, event: str, payload: str, pattern: str, state: CurrentState) -&gt; None:\n        # Process the message and update the state\n        # For example, you can parse the message and update the icao24 set\n        data = json.loads(message)\n        state.icao24.add(data[\"icao24\"])\n\nasync def main() -&gt; NoReturn:\n    # Run the subscriber to listen for aircraft updates in the main loop\n    initial_state = CurrentState(icao24=set())\n    aircraft_subscriber = AircraftSubscriber(\n        redis_client=\"redis://localhost:6379\",\n        channels=[\"jet1090\"],\n        initial_state=initial_state,\n    )\n    # This call returns after creating a task running in the background\n    await aircraft_subscriber.subscribe()\n\n    while True:\n        ...  # your main application logic here\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"plugins/backend/#plugin-to-websocket-events","title":"Plugin to WebSocket events","text":"<p>To send messages to the frontend through the WebSocket connection, you can use the <code>channel</code> service. This service listens to Redis channels and forwards messages to the frontend clients.</p> <p>The convention on the Redis channels is to use the <code>to:system:</code> prefix for messages sent from the backend to the frontend, and <code>from:system:</code> for messages sent from the frontend to the backend.</p> <p>For instance, every time the map is moved or zoomed, the frontend sends a WebSocket message on the <code>bound-box</code> channel, which is then forwarded by <code>channel</code> on the Redis using the <code>from:system:bound-box</code> label. Conversely, state vector updates from the backend components are sent on the <code>to:streaming-(*):new-data</code> channel, which is then forwarded to the frontend clients labelled as <code>new-data</code>.<sup>1</sup></p> <ol> <li> <p>The <code>(*)</code> placeholder is to be replaced by a unique identifier assigned to a session (When many browsers are connected to the same tangram service, they may be focused on different areas of the map, and thus receive different data).\u00a0\u21a9</p> </li> </ol>"},{"location":"plugins/frontend/","title":"Implement a frontend plugin","text":"<p>Frontend plugins are Vue.js components that can be dynamically loaded into the tangram web application. The common use case is to get data from the backend (REST API or Websocket) and display it in a custom way, such as on a map or in a table.</p>"},{"location":"plugins/frontend/#vue-components","title":"Vue components","text":"<p>The core Vue components are currently located in the <code>src/components/</code> directory: plugins can be added to this directory (default fallback location) or in a custom directory, then the full path will be specified as an environment variable.</p> <p>The usual way to import a component in a vue file is to import it like this:</p> <pre><code>import MyPlugin from \"./components/MyPlugin.vue\";\n</code></pre> <p>then to include a node in the template:</p> <pre><code>&lt;MyPlugin /&gt;\n</code></pre> <p>A plugin component will be imported a bit differently, as it is usually not located in the <code>src/components/</code> directory. Instead, it will be imported dynamically based on the environment variable <code>TANGRAM_WEB_MYPLUGIN_PLUGIN</code>. The environment variable shall be defined in the <code>.env</code> file, and it should point to the full path of the plugin component file. Then the component should be declared in the <code>vite.config.js</code> file, which is responsible for loading the Vue components dynamically:</p> <pre><code>plugins: [\n  // ..., other settings\n  dynamicComponentsPlugin({\n    envPath: \"../.env\",\n    fallbackDir: \"./src/plugins/\",\n    availablePlugins: [\n      \"airportSearch\",\n      \"systemInfo\",\n      \"sensorsInfo\",\n      \"cityPair\",\n      // list all your plugins here\n      \"myPlugin\", // This is your custom plugin\n    ],\n  }),\n];\n</code></pre> <p>Then you will be able to include the node in the template part of another component like this:</p> <pre><code>&lt;template&gt;\n  &lt;plugin-myplugin /&gt;\n&lt;/template&gt;\n</code></pre> <p>Tip</p> <p>There is one use case where it is convenient to have a plugin in the default <code>src/components/</code> directory.</p> <p>In some cases, you would like to have several possible implementations for a functionality. This can be done in several Vue files, and you can switch the full path to the file in the <code>.env</code> file. If the environment variable is not defined, the plugin will be loaded from the default <code>src/components/</code> directory.</p> <code>TANGRAM_WEB_MYPLUGIN_PLUGIN</code> Resulting component path undefined <code>src/plugins/MyPlugin.vue</code> <code>/path/to/plugins/MyPlugin1.vue</code> <code>/path/to/plugins/MyPlugin1.vue</code> <code>/path/to/plugins/MyPlugin2.vue</code> <code>/path/to/plugins/MyPlugin2.vue</code> <p>Example usage:</p> <ul> <li>Map data receivers</li> </ul>"},{"location":"plugins/frontend/#technical-details","title":"Technical details","text":""},{"location":"plugins/frontend/#registration-process","title":"Registration process","text":"<p>When Tangram initializes, the plugin system:</p> <ol> <li>reads the list of available plugins</li> <li>checks for environment variable overrides</li> <li>imports components from the specified paths or fallbacks</li> <li>registers the components with the Vue application</li> </ol>"},{"location":"plugins/frontend/#hot-reloading","title":"Hot reloading","text":"<p>The plugin system monitors any change to the environment configuration and:</p> <ul> <li>Invalidates cached module definitions</li> <li>Reloads the plugin components</li> <li>Triggers a page refresh to show the updated components</li> </ul>"},{"location":"plugins/frontend/#implementation-details","title":"Implementation Details","text":"<p>The dynamic component system is implemented as a Vite plugin (<code>vite-plugin-dynamic-components.js</code>) that:</p> <ol> <li>Creates a virtual module (<code>virtual:plugin-components</code>) at build time</li> <li>Dynamically generates import statements based on environment configuration</li> <li>Exports a <code>registerComponents</code> function that Vue uses during initialization</li> <li>Watches for changes to the environment variables</li> </ol> <p>Key functions in the implementation:</p> <ul> <li><code>createEnvVarsMap()</code>: Collects environment variables with the <code>TANGRAM_WEB_</code> prefix</li> <li><code>generateComponentName()</code>: Converts plugin names to kebab-case component names</li> <li><code>load()</code>: Generates the dynamic import and registration code</li> <li><code>configureServer()</code>: Sets up watchers for hot reloading</li> </ul>"},{"location":"plugins/frontend/#troubleshooting","title":"Troubleshooting","text":"<p>If the component does not load or behaves unexpectedly, consider the following:</p> <ul> <li>Verify the environment variable path is correct and absolute</li> <li>Check console logs for fallback path messages</li> <li>Check the web console in process-compose for any errors during component loading</li> <li>Ensure the component is correctly registered in <code>vite.config.js</code></li> </ul> <p>If you see style conflicts or unexpected behavior:</p> <ul> <li>Use scoped styles to prevent CSS leaks</li> <li>Be aware of global styles that might affect your component</li> </ul> <p>If the hot reloading does not work as expected:</p> <ul> <li>Verify the env file is being watched correctly</li> <li>Check for errors in the console during reload</li> </ul>"},{"location":"plugins/examples/citypair/","title":"Origin and destination city pair","text":"<p>(hatching)</p>"},{"location":"plugins/examples/contrails/","title":"Real-time contrails","text":"<p>(hatching)</p>"},{"location":"plugins/examples/sensors/","title":"Map data receivers","text":""},{"location":"plugins/examples/sensors/#statement-of-need","title":"Statement of need","text":"<p>Mode S data is provided by the <code>jet1090</code> process, which decodes the data from aggregated various sources, such as software-defined radio devices or network streams. Each source of data corresponds to a different receiver, hence a different location.</p> <p>It is useful to visualize the position of the receivers on the map, so that the user can see where the data is coming from. The position of the receivers is provided by the <code>jet1090</code> process, which can be configured to provide the position of the receivers in the <code>config_jet1090.toml</code> file.</p> <p>See Configuring jet1090 for more details.</p>"},{"location":"plugins/examples/sensors/#implementation","title":"Implementation","text":"<p>The implementation of the map data receivers plugin is a Vue.js component that displays the positions of the receivers on the map. The implementation of this plugin is located in the <code>src/components/SensorsInfo.vue</code> file, i.e. in the default fallback location for plugins.</p> <p>Tip</p> <p>When a Vue component is a plugin, its implementation can be overridden by a custom implementation located in a different directory. This is useful if you want to have several possible implementations for a functionality, or if you want to use a different implementation for a specific use case.</p> <p>If the environment variable <code>TANGRAM_WEB_SENSORSINFO_PLUGIN</code> is defined, the plugin will be loaded from the specified path. Otherwise, it will be loaded from the default <code>src/components/</code> directory.</p> <p>The information to display is provided by the <code>tangram</code> REST API, which provides the list of receivers and their positions on the <code>/sensors</code> endpoint.</p>"},{"location":"plugins/examples/sensors/#1-declare-the-plugin-in-the-viteconfigjs-file","title":"1. Declare the plugin in the <code>vite.config.js</code> file","text":"<p>In order to use the <code>SensorsInfo</code> component as a plugin, you need to declare it in the <code>vite.config.js</code> file. This allows the Vue application to dynamically load the component when needed.</p> <pre><code>plugins: [\n  // ..., other settings\n  dynamicComponentsPlugin({\n    envPath: \"../.env\",\n    fallbackDir: \"./src/components/\",\n    availablePlugins: [\n        \"airportSearch\",\n        \"systemInfo\",\n        \"sensorsInfo\",  // &lt;-- new line\n    ],\n  }),\n],\n</code></pre>"},{"location":"plugins/examples/sensors/#2-proxy-the-sensors-endpoint","title":"2. Proxy the /sensors endpoint","text":"<p>In the <code>vite.config.js</code> file, you need to add a proxy configuration to redirect requests to the <code>/sensors</code> endpoint to the <code>tangram</code> REST API:</p> <pre><code>server: {\n  proxy: {\n    // ..., other settings\n    \"/sensors\": {\n        target: `${jet1090_service}/sensors`,\n        changeOrigin: true,\n        secure: false,\n    }\n  },\n</code></pre> <p>This proxy rule is already implemented by default. It redirects requests to the <code>/sensors</code> endpoint to the <code>jet1090</code> service, which provides the list of receivers and their positions.</p>"},{"location":"plugins/examples/sensors/#3-implement-the-vue-component","title":"3. Implement the Vue component","text":"<p>A Vue component consists of a template, a script, and a style section. The template defines the HTML structure of the component, the script contains the logic, and the style section defines the CSS styles.</p> <p>In this example, we do not need to define any styles, so we will only implement the template and the script sections.</p> <p>In the template part, we add a <code>&lt;l-geo-json&gt;</code> (Documentation) component that will display the GeoJSON data of the receivers on the map.</p> <pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;l-geo-json v-if=\"geoJsonData\" :geojson=\"geoJsonData\"&gt;&lt;/l-geo-json&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre> <p>In the script part, we will fetch the data from the <code>/sensors</code> endpoint, transform it in a GeoJSON structure and store it in a reactive variable. We will use the <code>fetch</code> API to get the data and handle it accordingly.</p> <p>The fetch command happens in the <code>mounted</code> lifecycle hook, which is called when the component is mounted to the DOM, i.e. when the component is ready to be displayed (after the page is loaded).</p> <pre><code>&lt;script&gt;\nimport { LGeoJson } from \"@vue-leaflet/vue-leaflet\";\n\nexport default {\n  name: \"SensorLayer\",\n  components: {\n    LGeoJson,\n  },\n  data() {\n    // initialize the geoJSON data\n    return {\n      geoJsonData: null,\n    };\n  },\n  async mounted() {\n    // `/sensors` is served by jet1090, the proxy is coded in vite.config.js\n    const response = await fetch(\"/sensors\");\n    const sensors = await response.json();\n    // Convert sensor data to GeoJSON format\n    this.geoJsonData = {\n      type: \"FeatureCollection\",\n      features: Object.values(sensors)\n        // only display sensors seeing at least one aircraft\n        .filter((sensor) =&gt; sensor.aircraft_count &gt; 0)\n        .map((sensor) =&gt; ({\n          type: \"Feature\",\n          geometry: {\n            type: \"Point\",\n            coordinates: [sensor.reference.longitude, sensor.reference.latitude],\n          },\n          properties: {\n            name: sensor.name,\n            aircraft_count: sensor.aircraft_count,\n          },\n        })),\n    };\n  },\n};\n&lt;/script&gt;\n</code></pre>"},{"location":"plugins/examples/sensors/#4-refer-to-the-component-in-the-main-application","title":"4. Refer to the component in the main application","text":"<p>In the <code>App.vue</code> file, use the <code>&lt;plugin-sensorsinfo /&gt;</code> component to include the plugin in the main application. This will render the component and display the sensors' positions on the map.</p> <p>Tip</p> <p>After you declared the plugin in the <code>vite.config.js</code> file, you can use the <code>&lt;plugin-sensorsinfo /&gt;</code> component in any Vue file, not only in the <code>App.vue</code> file. The import will be done dynamically based on the environment variable <code>TANGRAM_WEB_SENSORSINFO_PLUGIN</code>.</p>"},{"location":"plugins/examples/sensors/#5-reload-your-application","title":"5. Reload your application","text":"<p>Confirm the sensors are displayed on the map. The reloading of the page should be dynamic, triggered everytime you save one of the critical files.</p>"},{"location":"plugins/examples/windfield/","title":"Add a wind field layer","text":""},{"location":"plugins/examples/windfield/#statement-of-need","title":"Statement of need","text":"<p>Meteorological data is essential for understanding the impact of weather on aviation operations. Meteo France provides weather prediction data from their ARPEGE model. The most basic features include zonal and meridional wind components, but also temperature, pressure, and humidity. More advanced features are also available but we will not cover them here.</p> <p>A web API is available after registration, but we will prefer here the GRIB files that can also be downloaded directly from the data.gouv.fr initiative, also provided by Meteo France under an Open License.</p> <p>New predictions are published every 6 hours, and the data is available for 3 days in advance. The data is provided in GRIB format, which is a standard format for meteorological data. In each file, each grid point represents spatio-temporal coordinates, and the data is provided for each hour of the day. The data is available at a resolution of 0.1 degrees, which is approximately 11 km at the equator. Altitude is provided in isobars, which is a standard unit for atmospheric pressure.</p>"},{"location":"plugins/examples/windfield/#implementation","title":"Implementation","text":"<p>The objective of this plugin is to display a wind field on the map, at an isobar specified by the user. We need to work on the following steps:</p> <ol> <li>on the backend side, download the GRIB files from the data.gouv.fr initiative, and provide an API endpoint to fetch the wind field data for a specific isobar</li> <li>on the frontend side, create a Vue component that will display a slider to select an isobar, and display the corresponding wind field on the map.</li> </ol>"},{"location":"plugins/examples/windfield/#1-implement-a-backend-plugin-for-wind-information","title":"1. Implement a backend plugin for wind information","text":"<p>Create a <code>weather</code> folder in the <code>src/tangram/plugins/</code> directory, and register the plugin in the <code>__init__.py</code> file. The plugin, associated with the <code>/weather</code> router will provide an API endpoint to fetch the wind field data for a specific isobar.</p> <p>The logic for downloading the data is implemented in the <code>arpege.py</code> file.</p> <p>The code is self-explanatory, but the following points are worth noting:</p> <ul> <li>in <code>__init__.py</code>, the <code>wind(isobaric: int)</code> function returns a <code>ORJSONResponse</code> (from <code>fastapi.responses</code>) rather than a <code>JSONResponse</code>. This is because the data is large and we want to avoid the overhead of converting it to JSON. The <code>ORJSONResponse</code> is a faster alternative, based on <code>orjson</code> that can handle large data efficiently. It also automatically deals with datetime objects, which are used in the GRIB data.</li> </ul> <p>Tip</p> <p>Extra Python libraries can be included with the <code>uv add</code> command.</p> <p>The command edits both the <code>pyproject.toml</code> and the <code>uv.lock</code> files:</p> <pre><code>uv add xarray cfgrib orjson\n</code></pre> <ul> <li> <p>in <code>arpege.py</code>, the download of the GRIB file is wrapped in a try/except block. If the file is not found (or Internet is momentarily unavailable), the function will try to get the previous file (6 hours before) and return it. It can be useful to fallback to older files when the newer versions are not yet available.</p> </li> <li> <p>the <code>xarray</code> library offers a <code>load_dataset</code> and an <code>open_dataset</code> function to read GRIB files. The <code>open_dataset</code> function is used here, as it allows to read the file without loading it entirely into memory, which is useful for large files.</p> </li> </ul> <p>Warning</p> <p>There is an issue with the packaging of the <code>ecCodes</code> library that is used by <code>xarray</code> to read GRIB files. The specific version of the <code>ecCodes</code> library for Linux/arm64 is not yet available at the time of writing this documentation.</p> <p>You are most likely to be impacted by this issue if you run this plugin on Apple Silicon Mac computers. In that case, you may want to run <code>just create-tangram-aarch64</code> to create a new Docker image with the latest version of the <code>ecCodes</code> library. The <code>just tangram</code> command will then use this image to run the application.</p>"},{"location":"plugins/examples/windfield/#2-declare-the-plugin-in-the-viteconfigjs-file","title":"2. Declare the plugin in the vite.config.js file","text":"<p>The backend part of the plugin does not require any specific declaration or configuration. The frontend part will be implemented as a Vue component, which will be dynamically loaded after being declared in the <code>vite.config.js</code> file.</p> <pre><code>plugins: [\n  // ..., other settings\n  dynamicComponentsPlugin({\n    envPath: \"../.env\",\n    fallbackDir: \"./src/components/\",\n    availablePlugins: [\n        \"airportSearch\",\n        \"systemInfo\",\n        \"sensorsInfo\",\n        \"windfield\",  // &lt;-- new line\n    ],\n  }),\n],\n</code></pre>"},{"location":"plugins/examples/windfield/#3-implement-the-vue-component","title":"3. Implement the Vue component","text":"<p>The Vue component will be implemented in the <code>src/components/WindField.vue</code> file. The component will include a slider to select the isobaric level, and build the JavaScript structure required to create the wind field.</p> <p>The template part of the component will include the slider, which is bound to a <code>v-model</code> variable called <code>isobaric</code>. The slider allows the user to select an isobaric level between 100 and 1000\u00a0hPa, with a step of 50\u00a0hPa.</p> <pre><code>&lt;template&gt;\n  &lt;div class=\"wind-altitude-control\" @mousedown.stop @touchstart.stop&gt;\n    &lt;label for=\"hpa-slider\"&gt;{{ isobaric }}hPa | FL{{ FL }}&lt;/label&gt;\n    &lt;!-- @input is for the slider is moved, @change when the mouse is released --&gt;\n    &lt;input\n      id=\"hpa-slider\"\n      type=\"range\"\n      min=\"100\"\n      max=\"1000\"\n      @input=\"updateLabel\"\n      @change=\"updateValue\"\n      step=\"50\"\n      v-model=\"isobaric\"\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre> <p>The <code>&lt;input&gt;</code> element is mapped to two events: <code>@input</code> and <code>@change</code>. The <code>@input</code> event is triggered when the user moves the slider, and it updates the <code>isobaric</code> variable, together with a conversion in altitude (in flight levels, i.e. hundreds of feet. FL100 corresponds to 10,000\u00a0ft).</p> <pre><code>import { useMapStore } from \"../store\"; // Import the map store\n\nexport default {\n  name: \"WindField\",\n  data() {\n    return {\n      velocityLayer: null, // This will hold the Leaflet Velocity layer\n      store: useMapStore(),\n      isobaric: 300, // Default value in hPa (FL300)\n      FL: 300, // Default value in flight level\n    };\n  },\n  methods: {\n    updateLabel() {\n      // this method is available in the WindField.vue component\n      this.FL = this.convertHpaToFlightLevel(this.isobaric);\n    },\n    async updateValue() {\n      console.log(\"Altitude changed to:\", this.isobaric, \"hPa\");\n      // Fetch the wind field data for the selected isobaric level\n      this.fetchAndDisplay();\n    },\n  },\n};\n</code></pre> <p>The <code>@change</code> event is triggered when the user releases the slider, and it calls the <code>updateValue</code> method to fetch the wind field data for the selected isobaric level. The default value of the slides is set to 300hPa (FL300), which is a common altitude for commercial flights.</p> <p>The style section of the component is at the end of the file, with a <code>scoped</code> attribute to limit the styles to this component only.</p> <pre><code>&lt;style scoped&gt;\n.wind-altitude-control {\n  /* this specifies the positioning of the slider on the map */\n  position: absolute;\n  top: 10px;\n  left: 10px;\n  z-index: 1000;\n  padding: 10px;\n  border-radius: 5px;\n}\n/* more items */\n&lt;/style&gt;\n</code></pre>"},{"location":"plugins/examples/windfield/#4-implement-the-velocity-field","title":"4. Implement the velocity field","text":"<p>Warning</p> <p>The Leaflet Velocity plugin is not available as a vue component, only as a regular JavaScript library. Therefore, a little more work is required to integrate it into the Vue component.</p> <p>Installing a new JavaScript library in a Vue component is done by importing the library in the script section of the component.</p> <ul> <li>First, it needs to be installed in the project with npm:</li> </ul> <pre><code>npm install leaflet-velocity  # from the web folder\n</code></pre> <ul> <li>Then it needs to be imported in the <code>WindField.vue</code> component:</li> </ul> <pre><code>import L from \"leaflet\";\nimport \"leaflet-velocity\";\nimport \"leaflet-velocity/dist/leaflet-velocity.min.css\";\n</code></pre> <p>Then the difficulty will be due to the fact that the Leaflet Velocity plugin is not a Vue component, but a regular JavaScript library. Therefore, we need to create a method that will be called when the component is mounted, and which will create the velocity field on the map.</p> <p>It can only be attached to the map after the map is created, so we will use the <code>mounted</code> lifecycle hook of the Vue component, and set up a watch to initialize the wind field only after the map becomes available.</p> <p>The main Leaflet map object is available from the <code>store</code> (the structure used to share information between components) as <code>this.store.map.leafletObject</code>.</p> <pre><code>    mounted() {\n        // Wait for the map to be initialized\n        if (!this.store.map || !this.store.map.leafletObject) {\n            // Set up a watcher to initialize when map becomes available\n            const unwatch = this.$watch(\n                () =&gt; this.store.map?.leafletObject,\n                (newVal) =&gt; {\n                    if (newVal) {\n                        unwatch();\n                        this.fetchAndDisplay();\n                    }\n                },\n                { immediate: true }\n            );\n            return;\n        }\n\n        // If map is already available, just load the data\n        this.fetchAndDisplay();\n\n    },\n</code></pre> <p>Then, the <code>fetchAndDisplay</code> method will be called to fetch the wind field data from the backend and display it on the map.</p> <pre><code>    async fetchAndDisplay() {\n        const response = await fetch(`/weather/wind?isobaric=${this.isobaric}`);\n        if (!response.ok) {\n            console.error(\"Failed to fetch wind field data:\", response.statusText);\n            return;\n        }\n        const data = await response.json();\n\n        // Create a velocity layer with the fetched data\n        const velocityLayer = L.velocityLayer({\n           ... // to be filled\n        });\n\n        // Add the velocity layer to the map\n        this.store.map.leafletObject.addLayer(velocityLayer);\n    },\n</code></pre>"},{"location":"plugins/examples/windfield/#5-refer-to-the-components-in-the-main-application","title":"5. Refer to the components in the main application","text":"<p>In the <code>App.vue</code> file, use the <code>&lt;plugin-windfield /&gt;</code> component to include the plugin in the main application. This will render the component and display the slider to select the isobaric level, and also render the wind field on the map after receiving the appropriate data from the backend.</p>"},{"location":"plugins/examples/windfield/#6-reload-the-application","title":"6. Reload the application","text":"<p>Confirm the windfield is displayed on the map. It may take a few minutes to first download the GRIB file, so be patient. Once it is downloaded in the /tmp directory, it will be reused for subsequent requests. When the container is switched off, the GRIB file will be deleted, so it will need to be downloaded again on the next run.</p> <p></p> <p>Tip</p> <p>Note that the wind field that is displayed for <code>TRA6424</code> is consistent with the groundspeed and true airspeed measured by the aircraft: 30 m/s (displayed on the lower right corner of the map) roughly corresponds to 60 kts, which is compatible with the delta in the speed values in the plot. Also a higher ground speed value is observed when the aircraft is flying with a strong tail wind.</p>"}]}